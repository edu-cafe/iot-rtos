###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      11/Mar/2013  20:18:36 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\BookSrc_CM3_IAR\Software\CPU\ST\STM32\src\stm32f10x_g #
#                    pio.c                                                    #
#    Command line =  C:\BookSrc_CM3_IAR\Software\CPU\ST\STM32\src\stm32f10x_g #
#                    pio.c -lCN C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MAN #
#                    GO-Z1\IAR\OS-Probe\Flash\List\ -o                        #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\Obj\ --no_cse --no_unroll --no_inline      #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANG #
#                    O-Z1\IAR\OS-Probe\ -I C:\BookSrc_CM3_IAR\Software\EvalBo #
#                    ards\ST\MANGO-Z1\IAR\OS-Probe\..\BSP\ -I                 #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\CPU\ST\STM32\inc\ -I              #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-CPU\ -I                        #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\ -I      #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-LCD\Source\ -I                 #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-LIB\ -I                        #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex-M3\Gener #
#                    ic\IAR\ -I C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MAN #
#                    GO-Z1\IAR\OS-Probe\..\..\..\..\..\uCOS-II\Source\ -I     #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Gen #
#                    eric\RS-232\Source\ -I C:\BookSrc_CM3_IAR\Software\EvalB #
#                    oards\ST\MANGO-Z1\IAR\OS-Probe\..\..\..\..\..\uC-Probe\T #
#                    arget\Communication\Generic\RS-232\Ports\ST\STM32\ -I    #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Gen #
#                    eric\Source\ -I C:\BookSrc_CM3_IAR\Software\EvalBoards\S #
#                    T\MANGO-Z1\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\P #
#                    lugins\uCOS-II\ -Ol --use_c++_inline                     #
#    List file    =  C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\List\stm32f10x_gpio.lst                    #
#    Object file  =  C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\Obj\stm32f10x_gpio.o                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\BookSrc_CM3_IAR\Software\CPU\ST\STM32\src\stm32f10x_gpio.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_gpio.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.3
      5          * Date               : 09/22/2008
      6          * Description        : This file provides all the GPIO firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_gpio.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          /* Private define ------------------------------------------------------------*/
     22          /* ------------ RCC registers bit address in the alias region ----------- */
     23          #define AFIO_OFFSET                 (AFIO_BASE - PERIPH_BASE)
     24          
     25          /* --- EVENTCR Register ---*/
     26          /* Alias word address of EVOE bit */
     27          #define EVCR_OFFSET                 (AFIO_OFFSET + 0x00)
     28          #define EVOE_BitNumber              ((u8)0x07)
     29          #define EVCR_EVOE_BB                (PERIPH_BB_BASE + (EVCR_OFFSET * 32) + (EVOE_BitNumber * 4))
     30          
     31          #define EVCR_PORTPINCONFIG_MASK     ((u16)0xFF80)
     32          #define LSB_MASK                    ((u16)0xFFFF)
     33          #define DBGAFR_POSITION_MASK        ((u32)0x000F0000)
     34          #define DBGAFR_SWJCFG_MASK          ((u32)0xF0FFFFFF)
     35          #define DBGAFR_LOCATION_MASK        ((u32)0x00200000)
     36          #define DBGAFR_NUMBITS_MASK         ((u32)0x00100000)
     37          
     38          /* Private macro -------------------------------------------------------------*/
     39          /* Private variables ---------------------------------------------------------*/
     40          /* Private function prototypes -----------------------------------------------*/
     41          /* Private functions ---------------------------------------------------------*/
     42          
     43          /*******************************************************************************
     44          * Function Name  : GPIO_DeInit
     45          * Description    : Deinitializes the GPIOx peripheral registers to their default
     46          *                  reset values.
     47          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
     48          * Output         : None
     49          * Return         : None
     50          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     51          void GPIO_DeInit(GPIO_TypeDef* GPIOx)
     52          {
   \                     GPIO_DeInit:
   \   00000000   0xB580             PUSH     {R7,LR}
     53            /* Check the parameters */
     54            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
     55            
     56            switch (*(u32*)&GPIOx)
   \   00000002   0x....             LDR.N    R1,??DataTable4  ;; 0x40010800
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD012             BEQ.N    ??GPIO_DeInit_0
   \   00000008   0x....             LDR.N    R1,??DataTable4_1  ;; 0x40010c00
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD018             BEQ.N    ??GPIO_DeInit_1
   \   0000000E   0x....             LDR.N    R1,??DataTable4_2  ;; 0x40011000
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD01E             BEQ.N    ??GPIO_DeInit_2
   \   00000014   0x....             LDR.N    R1,??DataTable4_3  ;; 0x40011400
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD024             BEQ.N    ??GPIO_DeInit_3
   \   0000001A   0x....             LDR.N    R1,??DataTable4_4  ;; 0x40011800
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD02A             BEQ.N    ??GPIO_DeInit_4
   \   00000020   0x....             LDR.N    R1,??DataTable4_5  ;; 0x40011c00
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD030             BEQ.N    ??GPIO_DeInit_5
   \   00000026   0x....             LDR.N    R1,??DataTable4_6  ;; 0x40012000
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD036             BEQ.N    ??GPIO_DeInit_6
   \   0000002C   0xE040             B.N      ??GPIO_DeInit_7
     57            {
     58              case GPIOA_BASE:
     59                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \                     ??GPIO_DeInit_0:
   \   0000002E   0x2101             MOVS     R1,#+1
   \   00000030   0x2004             MOVS     R0,#+4
   \   00000032   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     60                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     61                break;
   \   0000003E   0xE037             B.N      ??GPIO_DeInit_8
     62          
     63              case GPIOB_BASE:
     64                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
   \                     ??GPIO_DeInit_1:
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x2008             MOVS     R0,#+8
   \   00000044   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     65                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x2008             MOVS     R0,#+8
   \   0000004C   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     66                break;
   \   00000050   0xE02E             B.N      ??GPIO_DeInit_8
     67          
     68              case GPIOC_BASE:
     69                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
   \                     ??GPIO_DeInit_2:
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x2010             MOVS     R0,#+16
   \   00000056   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     70                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x2010             MOVS     R0,#+16
   \   0000005E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     71                break;
   \   00000062   0xE025             B.N      ??GPIO_DeInit_8
     72          
     73              case GPIOD_BASE:
     74                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
   \                     ??GPIO_DeInit_3:
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0x2020             MOVS     R0,#+32
   \   00000068   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     75                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
   \   0000006C   0x2100             MOVS     R1,#+0
   \   0000006E   0x2020             MOVS     R0,#+32
   \   00000070   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     76                break;
   \   00000074   0xE01C             B.N      ??GPIO_DeInit_8
     77                
     78              case GPIOE_BASE:
     79                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
   \                     ??GPIO_DeInit_4:
   \   00000076   0x2101             MOVS     R1,#+1
   \   00000078   0x2040             MOVS     R0,#+64
   \   0000007A   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     80                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0x2040             MOVS     R0,#+64
   \   00000082   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     81                break; 
   \   00000086   0xE013             B.N      ??GPIO_DeInit_8
     82          
     83              case GPIOF_BASE:
     84                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
   \                     ??GPIO_DeInit_5:
   \   00000088   0x2101             MOVS     R1,#+1
   \   0000008A   0x2080             MOVS     R0,#+128
   \   0000008C   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     85                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x2080             MOVS     R0,#+128
   \   00000094   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     86                break;
   \   00000098   0xE00A             B.N      ??GPIO_DeInit_8
     87          
     88              case GPIOG_BASE:
     89                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
   \                     ??GPIO_DeInit_6:
   \   0000009A   0x2101             MOVS     R1,#+1
   \   0000009C   0xF44F 0x7080      MOV      R0,#+256
   \   000000A0   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     90                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
   \   000000A4   0x2100             MOVS     R1,#+0
   \   000000A6   0xF44F 0x7080      MOV      R0,#+256
   \   000000AA   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     91                break;                       
   \   000000AE   0xE7FF             B.N      ??GPIO_DeInit_8
     92          
     93              default:
     94                break;
     95            }
     96          }
   \                     ??GPIO_DeInit_7:
   \                     ??GPIO_DeInit_8:
   \   000000B0   0xBD01             POP      {R0,PC}          ;; return
     97          
     98          /*******************************************************************************
     99          * Function Name  : GPIO_AFIODeInit
    100          * Description    : Deinitializes the Alternate Functions (remap, event control
    101          *                  and EXTI configuration) registers to their default reset
    102          *                  values.
    103          * Input          : None
    104          * Output         : None
    105          * Return         : None
    106          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    107          void GPIO_AFIODeInit(void)
    108          {
   \                     GPIO_AFIODeInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    109            RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    110            RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    111          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    112          
    113          /*******************************************************************************
    114          * Function Name  : GPIO_Init
    115          * Description    : Initializes the GPIOx peripheral according to the specified
    116          *                  parameters in the GPIO_InitStruct.
    117          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    118          *                  - GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
    119          *                    contains the configuration information for the specified GPIO
    120          *                    peripheral.
    121          * Output         : None
    122          * Return         : None
    123          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    124          void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
    125          {
   \                     GPIO_Init:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    126            u32 currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2600             MOVS     R6,#+0
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2500             MOVS     R5,#+0
    127            u32 tmpreg = 0x00, pinmask = 0x00;
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x2700             MOVS     R7,#+0
    128          
    129            /* Check the parameters */
    130            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    131            assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
    132            assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
    133            
    134          /*---------------------------- GPIO Mode Configuration -----------------------*/
    135            currentmode = ((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x0F);
   \   0000000E   0xF891 0xC003      LDRB     R12,[R1, #+3]
   \   00000012   0xF01C 0x0C0F      ANDS     R12,R12,#0xF
   \   00000016   0x4662             MOV      R2,R12
    136          
    137            if ((((u32)GPIO_InitStruct->GPIO_Mode) & ((u32)0x10)) != 0x00)
   \   00000018   0xF891 0xC003      LDRB     R12,[R1, #+3]
   \   0000001C   0xEA5F 0x6CCC      LSLS     R12,R12,#+27
   \   00000020   0xD501             BPL.N    ??GPIO_Init_0
    138            { 
    139              /* Check the parameters */
    140              assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    141              /* Output mode */
    142              currentmode |= (u32)GPIO_InitStruct->GPIO_Speed;
   \   00000022   0x788B             LDRB     R3,[R1, #+2]
   \   00000024   0x431A             ORRS     R2,R3,R2
    143            }
    144          
    145          /*---------------------------- GPIO CRL Configuration ------------------------*/
    146            /* Configure the eight low port pins */
    147            if (((u32)GPIO_InitStruct->GPIO_Pin & ((u32)0x00FF)) != 0x00)
   \                     ??GPIO_Init_0:
   \   00000026   0x780B             LDRB     R3,[R1, #+0]
   \   00000028   0x061B             LSLS     R3,R3,#+24
   \   0000002A   0xD021             BEQ.N    ??GPIO_Init_1
    148            {
    149              tmpreg = GPIOx->CRL;
   \   0000002C   0x6803             LDR      R3,[R0, #+0]
    150          
    151              for (pinpos = 0x00; pinpos < 0x08; pinpos++)
   \   0000002E   0x2400             MOVS     R4,#+0
   \   00000030   0xE006             B.N      ??GPIO_Init_2
    152              {
    153                pos = ((u32)0x01) << pinpos;
    154                /* Get the port pins position */
    155                currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    156          
    157                if (currentpin == pos)
    158                {
    159                  pos = pinpos << 2;
    160                  /* Clear the corresponding low control register bits */
    161                  pinmask = ((u32)0x0F) << pos;
    162                  tmpreg &= ~pinmask;
    163          
    164                  /* Write the mode configuration in the corresponding bits */
    165                  tmpreg |= (currentmode << pos);
    166          
    167                  /* Reset the corresponding ODR bit */
    168                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    169                  {
    170                    GPIOx->BRR = (((u32)0x01) << pinpos);
    171                  }
    172                  else
    173                  {
    174                    /* Set the corresponding ODR bit */
    175                    if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
   \                     ??GPIO_Init_3:
   \   00000032   0x78CD             LDRB     R5,[R1, #+3]
   \   00000034   0x2D48             CMP      R5,#+72
   \   00000036   0xD102             BNE.N    ??GPIO_Init_4
    176                    {
    177                      GPIOx->BSRR = (((u32)0x01) << pinpos);
   \   00000038   0x2501             MOVS     R5,#+1
   \   0000003A   0x40A5             LSLS     R5,R5,R4
   \   0000003C   0x6105             STR      R5,[R0, #+16]
    178                    }
    179                  }
   \                     ??GPIO_Init_4:
   \   0000003E   0x1C64             ADDS     R4,R4,#+1
   \                     ??GPIO_Init_2:
   \   00000040   0x2C08             CMP      R4,#+8
   \   00000042   0xD214             BCS.N    ??GPIO_Init_5
   \   00000044   0x2501             MOVS     R5,#+1
   \   00000046   0x40A5             LSLS     R5,R5,R4
   \   00000048   0x880E             LDRH     R6,[R1, #+0]
   \   0000004A   0x402E             ANDS     R6,R5,R6
   \   0000004C   0x42AE             CMP      R6,R5
   \   0000004E   0xD1F6             BNE.N    ??GPIO_Init_4
   \   00000050   0x00A5             LSLS     R5,R4,#+2
   \   00000052   0x260F             MOVS     R6,#+15
   \   00000054   0xFA16 0xF705      LSLS     R7,R6,R5
   \   00000058   0x43BB             BICS     R3,R3,R7
   \   0000005A   0xFA12 0xF505      LSLS     R5,R2,R5
   \   0000005E   0x432B             ORRS     R3,R5,R3
   \   00000060   0x78CD             LDRB     R5,[R1, #+3]
   \   00000062   0x2D28             CMP      R5,#+40
   \   00000064   0xD1E5             BNE.N    ??GPIO_Init_3
   \   00000066   0x2501             MOVS     R5,#+1
   \   00000068   0x40A5             LSLS     R5,R5,R4
   \   0000006A   0x6145             STR      R5,[R0, #+20]
   \   0000006C   0xE7E7             B.N      ??GPIO_Init_4
    180                }
    181              }
    182              GPIOx->CRL = tmpreg;
   \                     ??GPIO_Init_5:
   \   0000006E   0x6003             STR      R3,[R0, #+0]
    183            }
    184          
    185          /*---------------------------- GPIO CRH Configuration ------------------------*/
    186            /* Configure the eight high port pins */
    187            if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
   \                     ??GPIO_Init_1:
   \   00000070   0x880B             LDRH     R3,[R1, #+0]
   \   00000072   0x2BFF             CMP      R3,#+255
   \   00000074   0xDD26             BLE.N    ??GPIO_Init_6
    188            {
    189              tmpreg = GPIOx->CRH;
   \   00000076   0x6843             LDR      R3,[R0, #+4]
    190              for (pinpos = 0x00; pinpos < 0x08; pinpos++)
   \   00000078   0x2400             MOVS     R4,#+0
   \   0000007A   0xE020             B.N      ??GPIO_Init_7
    191              {
    192                pos = (((u32)0x01) << (pinpos + 0x08));
   \                     ??GPIO_Init_8:
   \   0000007C   0x2501             MOVS     R5,#+1
   \   0000007E   0xF114 0x0608      ADDS     R6,R4,#+8
   \   00000082   0x40B5             LSLS     R5,R5,R6
    193                /* Get the port pins position */
    194                currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
   \   00000084   0x880E             LDRH     R6,[R1, #+0]
   \   00000086   0x402E             ANDS     R6,R5,R6
    195                if (currentpin == pos)
   \   00000088   0x42AE             CMP      R6,R5
   \   0000008A   0xD117             BNE.N    ??GPIO_Init_9
    196                {
    197                  pos = pinpos << 2;
   \   0000008C   0x00A5             LSLS     R5,R4,#+2
    198                  /* Clear the corresponding high control register bits */
    199                  pinmask = ((u32)0x0F) << pos;
   \   0000008E   0x260F             MOVS     R6,#+15
   \   00000090   0xFA16 0xF705      LSLS     R7,R6,R5
    200                  tmpreg &= ~pinmask;
   \   00000094   0x43BB             BICS     R3,R3,R7
    201          
    202                  /* Write the mode configuration in the corresponding bits */
    203                  tmpreg |= (currentmode << pos);
   \   00000096   0xFA12 0xF505      LSLS     R5,R2,R5
   \   0000009A   0x432B             ORRS     R3,R5,R3
    204          
    205                  /* Reset the corresponding ODR bit */
    206                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
   \   0000009C   0x78CD             LDRB     R5,[R1, #+3]
   \   0000009E   0x2D28             CMP      R5,#+40
   \   000000A0   0xD104             BNE.N    ??GPIO_Init_10
    207                  {
    208                    GPIOx->BRR = (((u32)0x01) << (pinpos + 0x08));
   \   000000A2   0x2501             MOVS     R5,#+1
   \   000000A4   0xF114 0x0608      ADDS     R6,R4,#+8
   \   000000A8   0x40B5             LSLS     R5,R5,R6
   \   000000AA   0x6145             STR      R5,[R0, #+20]
    209                  }
    210                  /* Set the corresponding ODR bit */
    211                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
   \                     ??GPIO_Init_10:
   \   000000AC   0x78CD             LDRB     R5,[R1, #+3]
   \   000000AE   0x2D48             CMP      R5,#+72
   \   000000B0   0xD104             BNE.N    ??GPIO_Init_9
    212                  {
    213                    GPIOx->BSRR = (((u32)0x01) << (pinpos + 0x08));
   \   000000B2   0x2501             MOVS     R5,#+1
   \   000000B4   0xF114 0x0608      ADDS     R6,R4,#+8
   \   000000B8   0x40B5             LSLS     R5,R5,R6
   \   000000BA   0x6105             STR      R5,[R0, #+16]
    214                  }
    215                }
    216              }
   \                     ??GPIO_Init_9:
   \   000000BC   0x1C64             ADDS     R4,R4,#+1
   \                     ??GPIO_Init_7:
   \   000000BE   0x2C08             CMP      R4,#+8
   \   000000C0   0xD3DC             BCC.N    ??GPIO_Init_8
    217              GPIOx->CRH = tmpreg;
   \   000000C2   0x6043             STR      R3,[R0, #+4]
    218            }
    219          }
   \                     ??GPIO_Init_6:
   \   000000C4   0xBCF0             POP      {R4-R7}
   \   000000C6   0x4770             BX       LR               ;; return
    220          
    221          /*******************************************************************************
    222          * Function Name  : GPIO_StructInit
    223          * Description    : Fills each GPIO_InitStruct member with its default value.
    224          * Input          : - GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure
    225          *                    which will be initialized.
    226          * Output         : None
    227          * Return         : None
    228          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    229          void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
    230          {
    231            /* Reset GPIO init structure parameters values */
    232            GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
   \                     GPIO_StructInit:
   \   00000000   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000004   0x8001             STRH     R1,[R0, #+0]
    233            GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
   \   00000006   0x2102             MOVS     R1,#+2
   \   00000008   0x7081             STRB     R1,[R0, #+2]
    234            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   0000000A   0x2104             MOVS     R1,#+4
   \   0000000C   0x70C1             STRB     R1,[R0, #+3]
    235          }
   \   0000000E   0x4770             BX       LR               ;; return
    236          
    237          /*******************************************************************************
    238          * Function Name  : GPIO_ReadInputDataBit
    239          * Description    : Reads the specified input port pin.
    240          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    241          *                : - GPIO_Pin:  specifies the port bit to read.
    242          *                    This parameter can be GPIO_Pin_x where x can be (0..15).
    243          * Output         : None
    244          * Return         : The input port pin value.
    245          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    246          u8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    247          {
    248            u8 bitstatus = 0x00;
   \                     GPIO_ReadInputDataBit:
   \   00000000   0x2200             MOVS     R2,#+0
    249            
    250            /* Check the parameters */
    251            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    252            assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
    253            
    254            if ((GPIOx->IDR & GPIO_Pin) != (u32)Bit_RESET)
   \   00000002   0x6880             LDR      R0,[R0, #+8]
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x4208             TST      R0,R1
   \   00000008   0xD001             BEQ.N    ??GPIO_ReadInputDataBit_0
    255            {
    256              bitstatus = (u8)Bit_SET;
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xE000             B.N      ??GPIO_ReadInputDataBit_1
    257            }
    258            else
    259            {
    260              bitstatus = (u8)Bit_RESET;
   \                     ??GPIO_ReadInputDataBit_0:
   \   0000000E   0x2200             MOVS     R2,#+0
    261            }
    262            return bitstatus;
   \                     ??GPIO_ReadInputDataBit_1:
   \   00000010   0x0010             MOVS     R0,R2
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
    263          }
    264          
    265          /*******************************************************************************
    266          * Function Name  : GPIO_ReadInputData
    267          * Description    : Reads the specified GPIO input data port.
    268          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    269          * Output         : None
    270          * Return         : GPIO input data port value.
    271          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    272          u16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
    273          {
    274            /* Check the parameters */
    275            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    276            
    277            return ((u16)GPIOx->IDR);
   \                     GPIO_ReadInputData:
   \   00000000   0x6880             LDR      R0,[R0, #+8]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x4770             BX       LR               ;; return
    278          }
    279          
    280          /*******************************************************************************
    281          * Function Name  : GPIO_ReadOutputDataBit
    282          * Description    : Reads the specified output data port bit.
    283          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    284          *                : - GPIO_Pin:  specifies the port bit to read.
    285          *                    This parameter can be GPIO_Pin_x where x can be (0..15).
    286          * Output         : None
    287          * Return         : The output port pin value.
    288          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    289          u8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    290          {
    291            u8 bitstatus = 0x00;
   \                     GPIO_ReadOutputDataBit:
   \   00000000   0x2200             MOVS     R2,#+0
    292          
    293            /* Check the parameters */
    294            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    295            assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
    296            
    297            if ((GPIOx->ODR & GPIO_Pin) != (u32)Bit_RESET)
   \   00000002   0x68C0             LDR      R0,[R0, #+12]
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x4208             TST      R0,R1
   \   00000008   0xD001             BEQ.N    ??GPIO_ReadOutputDataBit_0
    298            {
    299              bitstatus = (u8)Bit_SET;
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0xE000             B.N      ??GPIO_ReadOutputDataBit_1
    300            }
    301            else
    302            {
    303              bitstatus = (u8)Bit_RESET;
   \                     ??GPIO_ReadOutputDataBit_0:
   \   0000000E   0x2200             MOVS     R2,#+0
    304            }
    305            return bitstatus;
   \                     ??GPIO_ReadOutputDataBit_1:
   \   00000010   0x0010             MOVS     R0,R2
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x4770             BX       LR               ;; return
    306          }
    307          
    308          /*******************************************************************************
    309          * Function Name  : GPIO_ReadOutputData
    310          * Description    : Reads the specified GPIO output data port.
    311          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    312          * Output         : None
    313          * Return         : GPIO output data port value.
    314          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    315          u16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
    316          {
    317            /* Check the parameters */
    318            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    319              
    320            return ((u16)GPIOx->ODR);
   \                     GPIO_ReadOutputData:
   \   00000000   0x68C0             LDR      R0,[R0, #+12]
   \   00000002   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000004   0x4770             BX       LR               ;; return
    321          }
    322          
    323          /*******************************************************************************
    324          * Function Name  : GPIO_SetBits
    325          * Description    : Sets the selected data port bits.
    326          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    327          *                  - GPIO_Pin: specifies the port bits to be written.
    328          *                    This parameter can be any combination of GPIO_Pin_x where 
    329          *                    x can be (0..15).
    330          * Output         : None
    331          * Return         : None
    332          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    333          void GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    334          {
    335            /* Check the parameters */
    336            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    337            assert_param(IS_GPIO_PIN(GPIO_Pin));
    338            
    339            GPIOx->BSRR = GPIO_Pin;
   \                     GPIO_SetBits:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x6101             STR      R1,[R0, #+16]
    340          }
   \   00000004   0x4770             BX       LR               ;; return
    341          
    342          /*******************************************************************************
    343          * Function Name  : GPIO_ResetBits
    344          * Description    : Clears the selected data port bits.
    345          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    346          *                  - GPIO_Pin: specifies the port bits to be written.
    347          *                    This parameter can be any combination of GPIO_Pin_x where 
    348          *                    x can be (0..15).
    349          * Output         : None
    350          * Return         : None
    351          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    352          void GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    353          {
    354            /* Check the parameters */
    355            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    356            assert_param(IS_GPIO_PIN(GPIO_Pin));
    357            
    358            GPIOx->BRR = GPIO_Pin;
   \                     GPIO_ResetBits:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x6141             STR      R1,[R0, #+20]
    359          }
   \   00000004   0x4770             BX       LR               ;; return
    360          
    361          /*******************************************************************************
    362          * Function Name  : GPIO_WriteBit
    363          * Description    : Sets or clears the selected data port bit.
    364          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    365          *                  - GPIO_Pin: specifies the port bit to be written.
    366          *                    This parameter can be one of GPIO_Pin_x where x can be (0..15).
    367          *                  - BitVal: specifies the value to be written to the selected bit.
    368          *                    This parameter can be one of the BitAction enum values:
    369          *                       - Bit_RESET: to clear the port pin
    370          *                       - Bit_SET: to set the port pin
    371          * Output         : None
    372          * Return         : None
    373          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    374          void GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal)
    375          {
    376            /* Check the parameters */
    377            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    378            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    379            assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
    380            
    381            if (BitVal != Bit_RESET)
   \                     GPIO_WriteBit:
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD002             BEQ.N    ??GPIO_WriteBit_0
    382            {
    383              GPIOx->BSRR = GPIO_Pin;
   \   00000006   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000008   0x6101             STR      R1,[R0, #+16]
   \   0000000A   0xE001             B.N      ??GPIO_WriteBit_1
    384            }
    385            else
    386            {
    387              GPIOx->BRR = GPIO_Pin;
   \                     ??GPIO_WriteBit_0:
   \   0000000C   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000E   0x6141             STR      R1,[R0, #+20]
    388            }
    389          }
   \                     ??GPIO_WriteBit_1:
   \   00000010   0x4770             BX       LR               ;; return
    390          
    391          /*******************************************************************************
    392          * Function Name  : GPIO_Write
    393          * Description    : Writes data to the specified GPIO data port.
    394          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    395          *                  - PortVal: specifies the value to be written to the port output
    396          *                    data register.
    397          * Output         : None
    398          * Return         : None
    399          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    400          void GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal)
    401          {
    402            /* Check the parameters */
    403            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    404            
    405            GPIOx->ODR = PortVal;
   \                     GPIO_Write:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x60C1             STR      R1,[R0, #+12]
    406          }
   \   00000004   0x4770             BX       LR               ;; return
    407          
    408          /*******************************************************************************
    409          * Function Name  : GPIO_PinLockConfig
    410          * Description    : Locks GPIO Pins configuration registers.
    411          * Input          : - GPIOx: where x can be (A..G) to select the GPIO peripheral.
    412          *                  - GPIO_Pin: specifies the port bit to be written.
    413          *                    This parameter can be any combination of GPIO_Pin_x where 
    414          *                    x can be (0..15).
    415          * Output         : None
    416          * Return         : None
    417          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    418          void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin)
    419          {
    420            u32 tmp = 0x00010000;
   \                     GPIO_PinLockConfig:
   \   00000000   0xF45F 0x3280      MOVS     R2,#+65536
    421            
    422            /* Check the parameters */
    423            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    424            assert_param(IS_GPIO_PIN(GPIO_Pin));
    425            
    426            tmp |= GPIO_Pin;
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x430A             ORRS     R2,R1,R2
    427            /* Set LCKK bit */
    428            GPIOx->LCKR = tmp;
   \   00000008   0x6182             STR      R2,[R0, #+24]
    429            /* Reset LCKK bit */
    430            GPIOx->LCKR =  GPIO_Pin;
   \   0000000A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000000C   0x6181             STR      R1,[R0, #+24]
    431            /* Set LCKK bit */
    432            GPIOx->LCKR = tmp;
   \   0000000E   0x6182             STR      R2,[R0, #+24]
    433            /* Read LCKK bit*/
    434            tmp = GPIOx->LCKR;
   \   00000010   0x6982             LDR      R2,[R0, #+24]
    435            /* Read LCKK bit*/
    436            tmp = GPIOx->LCKR;
   \   00000012   0x6980             LDR      R0,[R0, #+24]
   \   00000014   0x0002             MOVS     R2,R0
    437          }
   \   00000016   0x4770             BX       LR               ;; return
    438          
    439          /*******************************************************************************
    440          * Function Name  : GPIO_EventOutputConfig
    441          * Description    : Selects the GPIO pin used as Event output.
    442          * Input          : - GPIO_PortSource: selects the GPIO port to be used as source
    443          *                    for Event output.
    444          *                    This parameter can be GPIO_PortSourceGPIOx where x can be
    445          *                    (A..E).
    446          *                  - GPIO_PinSource: specifies the pin for the Event output.
    447          *                    This parameter can be GPIO_PinSourcex where x can be (0..15).
    448          * Output         : None
    449          * Return         : None
    450          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    451          void GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
    452          {
    453            u32 tmpreg = 0x00;
   \                     GPIO_EventOutputConfig:
   \   00000000   0x2200             MOVS     R2,#+0
    454          
    455            /* Check the parameters */
    456            assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
    457            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    458              
    459            tmpreg = AFIO->EVCR;
   \   00000002   0x....             LDR.N    R3,??DataTable4_7  ;; 0x40010000
   \   00000004   0x681B             LDR      R3,[R3, #+0]
   \   00000006   0x001A             MOVS     R2,R3
    460            /* Clear the PORT[6:4] and PIN[3:0] bits */
    461            tmpreg &= EVCR_PORTPINCONFIG_MASK;
   \   00000008   0xF64F 0x7380      MOVW     R3,#+65408
   \   0000000C   0x401A             ANDS     R2,R3,R2
    462            tmpreg |= (u32)GPIO_PortSource << 0x04;
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xEA52 0x1200      ORRS     R2,R2,R0, LSL #+4
    463            tmpreg |= GPIO_PinSource;
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x430A             ORRS     R2,R1,R2
    464          
    465            AFIO->EVCR = tmpreg;
   \   00000018   0x....             LDR.N    R0,??DataTable4_7  ;; 0x40010000
   \   0000001A   0x6002             STR      R2,[R0, #+0]
    466          }
   \   0000001C   0x4770             BX       LR               ;; return
    467          
    468          /*******************************************************************************
    469          * Function Name  : GPIO_EventOutputCmd
    470          * Description    : Enables or disables the Event Output.
    471          * Input          : - NewState: new state of the Event output.
    472          *                    This parameter can be: ENABLE or DISABLE.
    473          * Output         : None
    474          * Return         : None
    475          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    476          void GPIO_EventOutputCmd(FunctionalState NewState)
    477          {
    478            /* Check the parameters */
    479            assert_param(IS_FUNCTIONAL_STATE(NewState));
    480            
    481            *(vu32 *) EVCR_EVOE_BB = (u32)NewState;
   \                     GPIO_EventOutputCmd:
   \   00000000   0x....             LDR.N    R1,??DataTable4_8  ;; 0x4220001c
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x6008             STR      R0,[R1, #+0]
    482          }
   \   00000006   0x4770             BX       LR               ;; return
    483          
    484          /*******************************************************************************
    485          * Function Name  : GPIO_PinRemapConfig
    486          * Description    : Changes the mapping of the specified pin.
    487          * Input          : - GPIO_Remap: selects the pin to remap.
    488          *                    This parameter can be one of the following values:
    489          *                       - GPIO_Remap_SPI1
    490          *                       - GPIO_Remap_I2C1
    491          *                       - GPIO_Remap_USART1
    492          *                       - GPIO_Remap_USART2
    493          *                       - GPIO_PartialRemap_USART3
    494          *                       - GPIO_FullRemap_USART3
    495          *                       - GPIO_PartialRemap_TIM1
    496          *                       - GPIO_FullRemap_TIM1
    497          *                       - GPIO_PartialRemap1_TIM2
    498          *                       - GPIO_PartialRemap2_TIM2
    499          *                       - GPIO_FullRemap_TIM2
    500          *                       - GPIO_PartialRemap_TIM3
    501          *                       - GPIO_FullRemap_TIM3
    502          *                       - GPIO_Remap_TIM4
    503          *                       - GPIO_Remap1_CAN
    504          *                       - GPIO_Remap2_CAN
    505          *                       - GPIO_Remap_PD01
    506          *                       - GPIO_Remap_TIM5CH4_LSI
    507          *                       - GPIO_Remap_ADC1_ETRGINJ
    508          *                       - GPIO_Remap_ADC1_ETRGREG
    509          *                       - GPIO_Remap_ADC2_ETRGINJ
    510          *                       - GPIO_Remap_ADC2_ETRGREG
    511          *                       - GPIO_Remap_SWJ_NoJTRST
    512          *                       - GPIO_Remap_SWJ_JTAGDisable
    513          *                       - GPIO_Remap_SWJ_Disable
    514          *                  - NewState: new state of the port pin remapping.
    515          *                    This parameter can be: ENABLE or DISABLE.
    516          * Output         : None
    517          * Return         : None
    518          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    519          void GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState)
    520          {
   \                     GPIO_PinRemapConfig:
   \   00000000   0xB470             PUSH     {R4-R6}
    521            u32 tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x2500             MOVS     R5,#+0
    522          
    523            /* Check the parameters */
    524            assert_param(IS_GPIO_REMAP(GPIO_Remap));
    525            assert_param(IS_FUNCTIONAL_STATE(NewState));  
    526            
    527            tmpreg = AFIO->MAPR;
   \   0000000A   0x....             LDR.N    R6,??DataTable4_9  ;; 0x40010004
   \   0000000C   0x6836             LDR      R6,[R6, #+0]
   \   0000000E   0x0033             MOVS     R3,R6
    528          
    529            tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
   \   00000010   0xF3C0 0x4603      UBFX     R6,R0,#+16,#+4
   \   00000014   0x0035             MOVS     R5,R6
    530            tmp = GPIO_Remap & LSB_MASK;
   \   00000016   0xB286             UXTH     R6,R0            ;; ZeroExt  R6,R0,#+16,#+16
   \   00000018   0x0032             MOVS     R2,R6
    531          
    532            if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
   \   0000001A   0xF410 0x1640      ANDS     R6,R0,#0x300000
   \   0000001E   0xF5B6 0x1F40      CMP      R6,#+3145728
   \   00000022   0xD108             BNE.N    ??GPIO_PinRemapConfig_0
    533            {
    534              tmpreg &= DBGAFR_SWJCFG_MASK;
   \   00000024   0xF033 0x6370      BICS     R3,R3,#0xF000000
    535              AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
   \   00000028   0x....             LDR.N    R4,??DataTable4_9  ;; 0x40010004
   \   0000002A   0x6824             LDR      R4,[R4, #+0]
   \   0000002C   0xF034 0x6470      BICS     R4,R4,#0xF000000
   \   00000030   0x....             LDR.N    R5,??DataTable4_9  ;; 0x40010004
   \   00000032   0x602C             STR      R4,[R5, #+0]
   \   00000034   0xE00F             B.N      ??GPIO_PinRemapConfig_1
    536            }
    537            else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
   \                     ??GPIO_PinRemapConfig_0:
   \   00000036   0x02C4             LSLS     R4,R0,#+11
   \   00000038   0xD505             BPL.N    ??GPIO_PinRemapConfig_2
    538            {
    539              tmp1 = ((u32)0x03) << tmpmask;
   \   0000003A   0x2403             MOVS     R4,#+3
   \   0000003C   0x40AC             LSLS     R4,R4,R5
    540              tmpreg &= ~tmp1;
   \   0000003E   0x43A3             BICS     R3,R3,R4
    541              tmpreg |= ~DBGAFR_SWJCFG_MASK;
   \   00000040   0xF053 0x6370      ORRS     R3,R3,#0xF000000
   \   00000044   0xE007             B.N      ??GPIO_PinRemapConfig_1
    542            }
    543            else
    544            {
    545              tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
   \                     ??GPIO_PinRemapConfig_2:
   \   00000046   0x0D44             LSRS     R4,R0,#+21
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0x0124             LSLS     R4,R4,#+4
   \   0000004C   0xFA12 0xF404      LSLS     R4,R2,R4
   \   00000050   0x43A3             BICS     R3,R3,R4
    546              tmpreg |= ~DBGAFR_SWJCFG_MASK;
   \   00000052   0xF053 0x6370      ORRS     R3,R3,#0xF000000
    547            }
    548          
    549            if (NewState != DISABLE)
   \                     ??GPIO_PinRemapConfig_1:
   \   00000056   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000058   0x2900             CMP      R1,#+0
   \   0000005A   0xD005             BEQ.N    ??GPIO_PinRemapConfig_3
    550            {
    551              tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
   \   0000005C   0x0D40             LSRS     R0,R0,#+21
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x0100             LSLS     R0,R0,#+4
   \   00000062   0xFA12 0xF000      LSLS     R0,R2,R0
   \   00000066   0x4303             ORRS     R3,R0,R3
    552            }
    553          
    554            AFIO->MAPR = tmpreg;
   \                     ??GPIO_PinRemapConfig_3:
   \   00000068   0x....             LDR.N    R0,??DataTable4_9  ;; 0x40010004
   \   0000006A   0x6003             STR      R3,[R0, #+0]
    555          }
   \   0000006C   0xBC70             POP      {R4-R6}
   \   0000006E   0x4770             BX       LR               ;; return
    556          
    557          /*******************************************************************************
    558          * Function Name  : GPIO_EXTILineConfig
    559          * Description    : Selects the GPIO pin used as EXTI Line.
    560          * Input          : - GPIO_PortSource: selects the GPIO port to be used as
    561          *                    source for EXTI lines.
    562          *                    This parameter can be GPIO_PortSourceGPIOx where x can be
    563          *                    (A..G).
    564          *                  - GPIO_PinSource: specifies the EXTI line to be configured.
    565          *                   This parameter can be GPIO_PinSourcex where x can be (0..15).
    566          * Output         : None
    567          * Return         : None
    568          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    569          void GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource)
    570          {
   \                     GPIO_EXTILineConfig:
   \   00000000   0xB410             PUSH     {R4}
    571            u32 tmp = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
    572          
    573            /* Check the parameters */
    574            assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
    575            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    576            
    577            tmp = ((u32)0x0F) << (0x04 * (GPIO_PinSource & (u8)0x03));
   \   00000004   0x230F             MOVS     R3,#+15
   \   00000006   0xF011 0x0403      ANDS     R4,R1,#0x3
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x00A4             LSLS     R4,R4,#+2
   \   0000000E   0x40A3             LSLS     R3,R3,R4
   \   00000010   0x001A             MOVS     R2,R3
    578          
    579            AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
   \   00000012   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000014   0x108B             ASRS     R3,R1,#+2
   \   00000016   0x....             LDR.N    R4,??DataTable4_10  ;; 0x40010008
   \   00000018   0xF854 0x3023      LDR      R3,[R4, R3, LSL #+2]
   \   0000001C   0xEA33 0x0202      BICS     R2,R3,R2
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0x108B             ASRS     R3,R1,#+2
   \   00000024   0x....             LDR.N    R4,??DataTable4_10  ;; 0x40010008
   \   00000026   0xF844 0x2023      STR      R2,[R4, R3, LSL #+2]
    580            AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((u32)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (u8)0x03)));
   \   0000002A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002C   0x108A             ASRS     R2,R1,#+2
   \   0000002E   0x....             LDR.N    R3,??DataTable4_10  ;; 0x40010008
   \   00000030   0xF853 0x2022      LDR      R2,[R3, R2, LSL #+2]
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0xF011 0x0303      ANDS     R3,R1,#0x3
   \   0000003A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003C   0x009B             LSLS     R3,R3,#+2
   \   0000003E   0x4098             LSLS     R0,R0,R3
   \   00000040   0x4310             ORRS     R0,R0,R2
   \   00000042   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000044   0x1089             ASRS     R1,R1,#+2
   \   00000046   0x....             LDR.N    R2,??DataTable4_10  ;; 0x40010008
   \   00000048   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    581          }
   \   0000004C   0xBC10             POP      {R4}
   \   0000004E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x40011800         DC32     0x40011800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x40011C00         DC32     0x40011c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x40012000         DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x40010000         DC32     0x40010000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x4220001C         DC32     0x4220001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x40010004         DC32     0x40010004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x40010008         DC32     0x40010008
    582          
    583          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   GPIO_AFIODeInit
         8   -> RCC_APB2PeriphResetCmd
       8   GPIO_DeInit
         8   -> RCC_APB2PeriphResetCmd
       4   GPIO_EXTILineConfig
       0   GPIO_EventOutputCmd
       0   GPIO_EventOutputConfig
      16   GPIO_Init
       0   GPIO_PinLockConfig
      12   GPIO_PinRemapConfig
       0   GPIO_ReadInputData
       0   GPIO_ReadInputDataBit
       0   GPIO_ReadOutputData
       0   GPIO_ReadOutputDataBit
       0   GPIO_ResetBits
       0   GPIO_SetBits
       0   GPIO_StructInit
       0   GPIO_Write
       0   GPIO_WriteBit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      20  GPIO_AFIODeInit
     178  GPIO_DeInit
      80  GPIO_EXTILineConfig
       8  GPIO_EventOutputCmd
      30  GPIO_EventOutputConfig
     200  GPIO_Init
      24  GPIO_PinLockConfig
     112  GPIO_PinRemapConfig
       6  GPIO_ReadInputData
      22  GPIO_ReadInputDataBit
       6  GPIO_ReadOutputData
      22  GPIO_ReadOutputDataBit
       6  GPIO_ResetBits
       6  GPIO_SetBits
      16  GPIO_StructInit
       6  GPIO_Write
      18  GPIO_WriteBit

 
 804 bytes in section .text
 
 804 bytes of CODE memory

Errors: none
Warnings: none
