###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      11/Mar/2013  20:18:28 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\BookSrc_CM3_IAR\Software\CPU\ST\STM32\src\stm32f10x_n #
#                    vic.c                                                    #
#    Command line =  C:\BookSrc_CM3_IAR\Software\CPU\ST\STM32\src\stm32f10x_n #
#                    vic.c -lCN C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MAN #
#                    GO-Z1\IAR\OS-Probe\Flash\List\ -o                        #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\Obj\ --no_cse --no_unroll --no_inline      #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANG #
#                    O-Z1\IAR\OS-Probe\ -I C:\BookSrc_CM3_IAR\Software\EvalBo #
#                    ards\ST\MANGO-Z1\IAR\OS-Probe\..\BSP\ -I                 #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\CPU\ST\STM32\inc\ -I              #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-CPU\ -I                        #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\ -I      #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-LCD\Source\ -I                 #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-LIB\ -I                        #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex-M3\Gener #
#                    ic\IAR\ -I C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MAN #
#                    GO-Z1\IAR\OS-Probe\..\..\..\..\..\uCOS-II\Source\ -I     #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Gen #
#                    eric\RS-232\Source\ -I C:\BookSrc_CM3_IAR\Software\EvalB #
#                    oards\ST\MANGO-Z1\IAR\OS-Probe\..\..\..\..\..\uC-Probe\T #
#                    arget\Communication\Generic\RS-232\Ports\ST\STM32\ -I    #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Gen #
#                    eric\Source\ -I C:\BookSrc_CM3_IAR\Software\EvalBoards\S #
#                    T\MANGO-Z1\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\P #
#                    lugins\uCOS-II\ -Ol --use_c++_inline                     #
#    List file    =  C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\List\stm32f10x_nvic.lst                    #
#    Object file  =  C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\Obj\stm32f10x_nvic.o                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\BookSrc_CM3_IAR\Software\CPU\ST\STM32\src\stm32f10x_nvic.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_nvic.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.3
      5          * Date               : 09/22/2008
      6          * Description        : This file provides all the NVIC firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_nvic.h"
     18          
     19          /* Private typedef -----------------------------------------------------------*/
     20          /* Private define ------------------------------------------------------------*/
     21          #define AIRCR_VECTKEY_MASK    ((u32)0x05FA0000)
     22          
     23          /* Private macro -------------------------------------------------------------*/
     24          /* Private variables ---------------------------------------------------------*/
     25          /* Private function prototypes -----------------------------------------------*/
     26          /* Private functions ---------------------------------------------------------*/
     27          
     28          /*******************************************************************************
     29          * Function Name  : NVIC_DeInit
     30          * Description    : Deinitializes the NVIC peripheral registers to their default
     31          *                  reset values.
     32          * Input          : None
     33          * Output         : None
     34          * Return         : None
     35          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     36          void NVIC_DeInit(void)
     37          {
     38            u32 index = 0;
   \                     NVIC_DeInit:
   \   00000000   0x2000             MOVS     R0,#+0
     39            
     40            NVIC->ICER[0] = 0xFFFFFFFF;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable22  ;; 0xe000e180
   \   00000006   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000000A   0x600A             STR      R2,[R1, #+0]
     41            NVIC->ICER[1] = 0x0FFFFFFF;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable22_1  ;; 0xe000e184
   \   00000010   0xF07F 0x4270      MVNS     R2,#-268435456
   \   00000014   0x600A             STR      R2,[R1, #+0]
     42            NVIC->ICPR[0] = 0xFFFFFFFF;
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable22_2  ;; 0xe000e280
   \   0000001A   0xF05F 0x32FF      MOVS     R2,#-1
   \   0000001E   0x600A             STR      R2,[R1, #+0]
     43            NVIC->ICPR[1] = 0x0FFFFFFF;
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable22_3  ;; 0xe000e284
   \   00000024   0xF07F 0x4270      MVNS     R2,#-268435456
   \   00000028   0x600A             STR      R2,[R1, #+0]
     44            
     45            for(index = 0; index < 0x0F; index++)
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x0008             MOVS     R0,R1
   \   0000002E   0xE005             B.N      ??NVIC_DeInit_0
     46            {
     47               NVIC->IPR[index] = 0x00000000;
   \                     ??NVIC_DeInit_1:
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable22_4  ;; 0xe000e400
   \   00000034   0x2200             MOVS     R2,#+0
   \   00000036   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
     48            } 
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \                     ??NVIC_DeInit_0:
   \   0000003C   0x280F             CMP      R0,#+15
   \   0000003E   0xD3F7             BCC.N    ??NVIC_DeInit_1
     49          }
   \   00000040   0x4770             BX       LR               ;; return
     50          
     51          /*******************************************************************************
     52          * Function Name  : NVIC_SCBDeInit
     53          * Description    : Deinitializes the SCB peripheral registers to their default 
     54          *                  reset values.
     55          * Input          : None
     56          * Output         : None
     57          * Return         : None
     58          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     59          void NVIC_SCBDeInit(void)
     60          {
     61            u32 index = 0x00;
   \                     NVIC_SCBDeInit:
   \   00000000   0x2000             MOVS     R0,#+0
     62            
     63            SCB->ICSR = 0x0A000000;
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable22_5  ;; 0xe000ed04
   \   00000006   0xF05F 0x6220      MOVS     R2,#+167772160
   \   0000000A   0x600A             STR      R2,[R1, #+0]
     64            SCB->VTOR = 0x00000000;
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable22_6  ;; 0xe000ed08
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x600A             STR      R2,[R1, #+0]
     65            SCB->AIRCR = AIRCR_VECTKEY_MASK;
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable22_7  ;; 0xe000ed0c
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable22_8  ;; 0x5fa0000
   \   0000001C   0x600A             STR      R2,[R1, #+0]
     66            SCB->SCR = 0x00000000;
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable22_9  ;; 0xe000ed10
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x600A             STR      R2,[R1, #+0]
     67            SCB->CCR = 0x00000000;
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable22_10  ;; 0xe000ed14
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x600A             STR      R2,[R1, #+0]
     68            for(index = 0; index < 0x03; index++)
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x0008             MOVS     R0,R1
   \   00000032   0xE005             B.N      ??NVIC_SCBDeInit_0
     69            {
     70               SCB->SHPR[index] = 0;
   \                     ??NVIC_SCBDeInit_1:
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable22_11  ;; 0xe000ed18
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
     71            }
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \                     ??NVIC_SCBDeInit_0:
   \   00000040   0x2803             CMP      R0,#+3
   \   00000042   0xD3F7             BCC.N    ??NVIC_SCBDeInit_1
     72            SCB->SHCSR = 0x00000000;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable22_12  ;; 0xe000ed24
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x6001             STR      R1,[R0, #+0]
     73            SCB->CFSR = 0xFFFFFFFF;
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable22_13  ;; 0xe000ed28
   \   00000050   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000054   0x6001             STR      R1,[R0, #+0]
     74            SCB->HFSR = 0xFFFFFFFF;
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable22_14  ;; 0xe000ed2c
   \   0000005A   0xF05F 0x31FF      MOVS     R1,#-1
   \   0000005E   0x6001             STR      R1,[R0, #+0]
     75            SCB->DFSR = 0xFFFFFFFF;
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable22_15  ;; 0xe000ed30
   \   00000064   0xF05F 0x31FF      MOVS     R1,#-1
   \   00000068   0x6001             STR      R1,[R0, #+0]
     76          }
   \   0000006A   0x4770             BX       LR               ;; return
     77          
     78          /*******************************************************************************
     79          * Function Name  : NVIC_PriorityGroupConfig
     80          * Description    : Configures the priority grouping: pre-emption priority
     81          *                  and subpriority.
     82          * Input          : - NVIC_PriorityGroup: specifies the priority grouping bits
     83          *                    length. This parameter can be one of the following values:
     84          *                       - NVIC_PriorityGroup_0: 0 bits for pre-emption priority
     85          *                         4 bits for subpriority
     86          *                       - NVIC_PriorityGroup_1: 1 bits for pre-emption priority
     87          *                         3 bits for subpriority
     88          *                       - NVIC_PriorityGroup_2: 2 bits for pre-emption priority
     89          *                         2 bits for subpriority
     90          *                       - NVIC_PriorityGroup_3: 3 bits for pre-emption priority
     91          *                         1 bits for subpriority
     92          *                       - NVIC_PriorityGroup_4: 4 bits for pre-emption priority
     93          *                         0 bits for subpriority
     94          * Output         : None
     95          * Return         : None
     96          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     97          void NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup)
     98          {
     99            /* Check the parameters */
    100            assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
    101            
    102            /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
    103            SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
   \                     NVIC_PriorityGroupConfig:
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable22_8  ;; 0x5fa0000
   \   00000004   0x4308             ORRS     R0,R1,R0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable22_7  ;; 0xe000ed0c
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    104          }
   \   0000000C   0x4770             BX       LR               ;; return
    105          
    106          /*******************************************************************************
    107          * Function Name  : NVIC_Init
    108          * Description    : Initializes the NVIC peripheral according to the specified
    109          *                  parameters in the NVIC_InitStruct.
    110          * Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure
    111          *                    that contains the configuration information for the
    112          *                    specified NVIC peripheral.
    113          * Output         : None
    114          * Return         : None
    115          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    116          void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
    117          {
   \                     NVIC_Init:
   \   00000000   0xB470             PUSH     {R4-R6}
    118            u32 tmppriority = 0x00, tmpreg = 0x00, tmpmask = 0x00;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
    119            u32 tmppre = 0, tmpsub = 0x0F;
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x250F             MOVS     R5,#+15
    120          
    121            /* Check the parameters */
    122            assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
    123            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_InitStruct->NVIC_IRQChannel));
    124            assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
    125            assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    126              
    127            if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
   \   0000000C   0x78C6             LDRB     R6,[R0, #+3]
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD035             BEQ.N    ??NVIC_Init_0
    128            {
    129              /* Compute the Corresponding IRQ Priority --------------------------------*/    
    130              tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
   \   00000012   0x....             LDR.N    R1,??DataTable22_7  ;; 0xe000ed0c
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0xF411 0x61E0      ANDS     R1,R1,#0x700
   \   0000001A   0xF5D1 0x61E0      RSBS     R1,R1,#+1792
   \   0000001E   0x0A09             LSRS     R1,R1,#+8
    131              tmppre = (0x4 - tmppriority);
   \   00000020   0xF1D1 0x0404      RSBS     R4,R1,#+4
    132              tmpsub = tmpsub >> tmppriority;
   \   00000024   0x40CD             LSRS     R5,R5,R1
    133              
    134              tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
   \   00000026   0x7841             LDRB     R1,[R0, #+1]
   \   00000028   0x40A1             LSLS     R1,R1,R4
    135              tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
   \   0000002A   0x7882             LDRB     R2,[R0, #+2]
   \   0000002C   0x402A             ANDS     R2,R5,R2
   \   0000002E   0x4311             ORRS     R1,R2,R1
    136          
    137              tmppriority = tmppriority << 0x04;
   \   00000030   0x0109             LSLS     R1,R1,#+4
    138              tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
   \   00000032   0x7802             LDRB     R2,[R0, #+0]
   \   00000034   0xF012 0x0203      ANDS     R2,R2,#0x3
   \   00000038   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000003A   0x00D2             LSLS     R2,R2,#+3
   \   0000003C   0x4091             LSLS     R1,R1,R2
    139              
    140              tmpreg = NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
   \   0000003E   0x7802             LDRB     R2,[R0, #+0]
   \   00000040   0x1092             ASRS     R2,R2,#+2
   \   00000042   0x....             LDR.N    R3,??DataTable22_4  ;; 0xe000e400
   \   00000044   0xF853 0x2022      LDR      R2,[R3, R2, LSL #+2]
    141              tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
   \   00000048   0x23FF             MOVS     R3,#+255
   \   0000004A   0x7804             LDRB     R4,[R0, #+0]
   \   0000004C   0xF014 0x0403      ANDS     R4,R4,#0x3
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x00E4             LSLS     R4,R4,#+3
   \   00000054   0x40A3             LSLS     R3,R3,R4
    142              tmpreg &= ~tmpmask;
   \   00000056   0x439A             BICS     R2,R2,R3
    143              tmppriority &= tmpmask;  
   \   00000058   0x4019             ANDS     R1,R3,R1
    144              tmpreg |= tmppriority;
   \   0000005A   0x430A             ORRS     R2,R1,R2
    145          
    146              NVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
   \   0000005C   0x7801             LDRB     R1,[R0, #+0]
   \   0000005E   0x1089             ASRS     R1,R1,#+2
   \   00000060   0x....             LDR.N    R3,??DataTable22_4  ;; 0xe000e400
   \   00000062   0xF843 0x2021      STR      R2,[R3, R1, LSL #+2]
    147              
    148              /* Enable the Selected IRQ Channels --------------------------------------*/
    149              NVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    150                (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
   \   00000066   0x7801             LDRB     R1,[R0, #+0]
   \   00000068   0x1149             ASRS     R1,R1,#+5
   \   0000006A   0x....             LDR.N    R2,??DataTable22_16  ;; 0xe000e100
   \   0000006C   0x2301             MOVS     R3,#+1
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000074   0xFA13 0xF000      LSLS     R0,R3,R0
   \   00000078   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   \   0000007C   0xE00A             B.N      ??NVIC_Init_1
    151            }
    152            else
    153            {
    154              /* Disable the Selected IRQ Channels -------------------------------------*/
    155              NVIC->ICER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    156                (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
   \                     ??NVIC_Init_0:
   \   0000007E   0x7801             LDRB     R1,[R0, #+0]
   \   00000080   0x1149             ASRS     R1,R1,#+5
   \   00000082   0x....             LDR.N    R2,??DataTable22  ;; 0xe000e180
   \   00000084   0x2301             MOVS     R3,#+1
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000008C   0xFA13 0xF000      LSLS     R0,R3,R0
   \   00000090   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    157            }
    158          }
   \                     ??NVIC_Init_1:
   \   00000094   0xBC70             POP      {R4-R6}
   \   00000096   0x4770             BX       LR               ;; return
    159          
    160          /*******************************************************************************
    161          * Function Name  : NVIC_StructInit
    162          * Description    : Fills each NVIC_InitStruct member with its default value.
    163          * Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure which
    164          *                    will be initialized.
    165          * Output         : None
    166          * Return         : None
    167          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    168          void NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct)
    169          {
    170            /* NVIC_InitStruct members default value */
    171            NVIC_InitStruct->NVIC_IRQChannel = 0x00;
   \                     NVIC_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    172            NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority = 0x00;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7041             STRB     R1,[R0, #+1]
    173            NVIC_InitStruct->NVIC_IRQChannelSubPriority = 0x00;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7081             STRB     R1,[R0, #+2]
    174            NVIC_InitStruct->NVIC_IRQChannelCmd = DISABLE;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x70C1             STRB     R1,[R0, #+3]
    175          }
   \   00000010   0x4770             BX       LR               ;; return
    176          
    177          /*******************************************************************************
    178          * Function Name  : NVIC_SETPRIMASK
    179          * Description    : Enables the PRIMASK priority: Raises the execution priority to 0.
    180          * Input          : None
    181          * Output         : None
    182          * Return         : None
    183          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    184          void NVIC_SETPRIMASK(void)
    185          {
   \                     NVIC_SETPRIMASK:
   \   00000000   0xB580             PUSH     {R7,LR}
    186            __SETPRIMASK();
   \   00000002   0x.... 0x....      BL       __SETPRIMASK
    187          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    188          
    189          /*******************************************************************************
    190          * Function Name  : NVIC_RESETPRIMASK
    191          * Description    : Disables the PRIMASK priority.
    192          * Input          : None
    193          * Output         : None
    194          * Return         : None
    195          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    196          void NVIC_RESETPRIMASK(void)
    197          {
   \                     NVIC_RESETPRIMASK:
   \   00000000   0xB580             PUSH     {R7,LR}
    198            __RESETPRIMASK();
   \   00000002   0x.... 0x....      BL       __RESETPRIMASK
    199          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    200          
    201          /*******************************************************************************
    202          * Function Name  : NVIC_SETFAULTMASK
    203          * Description    : Enables the FAULTMASK priority: Raises the execution priority to -1.
    204          * Input          : None
    205          * Output         : None
    206          * Return         : None
    207          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    208          void NVIC_SETFAULTMASK(void)
    209          {
   \                     NVIC_SETFAULTMASK:
   \   00000000   0xB580             PUSH     {R7,LR}
    210            __SETFAULTMASK();
   \   00000002   0x.... 0x....      BL       __SETFAULTMASK
    211          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    212          
    213          /*******************************************************************************
    214          * Function Name  : NVIC_RESETFAULTMASK
    215          * Description    : Disables the FAULTMASK priority.
    216          * Input          : None
    217          * Output         : None
    218          * Return         : None
    219          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    220          void NVIC_RESETFAULTMASK(void)
    221          {
   \                     NVIC_RESETFAULTMASK:
   \   00000000   0xB580             PUSH     {R7,LR}
    222            __RESETFAULTMASK();
   \   00000002   0x.... 0x....      BL       __RESETFAULTMASK
    223          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
    224          
    225          /*******************************************************************************
    226          * Function Name  : NVIC_BASEPRICONFIG
    227          * Description    : The execution priority can be changed from 15 (lowest 
    228                             configurable priority) to 1. Writing a zero  value will disable 
    229          *                  the mask of execution priority.
    230          * Input          : None
    231          * Output         : None
    232          * Return         : None
    233          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    234          void NVIC_BASEPRICONFIG(u32 NewPriority)
    235          {
   \                     NVIC_BASEPRICONFIG:
   \   00000000   0xB580             PUSH     {R7,LR}
    236            /* Check the parameters */
    237            assert_param(IS_NVIC_BASE_PRI(NewPriority));
    238            
    239            __BASEPRICONFIG(NewPriority << 0x04);
   \   00000002   0x0100             LSLS     R0,R0,#+4
   \   00000004   0x.... 0x....      BL       __BASEPRICONFIG
    240          }
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    241          
    242          /*******************************************************************************
    243          * Function Name  : NVIC_GetBASEPRI
    244          * Description    : Returns the BASEPRI mask value.
    245          * Input          : None
    246          * Output         : None
    247          * Return         : BASEPRI register value
    248          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    249          u32 NVIC_GetBASEPRI(void)
    250          {
   \                     NVIC_GetBASEPRI:
   \   00000000   0xB580             PUSH     {R7,LR}
    251            return (__GetBASEPRI());
   \   00000002   0x.... 0x....      BL       __GetBASEPRI
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
    252          }
    253          
    254          /*******************************************************************************
    255          * Function Name  : NVIC_GetCurrentPendingIRQChannel
    256          * Description    : Returns the current pending IRQ channel identifier.
    257          * Input          : None
    258          * Output         : None
    259          * Return         : Pending IRQ Channel Identifier.
    260          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    261          u16 NVIC_GetCurrentPendingIRQChannel(void)
    262          {
    263            return ((u16)((SCB->ICSR & (u32)0x003FF000) >> 0x0C));
   \                     NVIC_GetCurrentPendingIRQChannel:
   \   00000000   0x....             LDR.N    R0,??DataTable22_5  ;; 0xe000ed04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0B00             LSRS     R0,R0,#+12
   \   00000006   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   00000008   0x0D80             LSRS     R0,R0,#+22
   \   0000000A   0x4770             BX       LR               ;; return
    264          }
    265          
    266          /*******************************************************************************
    267          * Function Name  : NVIC_GetIRQChannelPendingBitStatus
    268          * Description    : Checks whether the specified IRQ Channel pending bit is set
    269          *                  or not.
    270          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to check.
    271          * Output         : None
    272          * Return         : The new state of IRQ Channel pending bit(SET or RESET).
    273          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    274          ITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel)
    275          {
   \                     NVIC_GetIRQChannelPendingBitStatus:
   \   00000000   0xB410             PUSH     {R4}
    276            ITStatus pendingirqstatus = RESET;
   \   00000002   0x2100             MOVS     R1,#+0
    277            u32 tmp = 0x00;
   \   00000004   0x2200             MOVS     R2,#+0
    278            
    279            /* Check the parameters */
    280            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    281            
    282            tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   0000000C   0x40A3             LSLS     R3,R3,R4
   \   0000000E   0x001A             MOVS     R2,R3
    283          
    284            if (((NVIC->ISPR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp)
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x1140             ASRS     R0,R0,#+5
   \   00000014   0x....             LDR.N    R3,??DataTable22_17  ;; 0xe000e200
   \   00000016   0xF853 0x0020      LDR      R0,[R3, R0, LSL #+2]
   \   0000001A   0x4010             ANDS     R0,R2,R0
   \   0000001C   0x4290             CMP      R0,R2
   \   0000001E   0xD101             BNE.N    ??NVIC_GetIRQChannelPendingBitStatus_0
    285            {
    286              pendingirqstatus = SET;
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0xE000             B.N      ??NVIC_GetIRQChannelPendingBitStatus_1
    287            }
    288            else
    289            {
    290              pendingirqstatus = RESET;
   \                     ??NVIC_GetIRQChannelPendingBitStatus_0:
   \   00000024   0x2100             MOVS     R1,#+0
    291            }
    292            return pendingirqstatus;
   \                     ??NVIC_GetIRQChannelPendingBitStatus_1:
   \   00000026   0x0008             MOVS     R0,R1
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBC10             POP      {R4}
   \   0000002C   0x4770             BX       LR               ;; return
    293          }
    294          
    295          /*******************************************************************************
    296          * Function Name  : NVIC_SetIRQChannelPendingBit
    297          * Description    : Sets the NVIC’s interrupt pending bit.
    298          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to Set.
    299          * Output         : None
    300          * Return         : None
    301          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    302          void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
    303          {
    304            /* Check the parameters */
    305            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    306            
    307            *(vu32*) 0xE000EF00 = (u32)NVIC_IRQChannel;
   \                     NVIC_SetIRQChannelPendingBit:
   \   00000000   0x....             LDR.N    R1,??DataTable22_18  ;; 0xe000ef00
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x6008             STR      R0,[R1, #+0]
    308          }
   \   00000006   0x4770             BX       LR               ;; return
    309          
    310          /*******************************************************************************
    311          * Function Name  : NVIC_ClearIRQChannelPendingBit
    312          * Description    : Clears the NVIC’s interrupt pending bit.
    313          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to clear.
    314          * Output         : None
    315          * Return         : None
    316          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    317          void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
    318          {
    319            /* Check the parameters */
    320            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    321            
    322            NVIC->ICPR[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u32)0x1F);
   \                     NVIC_ClearIRQChannelPendingBit:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x1141             ASRS     R1,R0,#+5
   \   00000004   0x....             LDR.N    R2,??DataTable22_2  ;; 0xe000e280
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   0000000C   0xFA13 0xF000      LSLS     R0,R3,R0
   \   00000010   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    323          }
   \   00000014   0x4770             BX       LR               ;; return
    324          
    325          /*******************************************************************************
    326          * Function Name  : NVIC_GetCurrentActiveHandler
    327          * Description    : Returns the current active Handler (IRQ Channel and
    328          *                  SystemHandler) identifier.
    329          * Input          : None
    330          * Output         : None
    331          * Return         : Active Handler Identifier.
    332          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    333          u16 NVIC_GetCurrentActiveHandler(void)
    334          {
    335            return ((u16)(SCB->ICSR & (u32)0x3FF));
   \                     NVIC_GetCurrentActiveHandler:
   \   00000000   0x....             LDR.N    R0,??DataTable22_5  ;; 0xe000ed04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0580             LSLS     R0,R0,#+22       ;; ZeroExtS R0,R0,#+22,#+22
   \   00000006   0x0D80             LSRS     R0,R0,#+22
   \   00000008   0x4770             BX       LR               ;; return
    336          }
    337          
    338          /*******************************************************************************
    339          * Function Name  : NVIC_GetIRQChannelActiveBitStatus
    340          * Description    : Checks whether the specified IRQ Channel active bit is set
    341          *                  or not.
    342          * Input          : - NVIC_IRQChannel: specifies the interrupt active bit to check.
    343          * Output         : None
    344          * Return         : The new state of IRQ Channel active bit(SET or RESET).
    345          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    346          ITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel)
    347          {
   \                     NVIC_GetIRQChannelActiveBitStatus:
   \   00000000   0xB410             PUSH     {R4}
    348            ITStatus activeirqstatus = RESET;
   \   00000002   0x2100             MOVS     R1,#+0
    349            u32 tmp = 0x00;
   \   00000004   0x2200             MOVS     R2,#+0
    350          
    351            /* Check the parameters */
    352            assert_param(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    353            
    354            tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0xF010 0x041F      ANDS     R4,R0,#0x1F
   \   0000000C   0x40A3             LSLS     R3,R3,R4
   \   0000000E   0x001A             MOVS     R2,R3
    355          
    356            if (((NVIC->IABR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp )
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x1140             ASRS     R0,R0,#+5
   \   00000014   0x....             LDR.N    R3,??DataTable22_19  ;; 0xe000e300
   \   00000016   0xF853 0x0020      LDR      R0,[R3, R0, LSL #+2]
   \   0000001A   0x4010             ANDS     R0,R2,R0
   \   0000001C   0x4290             CMP      R0,R2
   \   0000001E   0xD101             BNE.N    ??NVIC_GetIRQChannelActiveBitStatus_0
    357            {
    358              activeirqstatus = SET;
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0xE000             B.N      ??NVIC_GetIRQChannelActiveBitStatus_1
    359            }
    360            else
    361            {
    362              activeirqstatus = RESET;
   \                     ??NVIC_GetIRQChannelActiveBitStatus_0:
   \   00000024   0x2100             MOVS     R1,#+0
    363            }
    364            return activeirqstatus;
   \                     ??NVIC_GetIRQChannelActiveBitStatus_1:
   \   00000026   0x0008             MOVS     R0,R1
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0xBC10             POP      {R4}
   \   0000002C   0x4770             BX       LR               ;; return
    365          }
    366          
    367          /*******************************************************************************
    368          * Function Name  : NVIC_GetCPUID
    369          * Description    : Returns the ID number, the version number and the implementation
    370          *                  details of the Cortex-M3 core.
    371          * Input          : None
    372          * Output         : None
    373          * Return         : CPU ID.
    374          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    375          u32 NVIC_GetCPUID(void)
    376          {
    377            return (SCB->CPUID);
   \                     NVIC_GetCPUID:
   \   00000000   0x....             LDR.N    R0,??DataTable22_20  ;; 0xe000ed00
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    378          }
    379          
    380          /*******************************************************************************
    381          * Function Name  : NVIC_SetVectorTable
    382          * Description    : Sets the vector table location and Offset.
    383          * Input          : - NVIC_VectTab: specifies if the vector table is in RAM or
    384          *                    FLASH memory.
    385          *                    This parameter can be one of the following values:
    386          *                       - NVIC_VectTab_RAM
    387          *                       - NVIC_VectTab_FLASH
    388          *                  - Offset: Vector Table base offset field. 
    389          *                            This value must be a multiple of 0x100.
    390          * Output         : None
    391          * Return         : None
    392          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    393          void NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset)
    394          { 
    395            /* Check the parameters */
    396            assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
    397            assert_param(IS_NVIC_OFFSET(Offset));  
    398             
    399            SCB->VTOR = NVIC_VectTab | (Offset & (u32)0x1FFFFF80);
   \                     NVIC_SetVectorTable:
   \   00000000   0x....             LDR.N    R2,??DataTable22_21  ;; 0x1fffff80
   \   00000002   0x4011             ANDS     R1,R2,R1
   \   00000004   0x4308             ORRS     R0,R1,R0
   \   00000006   0x....             LDR.N    R1,??DataTable22_6  ;; 0xe000ed08
   \   00000008   0x6008             STR      R0,[R1, #+0]
    400          }
   \   0000000A   0x4770             BX       LR               ;; return
    401          
    402          /*******************************************************************************
    403          * Function Name  : NVIC_GenerateSystemReset
    404          * Description    : Generates a system reset.
    405          * Input          : None
    406          * Output         : None
    407          * Return         : None
    408          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    409          void NVIC_GenerateSystemReset(void)
    410          {
    411            SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x04;
   \                     NVIC_GenerateSystemReset:
   \   00000000   0x....             LDR.N    R0,??DataTable22_7  ;; 0xe000ed0c
   \   00000002   0x....             LDR.N    R1,??DataTable22_22  ;; 0x5fa0004
   \   00000004   0x6001             STR      R1,[R0, #+0]
    412          }
   \   00000006   0x4770             BX       LR               ;; return
    413          
    414          /*******************************************************************************
    415          * Function Name  : NVIC_GenerateCoreReset
    416          * Description    : Generates a Core (Core + NVIC) reset.
    417          * Input          : None
    418          * Output         : None
    419          * Return         : None
    420          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    421          void NVIC_GenerateCoreReset(void)
    422          {
    423            SCB->AIRCR = AIRCR_VECTKEY_MASK | (u32)0x01;
   \                     NVIC_GenerateCoreReset:
   \   00000000   0x....             LDR.N    R0,??DataTable22_7  ;; 0xe000ed0c
   \   00000002   0x....             LDR.N    R1,??DataTable22_23  ;; 0x5fa0001
   \   00000004   0x6001             STR      R1,[R0, #+0]
    424          }
   \   00000006   0x4770             BX       LR               ;; return
    425          
    426          /*******************************************************************************
    427          * Function Name  : NVIC_SystemLPConfig
    428          * Description    : Selects the condition for the system to enter low power mode.
    429          * Input          : - LowPowerMode: Specifies the new mode for the system to enter
    430          *                    low power mode.
    431          *                    This parameter can be one of the following values:
    432          *                       - NVIC_LP_SEVONPEND
    433          *                       - NVIC_LP_SLEEPDEEP
    434          *                       - NVIC_LP_SLEEPONEXIT
    435          *                  - NewState: new state of LP condition.
    436          *                    This parameter can be: ENABLE or DISABLE.
    437          * Output         : None
    438          * Return         : None
    439          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    440          void NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState)
    441          {
    442            /* Check the parameters */
    443            assert_param(IS_NVIC_LP(LowPowerMode));
    444            assert_param(IS_FUNCTIONAL_STATE(NewState));  
    445            
    446            if (NewState != DISABLE)
   \                     NVIC_SystemLPConfig:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD006             BEQ.N    ??NVIC_SystemLPConfig_0
    447            {
    448              SCB->SCR |= LowPowerMode;
   \   00000006   0x....             LDR.N    R1,??DataTable22_9  ;; 0xe000ed10
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x4308             ORRS     R0,R0,R1
   \   0000000E   0x....             LDR.N    R1,??DataTable22_9  ;; 0xe000ed10
   \   00000010   0x6008             STR      R0,[R1, #+0]
   \   00000012   0xE006             B.N      ??NVIC_SystemLPConfig_1
    449            }
    450            else
    451            {
    452              SCB->SCR &= (u32)(~(u32)LowPowerMode);
   \                     ??NVIC_SystemLPConfig_0:
   \   00000014   0x....             LDR.N    R1,??DataTable22_9  ;; 0xe000ed10
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xEA31 0x0000      BICS     R0,R1,R0
   \   0000001E   0x....             LDR.N    R1,??DataTable22_9  ;; 0xe000ed10
   \   00000020   0x6008             STR      R0,[R1, #+0]
    453            }
    454          }
   \                     ??NVIC_SystemLPConfig_1:
   \   00000022   0x4770             BX       LR               ;; return
    455          
    456          /*******************************************************************************
    457          * Function Name  : NVIC_SystemHandlerConfig
    458          * Description    : Enables or disables the specified System Handlers.
    459          * Input          : - SystemHandler: specifies the system handler to be enabled
    460          *                    or disabled.
    461          *                    This parameter can be one of the following values:
    462          *                       - SystemHandler_MemoryManage
    463          *                       - SystemHandler_BusFault
    464          *                       - SystemHandler_UsageFault
    465          *                  - NewState: new state of  specified System Handlers.
    466          *                    This parameter can be: ENABLE or DISABLE.
    467          * Output         : None
    468          * Return         : None
    469          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    470          void NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState)
    471          {
    472            u32 tmpreg = 0x00;
   \                     NVIC_SystemHandlerConfig:
   \   00000000   0x2200             MOVS     R2,#+0
    473          
    474            /* Check the parameters */
    475            assert_param(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
    476            assert_param(IS_FUNCTIONAL_STATE(NewState)); 
    477            
    478            tmpreg =  (u32)0x01 << (SystemHandler & (u32)0x1F);
   \   00000002   0x2301             MOVS     R3,#+1
   \   00000004   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000008   0xFA13 0xF000      LSLS     R0,R3,R0
   \   0000000C   0x0002             MOVS     R2,R0
    479          
    480            if (NewState != DISABLE)
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD005             BEQ.N    ??NVIC_SystemHandlerConfig_0
    481            {
    482              SCB->SHCSR |= tmpreg;
   \   00000014   0x....             LDR.N    R0,??DataTable22_12  ;; 0xe000ed24
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x4310             ORRS     R0,R2,R0
   \   0000001A   0x....             LDR.N    R1,??DataTable22_12  ;; 0xe000ed24
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0xE004             B.N      ??NVIC_SystemHandlerConfig_1
    483            }
    484            else
    485            {
    486              SCB->SHCSR &= ~tmpreg;
   \                     ??NVIC_SystemHandlerConfig_0:
   \   00000020   0x....             LDR.N    R0,??DataTable22_12  ;; 0xe000ed24
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x4390             BICS     R0,R0,R2
   \   00000026   0x....             LDR.N    R1,??DataTable22_12  ;; 0xe000ed24
   \   00000028   0x6008             STR      R0,[R1, #+0]
    487            }
    488          }
   \                     ??NVIC_SystemHandlerConfig_1:
   \   0000002A   0x4770             BX       LR               ;; return
    489          
    490          /*******************************************************************************
    491          * Function Name  : NVIC_SystemHandlerPriorityConfig
    492          * Description    : Configures the specified System Handlers priority.
    493          * Input          : - SystemHandler: specifies the system handler to be
    494          *                    enabled or disabled.
    495          *                    This parameter can be one of the following values:
    496          *                       - SystemHandler_MemoryManage
    497          *                       - SystemHandler_BusFault
    498          *                       - SystemHandler_UsageFault
    499          *                       - SystemHandler_SVCall
    500          *                       - SystemHandler_DebugMonitor
    501          *                       - SystemHandler_PSV
    502          *                       - SystemHandler_SysTick
    503          *                  - SystemHandlerPreemptionPriority: new priority group of the
    504          *                    specified system handlers.
    505          *                  - SystemHandlerSubPriority: new sub priority of the specified
    506          *                    system handlers.
    507          * Output         : None
    508          * Return         : None
    509          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    510          void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
    511                                                u8 SystemHandlerSubPriority)
    512          {
   \                     NVIC_SystemHandlerPriorityConfig:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    513            u32 tmp1 = 0x00, tmp2 = 0xFF, handlermask = 0x00;
   \   00000002   0x2500             MOVS     R5,#+0
   \   00000004   0x26FF             MOVS     R6,#+255
   \   00000006   0x2300             MOVS     R3,#+0
    514            u32 tmppriority = 0x00;
   \   00000008   0x2400             MOVS     R4,#+0
    515          
    516            /* Check the parameters */
    517            assert_param(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
    518            assert_param(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
    519            assert_param(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
    520              
    521            tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
   \   0000000A   0x....             LDR.N    R7,??DataTable22_7  ;; 0xe000ed0c
   \   0000000C   0x683F             LDR      R7,[R7, #+0]
   \   0000000E   0xF417 0x67E0      ANDS     R7,R7,#0x700
   \   00000012   0xF5D7 0x67E0      RSBS     R7,R7,#+1792
   \   00000016   0x0A3F             LSRS     R7,R7,#+8
   \   00000018   0x003C             MOVS     R4,R7
    522            tmp1 = (0x4 - tmppriority);
   \   0000001A   0xF1D4 0x0704      RSBS     R7,R4,#+4
   \   0000001E   0x003D             MOVS     R5,R7
    523            tmp2 = tmp2 >> tmppriority;
   \   00000020   0x40E6             LSRS     R6,R6,R4
    524              
    525            tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0xFA11 0xF405      LSLS     R4,R1,R5
    526            tmppriority |=  SystemHandlerSubPriority & tmp2;
   \   00000028   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002A   0xEA16 0x0102      ANDS     R1,R6,R2
   \   0000002E   0x430C             ORRS     R4,R1,R4
    527          
    528            tmppriority = tmppriority << 0x04;
   \   00000030   0x0124             LSLS     R4,R4,#+4
    529            tmp1 = SystemHandler & (u32)0xC0;
   \   00000032   0xF010 0x05C0      ANDS     R5,R0,#0xC0
    530            tmp1 = tmp1 >> 0x06; 
   \   00000036   0x09AD             LSRS     R5,R5,#+6
    531            tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
   \   00000038   0xF3C0 0x2601      UBFX     R6,R0,#+8,#+2
    532            tmppriority = tmppriority << (tmp2 * 0x08);
   \   0000003C   0x0030             MOVS     R0,R6
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x00C0             LSLS     R0,R0,#+3
   \   00000042   0x4084             LSLS     R4,R4,R0
    533            handlermask = (u32)0xFF << (tmp2 * 0x08);
   \   00000044   0x20FF             MOVS     R0,#+255
   \   00000046   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000048   0x00F1             LSLS     R1,R6,#+3
   \   0000004A   0x4088             LSLS     R0,R0,R1
   \   0000004C   0x0003             MOVS     R3,R0
    534            
    535            SCB->SHPR[tmp1] &= ~handlermask;
   \   0000004E   0x....             LDR.N    R0,??DataTable22_11  ;; 0xe000ed18
   \   00000050   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000054   0x4398             BICS     R0,R0,R3
   \   00000056   0x....             LDR.N    R1,??DataTable22_11  ;; 0xe000ed18
   \   00000058   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
    536            SCB->SHPR[tmp1] |= tmppriority;
   \   0000005C   0x....             LDR.N    R0,??DataTable22_11  ;; 0xe000ed18
   \   0000005E   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000062   0x4320             ORRS     R0,R4,R0
   \   00000064   0x....             LDR.N    R1,??DataTable22_11  ;; 0xe000ed18
   \   00000066   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
    537          }
   \   0000006A   0xBCF0             POP      {R4-R7}
   \   0000006C   0x4770             BX       LR               ;; return
    538          
    539          /*******************************************************************************
    540          * Function Name  : NVIC_GetSystemHandlerPendingBitStatus
    541          * Description    : Checks whether the specified System handlers pending bit is
    542          *                  set or not.
    543          * Input          : - SystemHandler: specifies the system handler pending bit to
    544          *                    check.
    545          *                    This parameter can be one of the following values:
    546          *                       - SystemHandler_MemoryManage
    547          *                       - SystemHandler_BusFault
    548          *                       - SystemHandler_SVCall
    549          * Output         : None
    550          * Return         : The new state of System Handler pending bit(SET or RESET).
    551          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    552          ITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler)
    553          {
    554            ITStatus bitstatus  = RESET;
   \                     NVIC_GetSystemHandlerPendingBitStatus:
   \   00000000   0x2100             MOVS     R1,#+0
    555            u32 tmp = 0x00, tmppos = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2300             MOVS     R3,#+0
    556          
    557            /* Check the parameters */
    558            assert_param(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
    559            
    560            tmppos = (SystemHandler >> 0x0A);
   \   00000006   0x0A80             LSRS     R0,R0,#+10
   \   00000008   0x0003             MOVS     R3,R0
    561            tmppos &= (u32)0x0F;
   \   0000000A   0xF013 0x030F      ANDS     R3,R3,#0xF
    562          
    563            tmppos = (u32)0x01 << tmppos;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xFA10 0xF303      LSLS     R3,R0,R3
    564          
    565            tmp = SCB->SHCSR & tmppos;
   \   00000014   0x....             LDR.N    R0,??DataTable22_12  ;; 0xe000ed24
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x4018             ANDS     R0,R3,R0
   \   0000001A   0x0002             MOVS     R2,R0
    566          
    567            if (tmp == tmppos)
   \   0000001C   0x429A             CMP      R2,R3
   \   0000001E   0xD101             BNE.N    ??NVIC_GetSystemHandlerPendingBitStatus_0
    568            {
    569              bitstatus = SET;
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0xE000             B.N      ??NVIC_GetSystemHandlerPendingBitStatus_1
    570            }
    571            else
    572            {
    573              bitstatus = RESET;
   \                     ??NVIC_GetSystemHandlerPendingBitStatus_0:
   \   00000024   0x2100             MOVS     R1,#+0
    574            }
    575            return bitstatus;
   \                     ??NVIC_GetSystemHandlerPendingBitStatus_1:
   \   00000026   0x0008             MOVS     R0,R1
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x4770             BX       LR               ;; return
    576          }
    577          
    578          /*******************************************************************************
    579          * Function Name  : NVIC_SetSystemHandlerPendingBit
    580          * Description    : Sets System Handler pending bit.
    581          * Input          : - SystemHandler: specifies the system handler pending bit
    582          *                    to be set.
    583          *                    This parameter can be one of the following values:
    584          *                       - SystemHandler_NMI
    585          *                       - SystemHandler_PSV
    586          *                       - SystemHandler_SysTick
    587          * Output         : None
    588          * Return         : None
    589          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    590          void NVIC_SetSystemHandlerPendingBit(u32 SystemHandler)
    591          {
    592            u32 tmp = 0x00;
   \                     NVIC_SetSystemHandlerPendingBit:
   \   00000000   0x2100             MOVS     R1,#+0
    593          
    594            /* Check the parameters */
    595            assert_param(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
    596            
    597            /* Get the System Handler pending bit position */
    598            tmp = SystemHandler & (u32)0x1F;
   \   00000002   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000006   0x0001             MOVS     R1,R0
    599            /* Set the corresponding System Handler pending bit */
    600            SCB->ICSR |= ((u32)0x01 << tmp);
   \   00000008   0x....             LDR.N    R0,??DataTable22_5  ;; 0xe000ed04
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000012   0x4308             ORRS     R0,R1,R0
   \   00000014   0x....             LDR.N    R1,??DataTable22_5  ;; 0xe000ed04
   \   00000016   0x6008             STR      R0,[R1, #+0]
    601          }
   \   00000018   0x4770             BX       LR               ;; return
    602          
    603          /*******************************************************************************
    604          * Function Name  : NVIC_ClearSystemHandlerPendingBit
    605          * Description    : Clears System Handler pending bit.
    606          * Input          : - SystemHandler: specifies the system handler pending bit to
    607          *                    be clear.
    608          *                    This parameter can be one of the following values:
    609          *                       - SystemHandler_PSV
    610          *                       - SystemHandler_SysTick
    611          * Output         : None
    612          * Return         : None
    613          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    614          void NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler)
    615          {
    616            u32 tmp = 0x00;
   \                     NVIC_ClearSystemHandlerPendingBit:
   \   00000000   0x2100             MOVS     R1,#+0
    617          
    618            /* Check the parameters */
    619            assert_param(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
    620            
    621            /* Get the System Handler pending bit position */
    622            tmp = SystemHandler & (u32)0x1F;
   \   00000002   0xF010 0x001F      ANDS     R0,R0,#0x1F
   \   00000006   0x0001             MOVS     R1,R0
    623            /* Clear the corresponding System Handler pending bit */
    624            SCB->ICSR |= ((u32)0x01 << (tmp - 0x01));
   \   00000008   0x....             LDR.N    R0,??DataTable22_5  ;; 0xe000ed04
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2201             MOVS     R2,#+1
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000014   0x4308             ORRS     R0,R1,R0
   \   00000016   0x....             LDR.N    R1,??DataTable22_5  ;; 0xe000ed04
   \   00000018   0x6008             STR      R0,[R1, #+0]
    625          }
   \   0000001A   0x4770             BX       LR               ;; return
    626          
    627          /*******************************************************************************
    628          * Function Name  : NVIC_GetSystemHandlerActiveBitStatus
    629          * Description    : Checks whether the specified System handlers active bit is
    630          *                  set or not.
    631          * Input          : - SystemHandler: specifies the system handler active bit to
    632          *                    check.
    633          *                    This parameter can be one of the following values:
    634          *                       - SystemHandler_MemoryManage
    635          *                       - SystemHandler_BusFault
    636          *                       - SystemHandler_UsageFault
    637          *                       - SystemHandler_SVCall
    638          *                       - SystemHandler_DebugMonitor
    639          *                       - SystemHandler_PSV
    640          *                       - SystemHandler_SysTick
    641          * Output         : None
    642          * Return         : The new state of System Handler active bit(SET or RESET).
    643          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    644          ITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler)
    645          {
    646            ITStatus bitstatus  = RESET;
   \                     NVIC_GetSystemHandlerActiveBitStatus:
   \   00000000   0x2100             MOVS     R1,#+0
    647          
    648            u32 tmp = 0x00, tmppos = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x2300             MOVS     R3,#+0
    649          
    650            /* Check the parameters */
    651            assert_param(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
    652            
    653            tmppos = (SystemHandler >> 0x0E) & (u32)0x0F;
   \   00000006   0xF3C0 0x3083      UBFX     R0,R0,#+14,#+4
   \   0000000A   0x0003             MOVS     R3,R0
    654          
    655            tmppos = (u32)0x01 << tmppos;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xFA10 0xF303      LSLS     R3,R0,R3
    656          
    657            tmp = SCB->SHCSR & tmppos;
   \   00000012   0x....             LDR.N    R0,??DataTable22_12  ;; 0xe000ed24
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x4018             ANDS     R0,R3,R0
   \   00000018   0x0002             MOVS     R2,R0
    658          
    659            if (tmp == tmppos)
   \   0000001A   0x429A             CMP      R2,R3
   \   0000001C   0xD101             BNE.N    ??NVIC_GetSystemHandlerActiveBitStatus_0
    660            {
    661              bitstatus = SET;
   \   0000001E   0x2101             MOVS     R1,#+1
   \   00000020   0xE000             B.N      ??NVIC_GetSystemHandlerActiveBitStatus_1
    662            }
    663            else
    664            {
    665              bitstatus = RESET;
   \                     ??NVIC_GetSystemHandlerActiveBitStatus_0:
   \   00000022   0x2100             MOVS     R1,#+0
    666            }
    667            return bitstatus;
   \                     ??NVIC_GetSystemHandlerActiveBitStatus_1:
   \   00000024   0x0008             MOVS     R0,R1
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x4770             BX       LR               ;; return
    668          }
    669          
    670          /*******************************************************************************
    671          * Function Name  : NVIC_GetFaultHandlerSources
    672          * Description    : Returns the system fault handlers sources.
    673          * Input          : - SystemHandler: specifies the system handler to get its fault
    674          *                    sources.
    675          *                    This parameter can be one of the following values:
    676          *                       - SystemHandler_HardFault
    677          *                       - SystemHandler_MemoryManage
    678          *                       - SystemHandler_BusFault
    679          *                       - SystemHandler_UsageFault
    680          *                       - SystemHandler_DebugMonitor
    681          * Output         : None
    682          * Return         : Source of the fault handler.
    683          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    684          u32 NVIC_GetFaultHandlerSources(u32 SystemHandler)
    685          {
   \                     NVIC_GetFaultHandlerSources:
   \   00000000   0xB410             PUSH     {R4}
    686            u32 faultsources = 0x00;
   \   00000002   0x2100             MOVS     R1,#+0
    687            u32 tmpreg = 0x00, tmppos = 0x00;
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x2300             MOVS     R3,#+0
    688          
    689            /* Check the parameters */
    690            assert_param(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
    691            
    692            tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
   \   00000008   0xF3C0 0x4481      UBFX     R4,R0,#+18,#+2
   \   0000000C   0x0022             MOVS     R2,R4
    693            tmppos = (SystemHandler >> 0x14) & (u32)0x03;
   \   0000000E   0xF3C0 0x5001      UBFX     R0,R0,#+20,#+2
   \   00000012   0x0003             MOVS     R3,R0
    694          
    695            if (tmpreg == 0x00)
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD102             BNE.N    ??NVIC_GetFaultHandlerSources_0
    696            {
    697              faultsources = SCB->HFSR;
   \   00000018   0x....             LDR.N    R0,??DataTable22_14  ;; 0xe000ed2c
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xE011             B.N      ??NVIC_GetFaultHandlerSources_1
    698            }
    699            else if (tmpreg == 0x01)
   \                     ??NVIC_GetFaultHandlerSources_0:
   \   0000001E   0x2A01             CMP      R2,#+1
   \   00000020   0xD10D             BNE.N    ??NVIC_GetFaultHandlerSources_2
    700            {
    701              faultsources = SCB->CFSR >> (tmppos * 0x08);
   \   00000022   0x....             LDR.N    R0,??DataTable22_13  ;; 0xe000ed28
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x0019             MOVS     R1,R3
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x00C9             LSLS     R1,R1,#+3
   \   0000002C   0xFA30 0xF101      LSRS     R1,R0,R1
    702              if (tmppos != 0x02)
   \   00000030   0x2B02             CMP      R3,#+2
   \   00000032   0xD002             BEQ.N    ??NVIC_GetFaultHandlerSources_3
    703              {
    704                faultsources &= (u32)0x0F;
   \   00000034   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   00000038   0xE003             B.N      ??NVIC_GetFaultHandlerSources_1
    705              }
    706              else
    707              {
    708                faultsources &= (u32)0xFF;
   \                     ??NVIC_GetFaultHandlerSources_3:
   \   0000003A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003C   0xE001             B.N      ??NVIC_GetFaultHandlerSources_1
    709              }
    710            }
    711            else
    712            {
    713              faultsources = SCB->DFSR;
   \                     ??NVIC_GetFaultHandlerSources_2:
   \   0000003E   0x....             LDR.N    R0,??DataTable22_15  ;; 0xe000ed30
   \   00000040   0x6801             LDR      R1,[R0, #+0]
    714            }
    715            return faultsources;
   \                     ??NVIC_GetFaultHandlerSources_1:
   \   00000042   0x0008             MOVS     R0,R1
   \   00000044   0xBC10             POP      {R4}
   \   00000046   0x4770             BX       LR               ;; return
    716          }
    717          
    718          /*******************************************************************************
    719          * Function Name  : NVIC_GetFaultAddress
    720          * Description    : Returns the address of the location that generated a fault
    721          *                  handler.
    722          * Input          : - SystemHandler: specifies the system handler to get its
    723          *                    fault address.
    724          *                    This parameter can be one of the following values:
    725          *                       - SystemHandler_MemoryManage
    726          *                       - SystemHandler_BusFault
    727          * Output         : None
    728          * Return         : Fault address.
    729          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    730          u32 NVIC_GetFaultAddress(u32 SystemHandler)
    731          {
    732            u32 faultaddress = 0x00;
   \                     NVIC_GetFaultAddress:
   \   00000000   0x2100             MOVS     R1,#+0
    733            u32 tmp = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
    734          
    735            /* Check the parameters */
    736            assert_param(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
    737            
    738            tmp = (SystemHandler >> 0x16) & (u32)0x01;
   \   00000004   0xF3C0 0x5080      UBFX     R0,R0,#+22,#+1
   \   00000008   0x0002             MOVS     R2,R0
    739          
    740            if (tmp == 0x00)
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD102             BNE.N    ??NVIC_GetFaultAddress_0
    741            {
    742              faultaddress = SCB->MMFAR;
   \   0000000E   0x....             LDR.N    R0,??DataTable22_24  ;; 0xe000ed34
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xE001             B.N      ??NVIC_GetFaultAddress_1
    743            }
    744            else
    745            {
    746              faultaddress = SCB->BFAR;
   \                     ??NVIC_GetFaultAddress_0:
   \   00000014   0x....             LDR.N    R0,??DataTable22_25  ;; 0xe000ed38
   \   00000016   0x6801             LDR      R1,[R0, #+0]
    747            }
    748            return faultaddress;
   \                     ??NVIC_GetFaultAddress_1:
   \   00000018   0x0008             MOVS     R0,R1
   \   0000001A   0x4770             BX       LR               ;; return
    749          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \   00000000   0xE000E184         DC32     0xe000e184

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \   00000000   0xE000E284         DC32     0xe000e284

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \   00000000   0x05FA0000         DC32     0x5fa0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_10:
   \   00000000   0xE000ED14         DC32     0xe000ed14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_11:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_12:
   \   00000000   0xE000ED24         DC32     0xe000ed24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_13:
   \   00000000   0xE000ED28         DC32     0xe000ed28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_14:
   \   00000000   0xE000ED2C         DC32     0xe000ed2c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_15:
   \   00000000   0xE000ED30         DC32     0xe000ed30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_16:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_17:
   \   00000000   0xE000E200         DC32     0xe000e200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_18:
   \   00000000   0xE000EF00         DC32     0xe000ef00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_19:
   \   00000000   0xE000E300         DC32     0xe000e300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_20:
   \   00000000   0xE000ED00         DC32     0xe000ed00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_21:
   \   00000000   0x1FFFFF80         DC32     0x1fffff80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_22:
   \   00000000   0x05FA0004         DC32     0x5fa0004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_23:
   \   00000000   0x05FA0001         DC32     0x5fa0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_24:
   \   00000000   0xE000ED34         DC32     0xe000ed34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_25:
   \   00000000   0xE000ED38         DC32     0xe000ed38
    750          
    751          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   NVIC_BASEPRICONFIG
         8   -> __BASEPRICONFIG
       0   NVIC_ClearIRQChannelPendingBit
       0   NVIC_ClearSystemHandlerPendingBit
       0   NVIC_DeInit
       0   NVIC_GenerateCoreReset
       0   NVIC_GenerateSystemReset
       8   NVIC_GetBASEPRI
         8   -> __GetBASEPRI
       0   NVIC_GetCPUID
       0   NVIC_GetCurrentActiveHandler
       0   NVIC_GetCurrentPendingIRQChannel
       0   NVIC_GetFaultAddress
       4   NVIC_GetFaultHandlerSources
       4   NVIC_GetIRQChannelActiveBitStatus
       4   NVIC_GetIRQChannelPendingBitStatus
       0   NVIC_GetSystemHandlerActiveBitStatus
       0   NVIC_GetSystemHandlerPendingBitStatus
      12   NVIC_Init
       0   NVIC_PriorityGroupConfig
       8   NVIC_RESETFAULTMASK
         8   -> __RESETFAULTMASK
       8   NVIC_RESETPRIMASK
         8   -> __RESETPRIMASK
       0   NVIC_SCBDeInit
       8   NVIC_SETFAULTMASK
         8   -> __SETFAULTMASK
       8   NVIC_SETPRIMASK
         8   -> __SETPRIMASK
       0   NVIC_SetIRQChannelPendingBit
       0   NVIC_SetSystemHandlerPendingBit
       0   NVIC_SetVectorTable
       0   NVIC_StructInit
       0   NVIC_SystemHandlerConfig
      16   NVIC_SystemHandlerPriorityConfig
       0   NVIC_SystemLPConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_13
       4  ??DataTable22_14
       4  ??DataTable22_15
       4  ??DataTable22_16
       4  ??DataTable22_17
       4  ??DataTable22_18
       4  ??DataTable22_19
       4  ??DataTable22_2
       4  ??DataTable22_20
       4  ??DataTable22_21
       4  ??DataTable22_22
       4  ??DataTable22_23
       4  ??DataTable22_24
       4  ??DataTable22_25
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
      10  NVIC_BASEPRICONFIG
      22  NVIC_ClearIRQChannelPendingBit
      28  NVIC_ClearSystemHandlerPendingBit
      66  NVIC_DeInit
       8  NVIC_GenerateCoreReset
       8  NVIC_GenerateSystemReset
       8  NVIC_GetBASEPRI
       6  NVIC_GetCPUID
      10  NVIC_GetCurrentActiveHandler
      12  NVIC_GetCurrentPendingIRQChannel
      28  NVIC_GetFaultAddress
      72  NVIC_GetFaultHandlerSources
      46  NVIC_GetIRQChannelActiveBitStatus
      46  NVIC_GetIRQChannelPendingBitStatus
      42  NVIC_GetSystemHandlerActiveBitStatus
      44  NVIC_GetSystemHandlerPendingBitStatus
     152  NVIC_Init
      14  NVIC_PriorityGroupConfig
       8  NVIC_RESETFAULTMASK
       8  NVIC_RESETPRIMASK
     108  NVIC_SCBDeInit
       8  NVIC_SETFAULTMASK
       8  NVIC_SETPRIMASK
       8  NVIC_SetIRQChannelPendingBit
      26  NVIC_SetSystemHandlerPendingBit
      12  NVIC_SetVectorTable
      18  NVIC_StructInit
      44  NVIC_SystemHandlerConfig
     110  NVIC_SystemHandlerPriorityConfig
      36  NVIC_SystemLPConfig

 
 1 120 bytes in section .text
 
 1 120 bytes of CODE memory

Errors: none
Warnings: none
