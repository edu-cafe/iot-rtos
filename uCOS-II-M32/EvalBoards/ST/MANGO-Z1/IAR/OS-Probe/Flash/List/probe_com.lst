###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      11/Mar/2013  20:18:51 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\BookSrc_CM3_IAR\Software\uC-Probe\Target\Communicatio #
#                    n\Generic\Source\probe_com.c                             #
#    Command line =  C:\BookSrc_CM3_IAR\Software\uC-Probe\Target\Communicatio #
#                    n\Generic\Source\probe_com.c -lCN                        #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\List\ -o C:\BookSrc_CM3_IAR\Software\EvalB #
#                    oards\ST\MANGO-Z1\IAR\OS-Probe\Flash\Obj\ --no_cse       #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    6.5\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\ -I C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MA #
#                    NGO-Z1\IAR\OS-Probe\..\BSP\ -I                           #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\CPU\ST\STM32\inc\ -I              #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-CPU\ -I                        #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\ -I      #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-LCD\Source\ -I                 #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-LIB\ -I                        #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex-M3\Gener #
#                    ic\IAR\ -I C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MAN #
#                    GO-Z1\IAR\OS-Probe\..\..\..\..\..\uCOS-II\Source\ -I     #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Gen #
#                    eric\RS-232\Source\ -I C:\BookSrc_CM3_IAR\Software\EvalB #
#                    oards\ST\MANGO-Z1\IAR\OS-Probe\..\..\..\..\..\uC-Probe\T #
#                    arget\Communication\Generic\RS-232\Ports\ST\STM32\ -I    #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Gen #
#                    eric\Source\ -I C:\BookSrc_CM3_IAR\Software\EvalBoards\S #
#                    T\MANGO-Z1\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\P #
#                    lugins\uCOS-II\ -Ol --use_c++_inline                     #
#    List file    =  C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\List\probe_com.lst                         #
#    Object file  =  C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\Obj\probe_com.o                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\BookSrc_CM3_IAR\Software\uC-Probe\Target\Communication\Generic\Source\probe_com.c
      1          /*
      2          *********************************************************************************************************
      3          *                                       uC/Probe Communication
      4          *
      5          *                         (c) Copyright 2007-2008; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                       COMMUNICATION: GENERIC
     18          *
     19          * Filename      : probe_com.c
     20          * Version       : V2.20
     21          * Programmer(s) : BAN
     22          *********************************************************************************************************
     23          * Note(s)       : (1) This file contains code to respond to generic (non protocol-dependent) commands
     24          *                     received by the target.
     25          *********************************************************************************************************
     26          */
     27          
     28          
     29          /*
     30          *********************************************************************************************************
     31          *                                            INCLUDE FILES
     32          *********************************************************************************************************
     33          */
     34          
     35          #define   PROBE_COM_MODULE
     36          #include  <probe_com.h>

   \                                 In section .bss, align 4
   \   __absolute CPU_INT32U ProbeCom_RxPktCtr
   \                     ProbeCom_RxPktCtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute CPU_INT32U ProbeCom_TxPktCtr
   \                     ProbeCom_TxPktCtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute CPU_INT32U ProbeCom_TxSymCtr
   \                     ProbeCom_TxSymCtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute CPU_INT32U ProbeCom_TxSymByteCtr
   \                     ProbeCom_TxSymByteCtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute CPU_INT32U ProbeCom_ErrPktCtr
   \                     ProbeCom_ErrPktCtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute CPU_INT32U ProbeCom_RxSymCtr
   \                     ProbeCom_RxSymCtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute CPU_INT32U ProbeCom_RxSymByteCtr
   \                     ProbeCom_RxSymByteCtr:
   \   00000000                      DS8 4
     37          
     38          
     39          /*
     40          *********************************************************************************************************
     41          *                                            LOCAL DEFINES
     42          *********************************************************************************************************
     43          */
     44          
     45          /*
     46          *********************************************************************************************************
     47          *                                        DATA FORMATS DEFINES
     48          *********************************************************************************************************
     49          */
     50          
     51          #define  PROBE_COM_FMT_TX_ERR                         0x8000
     52          
     53          #define  PROBE_COM_FMT_RX_QUERY                       0x0001    /* Query setup parameter or capability.                 */
     54          #define  PROBE_COM_FMT_TX_QUERY                       0x8001
     55          
     56          #define  PROBE_COM_FMT_RX_RD                          0x0002    /* Read data at memory address.                         */
     57          #define  PROBE_COM_FMT_TX_RD                          0x8002
     58          
     59          #define  PROBE_COM_FMT_RX_WR                          0x0003    /* Write data at memory address.                        */
     60          #define  PROBE_COM_FMT_TX_WR                          0x8003
     61          
     62          #define  PROBE_COM_FMT_RX_RD_MULTI                    0x0007    /* Read data at multiple memory addresses.              */
     63          #define  PROBE_COM_FMT_TX_RD_MULTI                    0x8007
     64          #define  PROBE_COM_FMT_TX_RD_MULTI_LO                   0x07
     65          #define  PROBE_COM_FMT_TX_RD_MULTI_HI                   0x80
     66          
     67          #define  PROBE_COM_FMT_RX_WR_MULTI                    0x0008    /* Write data at multiple memory addresses.             */
     68          #define  PROBE_COM_FMT_TX_WR_MULTI                    0x8008
     69          
     70          #define  PROBE_COM_FMT_RX_STR_OUT                     0x0009    /* Transmit output string to Probe.                     */
     71          #define  PROBE_COM_FMT_TX_STR_OUT                     0x8009
     72          
     73          #define  PROBE_COM_FMT_RX_STR_IN                      0x000A    /* Receive input string from Probe.                     */
     74          #define  PROBE_COM_FMT_TX_STR_IN                      0x800A
     75          
     76          #define  PROBE_COM_FMT_RX_TERMINAL_EXEC               0x000B    /* Execute terminal command.                            */
     77          #define  PROBE_COM_FMT_TX_TERMINAL_EXEC               0x800B
     78          
     79          #define  PROBE_COM_FMT_RX_TERMINAL_OUT                0x000C    /* Transmit output data to Probe.                       */
     80          #define  PROBE_COM_FMT_TX_TERMINAL_OUT                0x800C
     81          
     82          #define  PROBE_COM_FMT_RX_TERMINAL_IN                 0x000D    /* Receive input data from Probe.                       */
     83          #define  PROBE_COM_FMT_TX_TERMINAL_IN                 0x800D
     84          
     85          /*
     86          *********************************************************************************************************
     87          *                                      STATUS CONSTANTS DEFINES
     88          *********************************************************************************************************
     89          */
     90          
     91          #define  PROBE_COM_STATUS_OK                            0x01
     92          #define  PROBE_COM_STATUS_TERMINAL_EXEC_NOT_RDY         0xF4    /* Terminal not rdy to exec new cmd.                    */
     93          #define  PROBE_COM_STATUS_TERMINAL_IN_OVF               0xF5    /* Terminal in buf ovf'd.                               */
     94          #define  PROBE_COM_STATUS_TERMINAL_OUT_NONE             0xF6    /* Terminal out buf empty.                              */
     95          #define  PROBE_COM_STATUS_STR_IN_OVF                    0xF7    /* String in buf ovf'd.                                 */
     96          #define  PROBE_COM_STATUS_STR_OUT_NONE                  0xF8    /* String out buf empty.                                */
     97          #define  PROBE_COM_STATUS_UNKNOWN_REQUEST               0xF9    /* Unknown req.                                         */
     98          #define  PROBE_COM_STATUS_QUERY_NOT_SUPPORTED           0xFC    /* Query not supported.                                 */
     99          #define  PROBE_COM_STATUS_TX_PKT_TOO_LARGE              0xFD    /* Reply pkt too large for buf.                         */
    100          #define  PROBE_COM_STATUS_RX_PKT_WRONG_SIZE             0xFE    /* Req pkt not correct size.                            */
    101          #define  PROBE_COM_STATUS_FAIL                          0xFF    /* Req exec failed (or unknown err).                    */
    102          
    103          /*
    104          *********************************************************************************************************
    105          *                                           QUERIES DEFINES
    106          *********************************************************************************************************
    107          */
    108          
    109                                                                          /* ------------------- CONFIGURATION ------------------ */
    110          #define  PROBE_COM_QUERY_MAX_RX_SIZE                  0x0101    /* Get data size of largest pkt target can rx.          */
    111          #define  PROBE_COM_QUERY_MAX_TX_SIZE                  0x0102    /* Get data size of largest pkt target can tx.          */
    112          
    113                                                                          /* ----------------- TARGET PROPERTIES ---------------- */
    114          #define  PROBE_COM_QUERY_ENDIANNESS_TEST              0x0201    /* Test endianness of target.                           */
    115          #define  PROBE_COM_QUERY_STATUS                       0x0202    /* Target status.                                       */
    116          
    117                                                                          /* ------------- COMMUNICATION CAPABILITIES ----------- */
    118          #define  PROBE_COM_QUERY_FMT_SUPPORT                  0x1001    /* Get list of supported req's.                         */
    119          #define  PROBE_COM_QUERY_VERSION                      0x1002    /* Get target code ver.                                 */
    120          
    121          /*
    122          *********************************************************************************************************
    123          *                                          MODIFIERS DEFINES
    124          *********************************************************************************************************
    125          */
    126          
    127          #define  PROBE_COM_MODIFIER_NONE                  DEF_BIT_NONE
    128          #define  PROBE_COM_MODIFIER_STR_OUT_AVAIL         DEF_BIT_00    /* Str out is avail.                                    */
    129          #define  PROBE_COM_MODIFIER_TERMINAL_EXEC_DONE    DEF_BIT_01    /* Terminal cmd exec done.                              */
    130          #define  PROBE_COM_MODIFIER_TERMINAL_OUT_AVAIL    DEF_BIT_02    /* Terminal out is avail.                               */
    131          
    132          /*
    133          *********************************************************************************************************
    134          *                                        HEADER SIZES DEFINES
    135          *
    136          * Note(s):  (1) The first four bytes in all tx data segments is identical:
    137          *
    138          *               (a) A 2-byte format;
    139          *               (b) A 1-byte status;
    140          *               (c) A 1-byte modifier, currently unused.
    141          *
    142          *           (2) The first two bytes in all rx data segments is identical:
    143          *
    144          *               (a) A 2-byte format.
    145          *********************************************************************************************************
    146          */
    147          
    148          #define  PROBE_COM_SIZE_RX_HDR                             2
    149          #define  PROBE_COM_SIZE_TX_HDR                             4
    150          
    151          /*
    152          *********************************************************************************************************
    153          *                                           LOCAL CONSTANTS
    154          *********************************************************************************************************
    155          */
    156          
    157          
    158          /*
    159          *********************************************************************************************************
    160          *                                          LOCAL DATA TYPES
    161          *********************************************************************************************************
    162          */
    163          
    164          typedef  struct  probe_com_buf {
    165              CPU_SIZE_T   Len;
    166              CPU_SIZE_T   IxRd;
    167              CPU_SIZE_T   IxWr;
    168              CPU_INT08U  *DataPtr;
    169          } PROBE_COM_BUF;
    170          
    171          
    172          /*
    173          *********************************************************************************************************
    174          *                                            LOCAL TABLES
    175          *********************************************************************************************************
    176          */
    177          
    178          
    179          /*
    180          *********************************************************************************************************
    181          *                                       LOCAL GLOBAL VARIABLES
    182          *********************************************************************************************************
    183          */
    184          
    185          #if (PROBE_COM_CFG_STR_REQ_EN       == DEF_ENABLED)
    186          static  CPU_CHAR                       ProbeCom_StrInBufData[PROBE_COM_CFG_STR_IN_BUF_SIZE];
    187          static  PROBE_COM_BUF                  ProbeCom_StrInBuf;
    188          
    189          static  CPU_CHAR                       ProbeCom_StrOutBufData[PROBE_COM_CFG_STR_OUT_BUF_SIZE];
    190          static  PROBE_COM_BUF                  ProbeCom_StrOutBuf;
    191          #endif
    192          
    193          #if (PROBE_COM_CFG_TERMINAL_REQ_EN  == DEF_ENABLED)

   \                                 In section .bss, align 4
    194          static  PROBE_COM_TERMINAL_EXEC_FNCT   ProbeCom_TerminalExecHandler;
   \                     ProbeCom_TerminalExecHandler:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    195          static  CPU_BOOLEAN                    ProbeCom_TerminalExecuting;
   \                     ProbeCom_TerminalExecuting:
   \   00000000                      DS8 1
    196          

   \                                 In section .bss, align 4
    197          static  PROBE_COM_TERMINAL_IN_FNCT     ProbeCom_TerminalInHandler;
   \                     ProbeCom_TerminalInHandler:
   \   00000000                      DS8 4
    198          

   \                                 In section .bss, align 4
    199          static  CPU_INT08U                    *ProbeCom_TerminalOutBufPtr;
   \                     ProbeCom_TerminalOutBufPtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    200          static  CPU_SIZE_T                     ProbeCom_TerminalOutBufIx;
   \                     ProbeCom_TerminalOutBufIx:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    201          static  CPU_SIZE_T                     ProbeCom_TerminalOutBufLen;
   \                     ProbeCom_TerminalOutBufLen:
   \   00000000                      DS8 4
    202          #endif
    203          

   \                                 In section .bss, align 4
    204          static  CPU_INT32U                     ProbeCom_EndiannessTest;
   \                     ProbeCom_EndiannessTest:
   \   00000000                      DS8 4
    205          
    206          
    207          /*
    208          *********************************************************************************************************
    209          *                                      LOCAL FUNCTION PROTOTYPES
    210          *********************************************************************************************************
    211          */
    212          
    213          static  CPU_INT08U   ProbeCom_PktModifier     (void);
    214          
    215          static  CPU_SIZE_T   ProbeCom_ReqErr          (CPU_INT08U      *ptx_buf,
    216                                                         CPU_INT08U       pcomm_err);
    217          
    218          
    219                                                                          /* ------------------- HANDLE REQ'S ------------------- */
    220          static  CPU_SIZE_T   ProbeCom_ReqQuery        (CPU_INT08U      *prx_buf,
    221                                                         CPU_INT08U      *ptx_buf,
    222                                                         CPU_SIZE_T       rx_pkt_size,
    223                                                         CPU_SIZE_T       tx_buf_size);
    224          
    225          static  CPU_SIZE_T   ProbeCom_ReqRd           (CPU_INT08U      *prx_buf,
    226                                                         CPU_INT08U      *ptx_buf,
    227                                                         CPU_SIZE_T       rx_pkt_size,
    228                                                         CPU_SIZE_T       tx_buf_size);
    229          
    230          static  CPU_SIZE_T   ProbeCom_ReqRdMulti      (CPU_INT08U      *prx_buf,
    231                                                         CPU_INT08U      *ptx_buf,
    232                                                         CPU_SIZE_T       rx_pkt_size,
    233                                                         CPU_SIZE_T       tx_buf_size);
    234          
    235          #if (PROBE_COM_CFG_WR_REQ_EN == DEF_ENABLED)
    236          static  CPU_SIZE_T   ProbeCom_ReqWr           (CPU_INT08U      *prx_buf,
    237                                                         CPU_INT08U      *ptx_buf,
    238                                                         CPU_SIZE_T       rx_pkt_size,
    239                                                         CPU_SIZE_T       tx_buf_size);
    240          
    241          static  CPU_SIZE_T   ProbeCom_ReqWrMulti      (CPU_INT08U      *prx_buf,
    242                                                         CPU_INT08U      *ptx_buf,
    243                                                         CPU_SIZE_T       rx_pkt_size,
    244                                                         CPU_SIZE_T       tx_buf_size);
    245          #endif
    246          
    247          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    248          static  CPU_SIZE_T   ProbeCom_ReqStrIn        (CPU_INT08U      *prx_buf,
    249                                                         CPU_INT08U      *ptx_buf,
    250                                                         CPU_SIZE_T       rx_pkt_size,
    251                                                         CPU_SIZE_T       tx_buf_size);
    252          
    253          static  CPU_SIZE_T   ProbeCom_ReqStrOut       (CPU_INT08U      *prx_buf,
    254                                                         CPU_INT08U      *ptx_buf,
    255                                                         CPU_SIZE_T       rx_pkt_size,
    256                                                         CPU_SIZE_T       tx_buf_size);
    257          #endif
    258          
    259          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    260          static  CPU_SIZE_T   ProbeCom_ReqTerminalExec (CPU_INT08U      *prx_buf,
    261                                                         CPU_INT08U      *ptx_buf,
    262                                                         CPU_SIZE_T       rx_pkt_size,
    263                                                         CPU_SIZE_T       tx_buf_size);
    264          
    265          static  CPU_SIZE_T   ProbeCom_ReqTerminalIn   (CPU_INT08U      *prx_buf,
    266                                                         CPU_INT08U      *ptx_buf,
    267                                                         CPU_SIZE_T       rx_pkt_size,
    268                                                         CPU_SIZE_T       tx_buf_size);
    269          
    270          static  CPU_SIZE_T   ProbeCom_ReqTerminalOut  (CPU_INT08U      *prx_buf,
    271                                                         CPU_INT08U      *ptx_buf,
    272                                                         CPU_SIZE_T       rx_pkt_size,
    273                                                         CPU_SIZE_T       tx_buf_size);
    274          #endif
    275          
    276                                                                          /* ------------------- DYNAMIC BUFFER ----------------- */
    277          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_TRUE)
    278          static  void         ProbeCom_BufInit         (PROBE_COM_BUF   *pbuf,
    279                                                         CPU_INT08U      *pdata,
    280                                                         CPU_SIZE_T       len);
    281          
    282          static  CPU_SIZE_T   ProbeCom_BufRd           (PROBE_COM_BUF   *pbuf,
    283                                                         CPU_INT08U      *pdest,
    284                                                         CPU_SIZE_T       len)
    285          ;
    286          static  CPU_SIZE_T   ProbeCom_BufWr           (PROBE_COM_BUF   *pbuf,
    287                                                         CPU_INT08U      *psrc,
    288                                                         CPU_SIZE_T       len);
    289          
    290          static  CPU_BOOLEAN  ProbeCom_BufIsEmpty      (PROBE_COM_BUF   *pbuf);
    291          #endif
    292          
    293          #if 0
    294          static  CPU_BOOLEAN  ProbeCom_BufIsFull       (PROBE_COM_BUF   *pbuf);
    295          #endif
    296          
    297                                                                          /* ------------------- STATIC BUFFER ------------------ */
    298          static  CPU_INT08U   ProbeCom_GetINT08U       (CPU_INT08U     **pbuf);
    299          
    300          static  CPU_INT16U   ProbeCom_GetINT16U       (CPU_INT08U     **pbuf);
    301          
    302          static  CPU_INT32U   ProbeCom_GetINT32U       (CPU_INT08U     **pbuf);
    303          
    304          static  void         ProbeCom_StoINT08U       (CPU_INT08U     **pbuf,
    305                                                         CPU_INT08U       data);
    306          
    307          static  void         ProbeCom_StoINT16U       (CPU_INT08U     **pbuf,
    308                                                         CPU_INT16U       data);
    309          
    310          #if 0
    311          static  void         ProbeCom_StoINT32U       (CPU_INT08U     **pbuf,
    312                                                         CPU_INT32U       data);
    313          #endif
    314          
    315                                                                          /* -------------- DETERMINE PKT MODIFIER -------------- */
    316          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    317          static  CPU_BOOLEAN  ProbeCom_StrOutAvail     (void);
    318          #endif
    319          
    320          
    321          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    322          static  CPU_BOOLEAN  ProbeCom_TerminalOutAvail(void);
    323          
    324          static  CPU_BOOLEAN  ProbeCom_TerminalExecDone(void);
    325          #endif
    326          
    327          
    328          /*
    329          *********************************************************************************************************
    330          *                                     LOCAL CONFIGURATION ERRORS
    331          *********************************************************************************************************
    332          */
    333          
    334          
    335          /*
    336          *********************************************************************************************************
    337          *                                           ProbeCom_Init()
    338          *
    339          * Description : Initialize the module.
    340          *
    341          * Argument(s) : none.
    342          *
    343          * Return(s)   : none.
    344          *
    345          * Caller(s)   : Application.
    346          *
    347          * Note(s)     : none.
    348          *********************************************************************************************************
    349          */
    350          

   \                                 In section .text, align 2, keep-with-next
    351          void  ProbeCom_Init (void)
    352          {
   \                     ProbeCom_Init:
   \   00000000   0xB580             PUSH     {R7,LR}
    353          #if (PROBE_COM_CFG_STR_REQ_EN      == DEF_ENABLED)
    354              Mem_Clr((void     *)&ProbeCom_StrInBufData[0],
    355                      (CPU_SIZE_T) PROBE_COM_CFG_STR_IN_BUF_SIZE);
    356          
    357              ProbeCom_BufInit(&ProbeCom_StrInBuf,
    358                               &ProbeCom_StrInBufData[0],
    359                                PROBE_COM_CFG_STR_IN_BUF_SIZE);
    360          
    361              Mem_Clr((void     *)&ProbeCom_StrOutBufData[0],
    362                      (CPU_SIZE_T) PROBE_COM_CFG_STR_OUT_BUF_SIZE);
    363          
    364              ProbeCom_BufInit(&ProbeCom_StrOutBuf,
    365                               &ProbeCom_StrOutBufData[0],
    366                                PROBE_COM_CFG_STR_OUT_BUF_SIZE);
    367          #endif
    368          
    369          
    370          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    371              ProbeCom_TerminalExecHandler   = (void        *)0;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x6001             STR      R1,[R0, #+0]
    372              ProbeCom_TerminalExecuting     = (CPU_BOOLEAN  )DEF_NO;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7001             STRB     R1,[R0, #+0]
    373          
    374              ProbeCom_TerminalInHandler     = (void        *)0;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6001             STR      R1,[R0, #+0]
    375          
    376              ProbeCom_TerminalOutBufPtr     = (CPU_INT08U  *)0;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6001             STR      R1,[R0, #+0]
    377              ProbeCom_TerminalOutBufIx      = (CPU_SIZE_T   )0;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x6001             STR      R1,[R0, #+0]
    378              ProbeCom_TerminalOutBufLen     = (CPU_SIZE_T   )0;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x6001             STR      R1,[R0, #+0]
    379          
    380              ProbeCom_OS_Init();
   \   00000032   0x.... 0x....      BL       ProbeCom_OS_Init
    381          #endif
    382          
    383          
    384          #if (PROBE_COM_CFG_STAT_EN         == DEF_ENABLED)
    385              ProbeCom_RxPktCtr              =  0;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x6001             STR      R1,[R0, #+0]
    386              ProbeCom_TxPktCtr              =  0;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x6001             STR      R1,[R0, #+0]
    387          
    388              ProbeCom_TxSymCtr              =  0;
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x6001             STR      R1,[R0, #+0]
    389              ProbeCom_TxSymByteCtr          =  0;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x6001             STR      R1,[R0, #+0]
    390              ProbeCom_ErrPktCtr             =  0;
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable16_10
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    391          
    392          #if (PROBE_COM_CFG_STR_REQ_EN      == DEF_ENABLED)
    393              ProbeCom_StrRxCtr              =  0;
    394              ProbeCom_StrRxOvfErrCtr        =  0;
    395          
    396              ProbeCom_StrTxCtr              =  0;
    397              ProbeCom_StrTxOvfErrCtr        =  0;
    398          #endif
    399          
    400          #if (PROBE_COM_CFG_WR_REQ_EN       == DEF_ENABLED)
    401              ProbeCom_RxSymCtr              =  0;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable16_11
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x6001             STR      R1,[R0, #+0]
    402              ProbeCom_RxSymByteCtr          =  0;
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable16_12
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x6001             STR      R1,[R0, #+0]
    403          #endif
    404          #endif
    405          
    406              ProbeCom_EndiannessTest        =  0x12345678L;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable16_14  ;; 0x12345678
   \   00000076   0x6001             STR      R1,[R0, #+0]
    407          }
   \   00000078   0xBD01             POP      {R0,PC}          ;; return
    408          
    409          
    410          /*
    411          *********************************************************************************************************
    412          *                                          ProbeCom_StrRd()
    413          *
    414          * Description : Read input data.
    415          *
    416          * Argument(s) : pdest       Pointer to the destination buffer.
    417          *
    418          *               len         Length of the destination buffer, in octets/characters.
    419          *
    420          * Return(s)   : Number of octets/characters read.
    421          *
    422          * Caller(s)   : Application.
    423          *
    424          * Note(s)     : (1) This function implements a non-blocking read.  It will read as much data as fits
    425          *                   into the buffer, up to 'len' bytes/characters.  The calling application should
    426          *                   monitor the return value to see if more data needs to be read.
    427          *
    428          *               (2) Since this function never blocks, it should not be called in a tight loop without a
    429          *                   delay.
    430          *
    431          *               (3) This function MAY be called from an ISR.
    432          *********************************************************************************************************
    433          */
    434          
    435          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    436          CPU_SIZE_T  ProbeCom_StrRd (CPU_INT08U  *pdest,
    437                                      CPU_SIZE_T   len)
    438          {
    439              CPU_SIZE_T  len_rd;
    440          
    441          
    442              len_rd = ProbeCom_BufRd(&ProbeCom_StrInBuf,
    443                                       pdest,
    444                                       len);
    445          
    446              return (len_rd);
    447          }
    448          #endif
    449          
    450          
    451          /*
    452          *********************************************************************************************************
    453          *                                          ProbeCom_StrWr()
    454          *
    455          * Description : Write or buffer data for output.
    456          *
    457          * Argument(s) : psrc        Pointer to the source buffer.
    458          *
    459          *               len         Length of the source buffer, in octets/characters.
    460          *
    461          * Return(s)   : Number of octets/characters written or buffered.
    462          *
    463          * Caller(s)   : Application.
    464          *
    465          * Note(s)     : (1) This function implements a non-blocking write.  It will write as much data as fits
    466          *                   into the buffer, up to 'len' bytes/characters.  The calling application should
    467          *                   monitor the return value to see if more data from the buffer needs to be written.
    468          *
    469          *               (2) Since this function never blocks, it should not be called in a tight loop without a
    470          *                   delay.
    471          *
    472          *               (3) This function MAY be called from an ISR.
    473          *********************************************************************************************************
    474          */
    475          
    476          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    477          CPU_SIZE_T  ProbeCom_StrWr (CPU_INT08U  *psrc,
    478                                      CPU_SIZE_T   len)
    479          {
    480              CPU_SIZE_T  len_wr;
    481          
    482          
    483              len_wr = ProbeCom_BufWr(&ProbeCom_StrOutBuf,
    484                                       psrc,
    485                                       len);
    486          
    487          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
    488              if (len_wr < len) {
    489                  ProbeCom_StrTxOvfErrCtr++;
    490              }
    491          #endif
    492          
    493              return (len_wr);
    494          }
    495          #endif
    496          
    497          
    498          /*
    499          *********************************************************************************************************
    500          *                                       ProbeCom_TerminalOut()
    501          *
    502          * Description : Output data over terminal.
    503          *
    504          * Argument(s) : psrc        Pointer to the source buffer.
    505          *
    506          *               len         Length of source buffer, in octets/characters.
    507          *
    508          * Return(s)   : Number of octets/characters output.
    509          *
    510          * Caller(s)   : Application.
    511          *
    512          * Note(s)     : (1) This function implements a blocking write.  It will queue the request and wait until
    513          *                   all of the data has been buffered or transmitted before returning.
    514          *
    515          *               (2) Terminal data may ONLY be output while a command is being executed.
    516          *
    517          *                   (a) Generic read/write functionality is provided by the string read/write functions
    518          *                       (see 'ProbeCom_StrRd()', 'ProbeCom_StrWr()').
    519          *
    520          *               (3) This function MUST NOT be called from an ISR.
    521          *********************************************************************************************************
    522          */
    523          
    524          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    525          CPU_SIZE_T  ProbeCom_TerminalOut (CPU_INT08U  *psrc,
    526                                            CPU_SIZE_T   len)
    527          {
   \                     ProbeCom_TerminalOut:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
    528          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
    529              CPU_SR  cpu_sr;
    530          #endif
    531          
    532          
    533                                                                          /* ------------------- VALIDATE ARGS ------------------ */
    534              if (psrc == (CPU_INT08U *)0) {                              /* Validate NULL ptr.                                   */
   \   00000006   0x2E00             CMP      R6,#+0
   \   00000008   0xD101             BNE.N    ??ProbeCom_TerminalOut_0
    535                  return ((CPU_SIZE_T)0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE030             B.N      ??ProbeCom_TerminalOut_1
    536              }
    537          
    538              if (len == (CPU_INT08U)0) {                                 /* Validate NULL len.                                   */
   \                     ??ProbeCom_TerminalOut_0:
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD101             BNE.N    ??ProbeCom_TerminalOut_2
    539                  return ((CPU_SIZE_T)0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE02C             B.N      ??ProbeCom_TerminalOut_1
    540              }
    541          
    542          
    543          
    544                                                                          /* ------------------- START OUTPUT ------------------- */
    545              CPU_CRITICAL_ENTER();
   \                     ??ProbeCom_TerminalOut_2:
   \   00000016   0x.... 0x....      BL       CPU_SR_Save
   \   0000001A   0x0005             MOVS     R5,R0
    546              if (ProbeCom_TerminalExecuting == DEF_NO) {                 /* Chk if cmd exec'ing.                                 */
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD101             BNE.N    ??ProbeCom_TerminalOut_3
    547                  return ((CPU_SIZE_T)0);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE022             B.N      ??ProbeCom_TerminalOut_1
    548              }
    549          
    550              if (ProbeCom_TerminalOutBufPtr != (CPU_INT08U *)0) {        /* Chk if out in progress.                              */
   \                     ??ProbeCom_TerminalOut_3:
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD001             BEQ.N    ??ProbeCom_TerminalOut_4
    551                  return ((CPU_SIZE_T)0);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE01B             B.N      ??ProbeCom_TerminalOut_1
    552              }
    553          
    554              ProbeCom_TerminalOutBufPtr = (CPU_INT08U *)psrc;            /* Schedule output.                                     */
   \                     ??ProbeCom_TerminalOut_4:
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   0000003C   0x6006             STR      R6,[R0, #+0]
    555              ProbeCom_TerminalOutBufIx  = (CPU_SIZE_T  )0;
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x6001             STR      R1,[R0, #+0]
    556              ProbeCom_TerminalOutBufLen = (CPU_SIZE_T  )len;
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   0000004A   0x6004             STR      R4,[R0, #+0]
    557          
    558              ProbeCom_OS_TerminalOutWait();                              /* Wait for output completion.                          */
   \   0000004C   0x.... 0x....      BL       ProbeCom_OS_TerminalOutWait
    559          
    560              ProbeCom_TerminalOutBufPtr = (CPU_INT08U *)0;
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x6001             STR      R1,[R0, #+0]
    561              ProbeCom_TerminalOutBufIx  = (CPU_SIZE_T  )0;
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x6001             STR      R1,[R0, #+0]
    562              ProbeCom_TerminalOutBufLen = (CPU_SIZE_T  )0;
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x6001             STR      R1,[R0, #+0]
    563              CPU_CRITICAL_EXIT();
   \   00000068   0x0028             MOVS     R0,R5
   \   0000006A   0x.... 0x....      BL       CPU_SR_Restore
    564          
    565          
    566          
    567                                                                          /* ----------------------- RTN ------------------------ */
    568              return (len);
   \   0000006E   0x0020             MOVS     R0,R4
   \                     ??ProbeCom_TerminalOut_1:
   \   00000070   0xBD70             POP      {R4-R6,PC}       ;; return
    569          }
    570          #endif
    571          
    572          
    573          /*
    574          *********************************************************************************************************
    575          *                                   ProbeCom_TerminalExecComplete()
    576          *
    577          * Description : Signal completion of command execution.
    578          *
    579          * Argument(s) : none.
    580          *
    581          * Return(s)   : The number of bytes in the data segment of the packet to transmit in response.
    582          *
    583          * Caller(s)   : Application.
    584          *
    585          * Note(s)     : none.
    586          *********************************************************************************************************
    587          */
    588          
    589          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    590          void  ProbeCom_TerminalExecComplete (void)
    591          {
   \                     ProbeCom_TerminalExecComplete:
   \   00000000   0xB580             PUSH     {R7,LR}
    592          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
    593              CPU_SR       cpu_sr;
    594          #endif
    595              CPU_BOOLEAN  executing;
    596          
    597          
    598              CPU_CRITICAL_ENTER();
   \   00000002   0x.... 0x....      BL       CPU_SR_Save
    599              executing = ProbeCom_TerminalExecuting;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
    600              if (executing == DEF_YES) {
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD103             BNE.N    ??ProbeCom_TerminalExecComplete_0
    601                  ProbeCom_TerminalExecuting = DEF_NO;
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x700A             STRB     R2,[R1, #+0]
    602              }
    603              CPU_CRITICAL_EXIT()
   \                     ??ProbeCom_TerminalExecComplete_0:
   \   0000001A   0x.... 0x....      BL       CPU_SR_Restore
    604          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
    605          #endif
    606          
    607          
    608          /*
    609          *********************************************************************************************************
    610          *                                     ProbeCom_TerminalExecSet()
    611          *
    612          * Description : Set the handler that will be invoked to process a terminal command.
    613          *
    614          * Argument(s) : handler         The handler that will be invoked.
    615          *
    616          * Return(s)   : none.
    617          *
    618          * Caller(s)   : Application.
    619          *
    620          * Note(s)     : (1) The handler should be a function with the following prototype:
    621          *
    622          *	                    void  App_TerminalExecFnct (CPU_CHAR    *pstr,
    623          *                                                   CPU_SIZE_T   len);
    624          *
    625          *                   where 'pstr' is a pointer to the command string, and 'len' is the length of the
    626          *                   command string (in characters) excluding the final NULL byte.  The command string
    627          *                   will NOT include a terminating new line or line feed.
    628          *********************************************************************************************************
    629          */
    630          
    631          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    632          void  ProbeCom_TerminalExecSet (PROBE_COM_TERMINAL_EXEC_FNCT  handler)
    633          {
   \                     ProbeCom_TerminalExecSet:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    634          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
    635              CPU_SR  cpu_sr;
    636          #endif
    637          
    638          
    639              CPU_CRITICAL_ENTER();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
    640              ProbeCom_TerminalExecHandler = handler;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000000C   0x600C             STR      R4,[R1, #+0]
    641              CPU_CRITICAL_EXIT();
   \   0000000E   0x.... 0x....      BL       CPU_SR_Restore
    642          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    643          #endif
    644          
    645          
    646          /*
    647          *********************************************************************************************************
    648          *                                      ProbeCom_TerminalInSet()
    649          *
    650          * Description : Set the handler that will be invoked to process terminal input.
    651          *
    652          * Argument(s) : handler         The handler that will be invoked.
    653          *
    654          * Return(s)   : none.
    655          *
    656          * Caller(s)   : Application.
    657          *
    658          * Note(s)     : (1) The handler should be a function with the following prototype:
    659          *
    660          *	                    void  App_TerminalInFnct (CPU_CHAR    *pstr,
    661          *                                                 CPU_SIZE_T   len);
    662          *
    663          *                   where 'pstr' is a pointer to the input string, and 'len' is the length of the input
    664          *                   string (in characters) excluding the final NULL byte.  The input string will NOT
    665          *                   include a terminating new line or line feed.
    666          *********************************************************************************************************
    667          */
    668          
    669          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    670          void  ProbeCom_TerminalInSet (PROBE_COM_TERMINAL_IN_FNCT  handler)
    671          {
   \                     ProbeCom_TerminalInSet:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    672          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
    673              CPU_SR  cpu_sr;
    674          #endif
    675          
    676          
    677              CPU_CRITICAL_ENTER();
   \   00000004   0x.... 0x....      BL       CPU_SR_Save
    678              ProbeCom_TerminalInHandler = handler;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable16_2
   \   0000000C   0x600C             STR      R4,[R1, #+0]
    679              CPU_CRITICAL_EXIT();
   \   0000000E   0x.... 0x....      BL       CPU_SR_Restore
    680          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    681          #endif
    682          
    683          
    684          /*
    685          *********************************************************************************************************
    686          *                                        ProbeCom_ParseRxPkt()
    687          *
    688          * Description : Parse a packet & formulate a response.
    689          *
    690          * Argument(s) : prx_pkt         Pointer to the receive  packet buffer
    691          *
    692          *               ptx_pkt         Pointer to the transmit packet buffer
    693          *
    694          *               rx_pkt_size     Size of the received packet
    695          *
    696          *               tx_pkt_size     Size of the transmit packet buffer
    697          *
    698          * Return(s)   : The number of bytes in the data segment of the packet to transmit in response.
    699          *
    700          * Caller(s)   : Tasks/receive handlers in communications-specific drivers, (e.g., probe_rs232,
    701          *               probe_usb, probe_tcpip, etc.).
    702          *
    703          * Note(s)     : none.
    704          *********************************************************************************************************
    705          */
    706          

   \                                 In section .text, align 2, keep-with-next
    707          CPU_SIZE_T  ProbeCom_ParseRxPkt (void        *prx_pkt,
    708                                           void        *ptx_pkt,
    709                                           CPU_SIZE_T   rx_pkt_size,
    710                                           CPU_SIZE_T   tx_buf_size)
    711          {
   \                     ProbeCom_ParseRxPkt:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x000C             MOVS     R4,R1
    712              CPU_SIZE_T   tx_buf_wr;
    713              CPU_INT16U   format;
    714              CPU_INT08U  *prx_pkt_08;
    715              CPU_INT08U  *ptx_pkt_08;
    716          
    717          
    718              if (rx_pkt_size < 2) {
   \   00000004   0x2A02             CMP      R2,#+2
   \   00000006   0xD201             BCS.N    ??ProbeCom_ParseRxPkt_0
    719                  return (0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE048             B.N      ??ProbeCom_ParseRxPkt_1
    720              }
    721          
    722              prx_pkt_08  = (CPU_INT08U *)prx_pkt;
    723              ptx_pkt_08  = (CPU_INT08U *)ptx_pkt;
    724              format      = (prx_pkt_08[1] << 8) + prx_pkt_08[0];
   \                     ??ProbeCom_ParseRxPkt_0:
   \   0000000C   0x7841             LDRB     R1,[R0, #+1]
   \   0000000E   0x7805             LDRB     R5,[R0, #+0]
   \   00000010   0xEB15 0x2101      ADDS     R1,R5,R1, LSL #+8
    725              prx_pkt_08 += 2;
   \   00000014   0x1C80             ADDS     R0,R0,#+2
    726          
    727          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
    728              ProbeCom_RxPktCtr++;
   \   00000016   0x.... 0x....      LDR.W    R5,??DataTable16_6
   \   0000001A   0x682D             LDR      R5,[R5, #+0]
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   \   0000001E   0x.... 0x....      LDR.W    R6,??DataTable16_6
   \   00000022   0x6035             STR      R5,[R6, #+0]
    729              ProbeCom_TxPktCtr++;
   \   00000024   0x.... 0x....      LDR.W    R5,??DataTable16_7
   \   00000028   0x682D             LDR      R5,[R5, #+0]
   \   0000002A   0x1C6D             ADDS     R5,R5,#+1
   \   0000002C   0x.... 0x....      LDR.W    R6,??DataTable16_7
   \   00000030   0x6035             STR      R5,[R6, #+0]
    730          #endif
    731          
    732              switch (format) {
   \   00000032   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000034   0x2901             CMP      R1,#+1
   \   00000036   0xD00E             BEQ.N    ??ProbeCom_ParseRxPkt_2
   \   00000038   0x2902             CMP      R1,#+2
   \   0000003A   0xD010             BEQ.N    ??ProbeCom_ParseRxPkt_3
   \   0000003C   0x2903             CMP      R1,#+3
   \   0000003E   0xD016             BEQ.N    ??ProbeCom_ParseRxPkt_4
   \   00000040   0x2907             CMP      R1,#+7
   \   00000042   0xD010             BEQ.N    ??ProbeCom_ParseRxPkt_5
   \   00000044   0x2908             CMP      R1,#+8
   \   00000046   0xD016             BEQ.N    ??ProbeCom_ParseRxPkt_6
   \   00000048   0x290B             CMP      R1,#+11
   \   0000004A   0xD018             BEQ.N    ??ProbeCom_ParseRxPkt_7
   \   0000004C   0x290C             CMP      R1,#+12
   \   0000004E   0xD01E             BEQ.N    ??ProbeCom_ParseRxPkt_8
   \   00000050   0x290D             CMP      R1,#+13
   \   00000052   0xD018             BEQ.N    ??ProbeCom_ParseRxPkt_9
   \   00000054   0xE01F             B.N      ??ProbeCom_ParseRxPkt_10
    733                  case PROBE_COM_FMT_RX_QUERY:
    734                       tx_buf_wr = ProbeCom_ReqQuery(       prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
   \                     ??ProbeCom_ParseRxPkt_2:
   \   00000056   0x0021             MOVS     R1,R4
   \   00000058   0x.... 0x....      BL       ProbeCom_ReqQuery
    735                       break;
   \   0000005C   0xE01F             B.N      ??ProbeCom_ParseRxPkt_11
    736          
    737                  case PROBE_COM_FMT_RX_RD:
    738                       tx_buf_wr = ProbeCom_ReqRd(          prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
   \                     ??ProbeCom_ParseRxPkt_3:
   \   0000005E   0x0021             MOVS     R1,R4
   \   00000060   0x.... 0x....      BL       ProbeCom_ReqRd
    739                       break;
   \   00000064   0xE01B             B.N      ??ProbeCom_ParseRxPkt_11
    740          
    741                  case PROBE_COM_FMT_RX_RD_MULTI:
    742                       tx_buf_wr = ProbeCom_ReqRdMulti(     prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
   \                     ??ProbeCom_ParseRxPkt_5:
   \   00000066   0x0021             MOVS     R1,R4
   \   00000068   0x.... 0x....      BL       ProbeCom_ReqRdMulti
    743                       break;
   \   0000006C   0xE017             B.N      ??ProbeCom_ParseRxPkt_11
    744          
    745          #if (PROBE_COM_CFG_WR_REQ_EN == DEF_ENABLED)
    746                  case PROBE_COM_FMT_RX_WR:
    747                       tx_buf_wr = ProbeCom_ReqWr(          prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
   \                     ??ProbeCom_ParseRxPkt_4:
   \   0000006E   0x0021             MOVS     R1,R4
   \   00000070   0x.... 0x....      BL       ProbeCom_ReqWr
    748                       break;
   \   00000074   0xE013             B.N      ??ProbeCom_ParseRxPkt_11
    749          
    750                  case PROBE_COM_FMT_RX_WR_MULTI:
    751                       tx_buf_wr = ProbeCom_ReqWrMulti(     prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
   \                     ??ProbeCom_ParseRxPkt_6:
   \   00000076   0x0021             MOVS     R1,R4
   \   00000078   0x.... 0x....      BL       ProbeCom_ReqWrMulti
    752                       break;
   \   0000007C   0xE00F             B.N      ??ProbeCom_ParseRxPkt_11
    753          #endif
    754          
    755          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    756                  case PROBE_COM_FMT_RX_STR_IN:
    757                       tx_buf_wr = ProbeCom_ReqStrIn(       prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
    758                       break;
    759          
    760                  case PROBE_COM_FMT_RX_STR_OUT:
    761                       tx_buf_wr = ProbeCom_ReqStrOut(      prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
    762                       break;
    763          #endif
    764          
    765          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    766                  case PROBE_COM_FMT_RX_TERMINAL_EXEC:
    767                       tx_buf_wr = ProbeCom_ReqTerminalExec(prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
   \                     ??ProbeCom_ParseRxPkt_7:
   \   0000007E   0x0021             MOVS     R1,R4
   \   00000080   0x.... 0x....      BL       ProbeCom_ReqTerminalExec
    768                       break;
   \   00000084   0xE00B             B.N      ??ProbeCom_ParseRxPkt_11
    769          
    770                  case PROBE_COM_FMT_RX_TERMINAL_IN:
    771                       tx_buf_wr = ProbeCom_ReqTerminalIn(  prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
   \                     ??ProbeCom_ParseRxPkt_9:
   \   00000086   0x0021             MOVS     R1,R4
   \   00000088   0x.... 0x....      BL       ProbeCom_ReqTerminalIn
    772                       break;
   \   0000008C   0xE007             B.N      ??ProbeCom_ParseRxPkt_11
    773          
    774                  case PROBE_COM_FMT_RX_TERMINAL_OUT:
    775                       tx_buf_wr = ProbeCom_ReqTerminalOut( prx_pkt_08, ptx_pkt_08, rx_pkt_size, tx_buf_size);
   \                     ??ProbeCom_ParseRxPkt_8:
   \   0000008E   0x0021             MOVS     R1,R4
   \   00000090   0x.... 0x....      BL       ProbeCom_ReqTerminalOut
    776                       break;
   \   00000094   0xE003             B.N      ??ProbeCom_ParseRxPkt_11
    777          #endif
    778          
    779                  default:
    780                       tx_buf_wr = ProbeCom_ReqErr(                     ptx_pkt_08, PROBE_COM_STATUS_UNKNOWN_REQUEST);
   \                     ??ProbeCom_ParseRxPkt_10:
   \   00000096   0x21F9             MOVS     R1,#+249
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       ProbeCom_ReqErr
    781                       break;
    782              }
    783          
    784              return (tx_buf_wr);
   \                     ??ProbeCom_ParseRxPkt_11:
   \                     ??ProbeCom_ParseRxPkt_1:
   \   0000009E   0xBD70             POP      {R4-R6,PC}       ;; return
    785          }
    786          
    787          
    788          /*
    789          *********************************************************************************************************
    790          *********************************************************************************************************
    791          *                                           LOCAL FUNCTIONS
    792          *********************************************************************************************************
    793          *********************************************************************************************************
    794          */
    795          
    796          /*
    797          *********************************************************************************************************
    798          *                                       ProbeCom_StrOutAvail()
    799          *
    800          * Description : Check if string output is waiting for transmission.
    801          *
    802          * Argument(s) : none.
    803          *
    804          * Return(s)   : DEF_TRUE   if a  string output is waiting for transmission.
    805          *               DEF_FALSE  if no string output is waiting for transmission.
    806          *
    807          * Caller(s)   : ProbeCom_PktModifier().
    808          *
    809          * Note(s)     : (1) See Notes for 'ProbeCom_StrWr()'.
    810          *********************************************************************************************************
    811          */
    812          
    813          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    814          static  CPU_BOOLEAN  ProbeCom_StrOutAvail (void)
    815          {
    816              CPU_BOOLEAN  avail;
    817              CPU_BOOLEAN  empty;
    818          
    819          
    820              empty = ProbeCom_BufIsEmpty(&ProbeCom_StrOutBuf);
    821              avail = (empty == DEF_YES) ? (DEF_FALSE) : (DEF_TRUE);
    822          
    823              return (avail);
    824          }
    825          #endif
    826          
    827          
    828          
    829          /*
    830          *********************************************************************************************************
    831          *                                     ProbeCom_TerminalOutAvail()
    832          *
    833          * Description : Check if terminal output is waiting for transmission.
    834          *
    835          * Argument(s) : none.
    836          *
    837          * Return(s)   : DEF_TRUE   if a  terminal output is waiting for transmission.
    838          *               DEF_FALSE  if no terminal output is waiting for transmission.
    839          *
    840          * Caller(s)   : ProbeCom_PktModifier().
    841          *
    842          * Note(s)     : (1) See Notes for 'ProbeCom_TerminalOut()'.
    843          *********************************************************************************************************
    844          */
    845          
    846          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    847          static  CPU_BOOLEAN  ProbeCom_TerminalOutAvail (void)
    848          {
   \                     ProbeCom_TerminalOutAvail:
   \   00000000   0xB510             PUSH     {R4,LR}
    849          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
    850              CPU_SR       cpu_sr;
    851          #endif
    852              CPU_SIZE_T   buf_len;
    853              CPU_BOOLEAN  avail;
    854          
    855          
    856              CPU_CRITICAL_ENTER();
   \   00000002   0x.... 0x....      BL       CPU_SR_Save
    857              buf_len = ProbeCom_TerminalOutBufLen;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   0000000A   0x680C             LDR      R4,[R1, #+0]
    858              CPU_CRITICAL_EXIT();
   \   0000000C   0x.... 0x....      BL       CPU_SR_Restore
    859          
    860              avail   = (buf_len == 0) ? (DEF_FALSE) : (DEF_TRUE);
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD101             BNE.N    ??ProbeCom_TerminalOutAvail_0
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE000             B.N      ??ProbeCom_TerminalOutAvail_1
   \                     ??ProbeCom_TerminalOutAvail_0:
   \   00000018   0x2001             MOVS     R0,#+1
    861          
    862              return (avail);
   \                     ??ProbeCom_TerminalOutAvail_1:
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
    863          }
    864          #endif
    865          
    866          
    867          
    868          /*
    869          *********************************************************************************************************
    870          *                                     ProbeCom_TerminalExecDone()
    871          *
    872          * Description : Check if terminal execution is done.
    873          *
    874          * Argument(s) : none.
    875          *
    876          * Return(s)   : DEF_TRUE   if terminal command execution is     done.
    877          *               DEF_FALSE  if terminal command execution is NOT done.
    878          *
    879          * Caller(s)   : ProbeCom_PktModifier().
    880          *
    881          * Note(s)     : (1) See Notes for 'ProbeCom_TerminalOut()'.
    882          *********************************************************************************************************
    883          */
    884          
    885          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
    886          static  CPU_BOOLEAN  ProbeCom_TerminalExecDone (void)
    887          {
   \                     ProbeCom_TerminalExecDone:
   \   00000000   0xB510             PUSH     {R4,LR}
    888          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
    889              CPU_SR       cpu_sr;
    890          #endif
    891              CPU_BOOLEAN  executing;
    892              CPU_BOOLEAN  done;
    893          
    894          
    895              CPU_CRITICAL_ENTER();
   \   00000002   0x.... 0x....      BL       CPU_SR_Save
    896              executing = ProbeCom_TerminalExecuting;
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   0000000A   0x780C             LDRB     R4,[R1, #+0]
    897              CPU_CRITICAL_EXIT();
   \   0000000C   0x.... 0x....      BL       CPU_SR_Restore
    898          
    899              done = (executing == DEF_YES) ? (DEF_FALSE) : (DEF_TRUE);
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C01             CMP      R4,#+1
   \   00000014   0xD101             BNE.N    ??ProbeCom_TerminalExecDone_0
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE000             B.N      ??ProbeCom_TerminalExecDone_1
   \                     ??ProbeCom_TerminalExecDone_0:
   \   0000001A   0x2001             MOVS     R0,#+1
    900          
    901              return (done);
   \                     ??ProbeCom_TerminalExecDone_1:
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    902          }
    903          #endif
    904          
    905          
    906          /*
    907          *********************************************************************************************************
    908          *                                       ProbeCom_PktModifier()
    909          *
    910          * Description : Get packet modfier byte.
    911          *
    912          * Argument(s) : none.
    913          *
    914          * Return(s)   : The modifier byte.
    915          *
    916          * Caller(s)   : Various command handlers (ProbeCom_Req????()).
    917          *
    918          * Note(s)     : none.
    919          *********************************************************************************************************
    920          */
    921          

   \                                 In section .text, align 2, keep-with-next
    922          static  CPU_INT08U  ProbeCom_PktModifier (void)
    923          {
   \                     ProbeCom_PktModifier:
   \   00000000   0xB510             PUSH     {R4,LR}
    924          #if ((PROBE_COM_CFG_STR_REQ_EN      == DEF_ENABLED) || \
    925               (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED))
    926              CPU_BOOLEAN  avail;
    927          #endif
    928          #if  (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    929              CPU_BOOLEAN  done;
    930          #endif
    931              CPU_INT08U   mod;
    932          
    933          
    934              mod = PROBE_COM_MODIFIER_NONE;
   \   00000002   0x2400             MOVS     R4,#+0
    935          
    936          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
    937              avail = ProbeCom_StrOutAvail();
    938              if (avail == DEF_TRUE) {
    939                  DEF_BIT_SET(mod, PROBE_COM_MODIFIER_STR_OUT_AVAIL);
    940              }
    941          #endif
    942          
    943          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
    944              avail = ProbeCom_TerminalOutAvail();
   \   00000004   0x.... 0x....      BL       ProbeCom_TerminalOutAvail
    945              if (avail == DEF_TRUE) {
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD101             BNE.N    ??ProbeCom_PktModifier_0
    946                  DEF_BIT_SET(mod, PROBE_COM_MODIFIER_TERMINAL_OUT_AVAIL);
   \   0000000E   0xF054 0x0404      ORRS     R4,R4,#0x4
    947              }
    948          
    949              done = ProbeCom_TerminalExecDone();
   \                     ??ProbeCom_PktModifier_0:
   \   00000012   0x.... 0x....      BL       ProbeCom_TerminalExecDone
    950              if (done == DEF_TRUE) {
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD101             BNE.N    ??ProbeCom_PktModifier_1
    951                  DEF_BIT_SET(mod, PROBE_COM_MODIFIER_TERMINAL_EXEC_DONE);
   \   0000001C   0xF054 0x0402      ORRS     R4,R4,#0x2
    952              }
    953          #endif
    954          
    955              return (mod);
   \                     ??ProbeCom_PktModifier_1:
   \   00000020   0x0020             MOVS     R0,R4
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    956          }
    957          
    958          
    959          /*
    960          *********************************************************************************************************
    961          *                                          ProbeCom_ReqErr()
    962          *
    963          * Description : Formulate error response when the target receives a request it cannot handle.
    964          *
    965          * Argument(s) : ptx_buf      Pointer to the transmit buffer
    966          *
    967          *               comm_err     Error that occurred
    968          *
    969          * Return(s)   : The number of bytes written to the tx buffer.
    970          *
    971          * Caller(s)   : Various command handlers (ProbeCom_Req????()).
    972          *
    973          * Note(s)     : (1) The TX format:
    974          *
    975          *                   (A) A 2-byte format  , indicating the data segment format;
    976          *                   (B) A 1-byte constant, PROBE_RS232_OK,   if the location can    be read;
    977          *                       A 1-byte constant, PROBE_RS232_FAIL, if the location cannot be read.
    978          *                   (C) A 1-byte modifier.
    979          *
    980          *                         +-------------------------+------------+------------+
    981          *                         |          Format         |   Status   |  Modifier  |
    982          *                         +-------------------------+------------+------------+
    983          *********************************************************************************************************
    984          */
    985          

   \                                 In section .text, align 2, keep-with-next
    986          static  CPU_SIZE_T  ProbeCom_ReqErr (CPU_INT08U  *ptx_buf,
    987                                               CPU_INT08U   comm_err)
    988          {
   \                     ProbeCom_ReqErr:
   \   00000000   0xB511             PUSH     {R0,R4,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x000C             MOVS     R4,R1
    989              CPU_SIZE_T  tx_len;
    990          
    991          
    992          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
    993              ProbeCom_ErrPktCtr++;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable16_10
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable16_10
   \   00000012   0x6008             STR      R0,[R1, #+0]
    994          #endif
    995          
    996              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_ERR);         /* Tx pkt fmt.                                          */
   \   00000014   0xF44F 0x4100      MOV      R1,#+32768
   \   00000018   0xA801             ADD      R0,SP,#+4
   \   0000001A   0x.... 0x....      BL       ProbeCom_StoINT16U
    997              ProbeCom_StoINT08U(&ptx_buf, comm_err);                     /* Target status.                                       */
   \   0000001E   0x0021             MOVS     R1,R4
   \   00000020   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000022   0xA801             ADD      R0,SP,#+4
   \   00000024   0x.... 0x....      BL       ProbeCom_StoINT08U
    998              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* Modifier.                                            */
   \   00000028   0x.... 0x....      BL       ProbeCom_PktModifier
   \   0000002C   0x0001             MOVS     R1,R0
   \   0000002E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000030   0xA801             ADD      R0,SP,#+4
   \   00000032   0x.... 0x....      BL       ProbeCom_StoINT08U
    999          
   1000              tx_len = (CPU_SIZE_T)PROBE_COM_SIZE_TX_HDR;
   \   00000036   0x2004             MOVS     R0,#+4
   1001              return (tx_len);                                            /* Rtn TX data segment size =  4 (= Tx hdr size).       */
   \   00000038   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1002          }
   1003          
   1004          
   1005          /*
   1006          *********************************************************************************************************
   1007          *                                         ProbeCom_ReqQuery()
   1008          *
   1009          * Description : Parse the FMT_QUERY command & formulate response.  This command asks the target
   1010          *               about its capabilities, which are returned in response.
   1011          *
   1012          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1013          *
   1014          *               ptx_buf         Pointer to the transmit buffer
   1015          *
   1016          *               rx_pkt_size     Size of the receive  packet
   1017          *
   1018          *               tx_buf_size     Size of the transmit buffer
   1019          *
   1020          * Return(s)   : The number of bytes written to the tx buffer.
   1021          *
   1022          * Caller(s)   : ProbeCom_ParseRxPkt().
   1023          *
   1024          * Note(s)     : (1) The RX format:
   1025          *
   1026          *                   (A) A 2-byte format, indicating the data segment format;
   1027          *                   (B) A 2-byte query , indicating the query type.
   1028          *
   1029          *                         +-------------------------+-------------------------+
   1030          *                         |          Format         |          Query          |
   1031          *                         +-------------------------+-------------------------+
   1032          *
   1033          *              (2) The TX format:
   1034          *
   1035          *                   (A) A 2-byte format, indicating the data segment format;
   1036          *                   (B) A 1-byte status, indicating the status after the request;
   1037          *                   (C) A 1-byte modifier;
   1038          *                   (E) A n-byte answer, the answer to the query.
   1039          *
   1040          *                         +-------------------------+------------+------------+
   1041          *                         |          Format         |   Status   |  Modifier  |
   1042          *                         +-------------------------+------------+------------+
   1043          *                         |                       Answer                      |
   1044          *                         |                         .                         |
   1045          *                         |                         .                         |
   1046          *                         |                         .                         |
   1047          *                         +---------------------------------------------------+
   1048          *
   1049          *********************************************************************************************************
   1050          */
   1051          

   \                                 In section .text, align 2, keep-with-next
   1052          static  CPU_SIZE_T  ProbeCom_ReqQuery (CPU_INT08U  *prx_buf,
   1053                                                 CPU_INT08U  *ptx_buf,
   1054                                                 CPU_SIZE_T   rx_pkt_size,
   1055                                                 CPU_SIZE_T   tx_buf_size)
   1056          {
   \                     ProbeCom_ReqQuery:
   \   00000000   0xB533             PUSH     {R0,R1,R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1057              CPU_INT16U  query;
   1058              CPU_INT32U  status;
   1059              CPU_SIZE_T  tx_len;
   1060              CPU_INT32U  version;
   1061          
   1062          
   1063              query  = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   1064              tx_len = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   1065          
   1066                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1067                                                                          /* Expected size =  2 (= Rx hdr size)                   */
   1068                                                                          /*               +  2 (= Query      ).                  */
   1069              if (rx_pkt_size != 4) {
   \   00000008   0x2A04             CMP      R2,#+4
   \   0000000A   0xD006             BEQ.N    ??ProbeCom_ReqQuery_0
   1070                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   \   0000000C   0x21FE             MOVS     R1,#+254
   \   0000000E   0x9804             LDR      R0,[SP, #+16]
   \   00000010   0x.... 0x....      BL       ProbeCom_ReqErr
   \   00000014   0x0005             MOVS     R5,R0
   1071                  return (tx_len);
   \   00000016   0x0028             MOVS     R0,R5
   \   00000018   0xE038             B.N      ??ProbeCom_ReqQuery_1
   1072              }
   1073          
   1074                                                                          /* ------------------- HANDLE QUERY ------------------- */
   1075              query = ProbeCom_GetINT16U(&prx_buf);                       /* Rd the query.                                        */
   \                     ??ProbeCom_ReqQuery_0:
   \   0000001A   0xA803             ADD      R0,SP,#+12
   \   0000001C   0x.... 0x....      BL       ProbeCom_GetINT16U
   \   00000020   0x0004             MOVS     R4,R0
   1076          
   1077              switch (query) {                                            /* Determine if query is supported.                     */
   \   00000022   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0xF240 0x1101      MOVW     R1,#+257
   \   0000002A   0x1A40             SUBS     R0,R0,R1
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xD909             BLS.N    ??ProbeCom_ReqQuery_2
   \   00000030   0xF44F 0x7180      MOV      R1,#+256
   \   00000034   0x1A40             SUBS     R0,R0,R1
   \   00000036   0x2801             CMP      R0,#+1
   \   00000038   0xD904             BLS.N    ??ProbeCom_ReqQuery_2
   \   0000003A   0xF44F 0x6160      MOV      R1,#+3584
   \   0000003E   0x1A40             SUBS     R0,R0,R1
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD825             BHI.N    ??ProbeCom_ReqQuery_3
   1078                  case PROBE_COM_QUERY_MAX_RX_SIZE:
   1079                  case PROBE_COM_QUERY_MAX_TX_SIZE:
   1080                  case PROBE_COM_QUERY_FMT_SUPPORT:
   1081                  case PROBE_COM_QUERY_ENDIANNESS_TEST:
   1082                  case PROBE_COM_QUERY_STATUS:
   1083                  case PROBE_COM_QUERY_VERSION:
   1084                       break;
   1085          
   1086                  default:
   1087                       tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_QUERY_NOT_SUPPORTED);
   1088                       return (tx_len);
   1089              }
   1090          
   1091                                                                          /* Sto tx pkt hdr :                                     */
   1092              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_QUERY);       /*  (a) TX pkt fmt.                                     */
   \                     ??ProbeCom_ReqQuery_2:
   \   00000044   0xF248 0x0101      MOVW     R1,#+32769
   \   00000048   0xA804             ADD      R0,SP,#+16
   \   0000004A   0x.... 0x....      BL       ProbeCom_StoINT16U
   1093              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /*  (b) Target status.                                  */
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0xA804             ADD      R0,SP,#+16
   \   00000052   0x.... 0x....      BL       ProbeCom_StoINT08U
   1094              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /*  (c) Modifier.                                       */
   \   00000056   0x.... 0x....      BL       ProbeCom_PktModifier
   \   0000005A   0x0001             MOVS     R1,R0
   \   0000005C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000005E   0xA804             ADD      R0,SP,#+16
   \   00000060   0x.... 0x....      BL       ProbeCom_StoINT08U
   1095          
   1096                                                                          /* Sto tx data segment data.                            */
   1097              switch (query) {
   \   00000064   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000066   0xF240 0x1001      MOVW     R0,#+257
   \   0000006A   0x1A24             SUBS     R4,R4,R0
   \   0000006C   0xD017             BEQ.N    ??ProbeCom_ReqQuery_4
   \   0000006E   0x1E64             SUBS     R4,R4,#+1
   \   00000070   0xD020             BEQ.N    ??ProbeCom_ReqQuery_5
   \   00000072   0x3CFF             SUBS     R4,R4,#+255
   \   00000074   0xD04D             BEQ.N    ??ProbeCom_ReqQuery_6
   \   00000076   0x1E64             SUBS     R4,R4,#+1
   \   00000078   0xD058             BEQ.N    ??ProbeCom_ReqQuery_7
   \   0000007A   0xF640 0x50FF      MOVW     R0,#+3583
   \   0000007E   0x1A24             SUBS     R4,R4,R0
   \   00000080   0xD023             BEQ.N    ??ProbeCom_ReqQuery_8
   \   00000082   0x1E64             SUBS     R4,R4,#+1
   \   00000084   0xD05C             BEQ.N    ??ProbeCom_ReqQuery_9
   1098                  case PROBE_COM_QUERY_MAX_RX_SIZE:
   1099                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_CFG_RX_MAX_SIZE);
   1100                       ProbeCom_StoINT16U(&ptx_buf, 0);
   1101                       tx_len  = 4;
   1102                       break;
   1103          
   1104          
   1105                  case PROBE_COM_QUERY_MAX_TX_SIZE:
   1106                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_CFG_TX_MAX_SIZE);
   1107                       ProbeCom_StoINT16U(&ptx_buf, 0);
   1108                       tx_len  = 4;
   1109                       break;
   1110          
   1111          
   1112                  case PROBE_COM_QUERY_FMT_SUPPORT:
   1113                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_QUERY);
   1114                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_RD);
   1115                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_RD_MULTI);
   1116                       tx_len  = 8;
   1117          #if (PROBE_COM_CFG_WR_REQ_EN == DEF_ENABLED)
   1118                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_WR);
   1119                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_WR_MULTI);
   1120                       tx_len += 4;
   1121          #endif
   1122          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
   1123                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_STR_IN);
   1124                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_STR_OUT);
   1125                       tx_len += 4;
   1126          #endif
   1127          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)
   1128                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_TERMINAL_EXEC);
   1129                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_TERMINAL_IN);
   1130                       ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_RX_TERMINAL_OUT);
   1131                       tx_len += 6;
   1132          #endif
   1133                       break;
   1134          
   1135          
   1136                  case PROBE_COM_QUERY_ENDIANNESS_TEST:
   1137                       ProbeCom_EndiannessTest = 0x12345678;
   1138                       Mem_Copy((void     *) ptx_buf,
   1139                                (void     *)&ProbeCom_EndiannessTest,
   1140                                (CPU_SIZE_T) 4);
   1141                       tx_len  = 4;
   1142                       break;
   1143          
   1144          
   1145                  case PROBE_COM_QUERY_STATUS:
   1146                       status = (CPU_INT32U)ProbeCom_PktModifier();
   1147                       Mem_Copy((void     *) ptx_buf,
   1148                                (void     *)&status,
   1149                                (CPU_SIZE_T) 4);
   1150                       tx_len = 4;
   1151                       break;
   1152          
   1153          
   1154                  case PROBE_COM_QUERY_VERSION:
   1155                       version = PROBE_COM_VERSION;
   1156                       Mem_Copy((void     *) ptx_buf,
   1157                                (void     *)&version,
   1158                                (CPU_SIZE_T) 4);
   1159                       tx_len  = 4;
   1160                       break;
   1161          
   1162          
   1163                  default:
   1164                       tx_len  = 0;
   \                     ??ProbeCom_ReqQuery_10:
   \   00000086   0x2500             MOVS     R5,#+0
   1165                       break;
   1166              }
   1167          
   1168                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1169              tx_len += PROBE_COM_SIZE_TX_HDR;
   \                     ??ProbeCom_ReqQuery_11:
   \   00000088   0x1D2D             ADDS     R5,R5,#+4
   1170              return (tx_len);                                            /* TX pkt size = nbytes (= Tx data size)                */
   \   0000008A   0x0028             MOVS     R0,R5
   \                     ??ProbeCom_ReqQuery_1:
   \   0000008C   0xB005             ADD      SP,SP,#+20
   \   0000008E   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??ProbeCom_ReqQuery_3:
   \   00000090   0x21FC             MOVS     R1,#+252
   \   00000092   0x9804             LDR      R0,[SP, #+16]
   \   00000094   0x.... 0x....      BL       ProbeCom_ReqErr
   \   00000098   0x0005             MOVS     R5,R0
   \   0000009A   0x0028             MOVS     R0,R5
   \   0000009C   0xE7F6             B.N      ??ProbeCom_ReqQuery_1
   \                     ??ProbeCom_ReqQuery_4:
   \   0000009E   0xF44F 0x7100      MOV      R1,#+512
   \   000000A2   0xA804             ADD      R0,SP,#+16
   \   000000A4   0x.... 0x....      BL       ProbeCom_StoINT16U
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0xA804             ADD      R0,SP,#+16
   \   000000AC   0x.... 0x....      BL       ProbeCom_StoINT16U
   \   000000B0   0x2504             MOVS     R5,#+4
   \   000000B2   0xE7E9             B.N      ??ProbeCom_ReqQuery_11
   \                     ??ProbeCom_ReqQuery_5:
   \   000000B4   0xF44F 0x7100      MOV      R1,#+512
   \   000000B8   0xA804             ADD      R0,SP,#+16
   \   000000BA   0x.... 0x....      BL       ProbeCom_StoINT16U
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0xA804             ADD      R0,SP,#+16
   \   000000C2   0x.... 0x....      BL       ProbeCom_StoINT16U
   \   000000C6   0x2504             MOVS     R5,#+4
   \   000000C8   0xE7DE             B.N      ??ProbeCom_ReqQuery_11
   \                     ??ProbeCom_ReqQuery_8:
   \   000000CA   0x2101             MOVS     R1,#+1
   \   000000CC   0xA804             ADD      R0,SP,#+16
   \   000000CE   0x.... 0x....      BL       ProbeCom_StoINT16U
   \   000000D2   0x2102             MOVS     R1,#+2
   \   000000D4   0xA804             ADD      R0,SP,#+16
   \   000000D6   0x.... 0x....      BL       ProbeCom_StoINT16U
   \   000000DA   0x2107             MOVS     R1,#+7
   \   000000DC   0xA804             ADD      R0,SP,#+16
   \   000000DE   0x.... 0x....      BL       ProbeCom_StoINT16U
   \   000000E2   0x2508             MOVS     R5,#+8
   \   000000E4   0x2103             MOVS     R1,#+3
   \   000000E6   0xA804             ADD      R0,SP,#+16
   \   000000E8   0x.... 0x....      BL       ProbeCom_StoINT16U
   \   000000EC   0x2108             MOVS     R1,#+8
   \   000000EE   0xA804             ADD      R0,SP,#+16
   \   000000F0   0x.... 0x....      BL       ProbeCom_StoINT16U
   \   000000F4   0x1D2D             ADDS     R5,R5,#+4
   \   000000F6   0x210B             MOVS     R1,#+11
   \   000000F8   0xA804             ADD      R0,SP,#+16
   \   000000FA   0x.... 0x....      BL       ProbeCom_StoINT16U
   \   000000FE   0x210D             MOVS     R1,#+13
   \   00000100   0xA804             ADD      R0,SP,#+16
   \   00000102   0x.... 0x....      BL       ProbeCom_StoINT16U
   \   00000106   0x210C             MOVS     R1,#+12
   \   00000108   0xA804             ADD      R0,SP,#+16
   \   0000010A   0x.... 0x....      BL       ProbeCom_StoINT16U
   \   0000010E   0x1DAD             ADDS     R5,R5,#+6
   \   00000110   0xE7BA             B.N      ??ProbeCom_ReqQuery_11
   \                     ??ProbeCom_ReqQuery_6:
   \   00000112   0x.... 0x....      LDR.W    R0,??DataTable16_13
   \   00000116   0x.... 0x....      LDR.W    R1,??DataTable16_14  ;; 0x12345678
   \   0000011A   0x6001             STR      R1,[R0, #+0]
   \   0000011C   0x2204             MOVS     R2,#+4
   \   0000011E   0x.... 0x....      LDR.W    R1,??DataTable16_13
   \   00000122   0x9804             LDR      R0,[SP, #+16]
   \   00000124   0x.... 0x....      BL       Mem_Copy
   \   00000128   0x2504             MOVS     R5,#+4
   \   0000012A   0xE7AD             B.N      ??ProbeCom_ReqQuery_11
   \                     ??ProbeCom_ReqQuery_7:
   \   0000012C   0x.... 0x....      BL       ProbeCom_PktModifier
   \   00000130   0x9001             STR      R0,[SP, #+4]
   \   00000132   0x2204             MOVS     R2,#+4
   \   00000134   0xA901             ADD      R1,SP,#+4
   \   00000136   0x9804             LDR      R0,[SP, #+16]
   \   00000138   0x.... 0x....      BL       Mem_Copy
   \   0000013C   0x2504             MOVS     R5,#+4
   \   0000013E   0xE7A3             B.N      ??ProbeCom_ReqQuery_11
   \                     ??ProbeCom_ReqQuery_9:
   \   00000140   0x20DC             MOVS     R0,#+220
   \   00000142   0x9000             STR      R0,[SP, #+0]
   \   00000144   0x2204             MOVS     R2,#+4
   \   00000146   0xA900             ADD      R1,SP,#+0
   \   00000148   0x9804             LDR      R0,[SP, #+16]
   \   0000014A   0x.... 0x....      BL       Mem_Copy
   \   0000014E   0x2504             MOVS     R5,#+4
   \   00000150   0xE79A             B.N      ??ProbeCom_ReqQuery_11
   1171                                                                          /*             + 4      (= Tx hdr  size).               */
   1172          }
   1173          
   1174          
   1175          /*
   1176          *********************************************************************************************************
   1177          *                                          ProbeCom_ReqRd()
   1178          *
   1179          * Description : Parse the FMT_RD request & formulate response.  This command causes the target to send
   1180          *               data read from its memory for a certain {memory address, data length} pair (which is
   1181          *               given in the request).
   1182          *
   1183          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1184          *
   1185          *               ptx_buf         Pointer to the transmit buffer
   1186          *
   1187          *               rx_pkt_size     Size of the receive  packet
   1188          *
   1189          *               tx_buf_size     Size of the transmit buffer
   1190          *
   1191          * Return(s)   : The number of bytes written to the tx buffer.
   1192          *
   1193          * Caller(s)   : ProbeCom_ParseRxPkt().
   1194          *
   1195          * Note(s)     : (1) The RX format:
   1196          *
   1197          *                   (A) A 2-byte format , indicating the data segment format;
   1198          *                   (B) A 2-byte length , indicating the number of bytes to read;
   1199          *                   (C) A 4-byte address, the starting address of the data to read.
   1200          *
   1201          *                         +-------------------------+-------------------------+
   1202          *                         |          Format         |     Number of bytes     |
   1203          *                         +-------------------------+-------------------------+
   1204          *                         |                      Address                      |
   1205          *                         +-------------------------+-------------------------+
   1206          *
   1207          *               (2) The TX format:
   1208          *
   1209          *                   (A) A 2-byte format, indicating the data segment format;
   1210          *                   (B) A 1-byte status, indicating the status after the request;
   1211          *                   (C) A 1-byte modifier;
   1212          *                   (D) The memory data.
   1213          *
   1214          *                         +-------------------------+------------+------------+
   1215          *                         |          Format         |   Status   |  Modifier  |
   1216          *                         +-------------------------+------------+------------+
   1217          *                         |                        Data                       |
   1218          *                         |                         .                         |
   1219          *                         |                         .                         |
   1220          *                         |                         .                         |
   1221          *                         +---------------------------------------------------+
   1222          *
   1223          *********************************************************************************************************
   1224          */
   1225          

   \                                 In section .text, align 2, keep-with-next
   1226          static  CPU_SIZE_T  ProbeCom_ReqRd (CPU_INT08U  *prx_buf,
   1227                                              CPU_INT08U  *ptx_buf,
   1228                                              CPU_SIZE_T   rx_pkt_size,
   1229                                              CPU_SIZE_T   tx_buf_size)
   1230          {
   \                     ProbeCom_ReqRd:
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x001E             MOVS     R6,R3
   1231              CPU_ADDR    sym_addr;
   1232              CPU_SIZE_T  sym_size;
   1233              CPU_SIZE_T  tx_len;
   1234          
   1235          
   1236                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1237                                                                          /* Expected size = 2 (= Rx hdr size )                   */
   1238                                                                          /*               + 2 (= Sym size    )                   */
   1239                                                                          /*               + 4 (= Sym addr    ).                  */
   1240              if (rx_pkt_size != 8) {
   \   00000004   0x2A08             CMP      R2,#+8
   \   00000006   0xD004             BEQ.N    ??ProbeCom_ReqRd_0
   1241                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   \   00000008   0x21FE             MOVS     R1,#+254
   \   0000000A   0x9801             LDR      R0,[SP, #+4]
   \   0000000C   0x.... 0x....      BL       ProbeCom_ReqErr
   1242                  return (tx_len);
   \   00000010   0xE033             B.N      ??ProbeCom_ReqRd_1
   1243              }
   1244          
   1245          
   1246                                                                          /* -------------------- HANDLE RD --------------------- */
   1247              sym_size = ProbeCom_GetINT16U(&prx_buf);                    /* Get nbr of bytes to rd.                              */
   \                     ??ProbeCom_ReqRd_0:
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       ProbeCom_GetINT16U
   \   00000018   0x0005             MOVS     R5,R0
   1248          
   1249                                                                          /* Get rd addr.                                         */
   1250          #if ((!defined(CPU_CFG_ADDR_SIZE)) || \
   1251               ((defined(CPU_CFG_ADDR_SIZE)) && \
   1252                        (CPU_CFG_ADDR_SIZE   != CPU_WORD_SIZE_16)))
   1253              sym_addr = (CPU_ADDR)ProbeCom_GetINT32U(&prx_buf);
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0x.... 0x....      BL       ProbeCom_GetINT32U
   \   00000020   0x0004             MOVS     R4,R0
   1254          #else
   1255              sym_addr = (CPU_ADDR)ProbeCom_GetINT16U(&prx_buf);
   1256          #endif
   1257          
   1258              if (sym_size + PROBE_COM_SIZE_TX_HDR > tx_buf_size) {       /* If tx pkt will NOT fit in buf, rtn err.              */
   \   00000022   0x1D28             ADDS     R0,R5,#+4
   \   00000024   0x4286             CMP      R6,R0
   \   00000026   0xD204             BCS.N    ??ProbeCom_ReqRd_2
   1259                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_TX_PKT_TOO_LARGE);
   \   00000028   0x21FD             MOVS     R1,#+253
   \   0000002A   0x9801             LDR      R0,[SP, #+4]
   \   0000002C   0x.... 0x....      BL       ProbeCom_ReqErr
   1260                  return (tx_len);
   \   00000030   0xE023             B.N      ??ProbeCom_ReqRd_1
   1261              }
   1262          
   1263          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1264              ProbeCom_TxSymCtr++;                                        /* Inc tx sym ctr.                                      */
   \                     ??ProbeCom_ReqRd_2:
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
   \   0000003A   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   1265              ProbeCom_TxSymByteCtr += sym_size;
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable16_9
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x1828             ADDS     R0,R5,R0
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable16_9
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1266          #endif
   1267          
   1268                                                                          /* Store tx pkt hdr :                                   */
   1269              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_RD);          /*  (a) Tx pkt fmt.                                     */
   \   0000004E   0xF248 0x0102      MOVW     R1,#+32770
   \   00000052   0xA801             ADD      R0,SP,#+4
   \   00000054   0x.... 0x....      BL       ProbeCom_StoINT16U
   1270              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /*  (b) Target status.                                  */
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0xA801             ADD      R0,SP,#+4
   \   0000005C   0x.... 0x....      BL       ProbeCom_StoINT08U
   1271              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /*  (c) Modifier.                                       */
   \   00000060   0x.... 0x....      BL       ProbeCom_PktModifier
   \   00000064   0x0001             MOVS     R1,R0
   \   00000066   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000068   0xA801             ADD      R0,SP,#+4
   \   0000006A   0x.... 0x....      BL       ProbeCom_StoINT08U
   1272          
   1273              Mem_Copy((void     *)ptx_buf,                               /* Save tx data segment data.                           */
   1274                       (void     *)sym_addr,
   1275                       (CPU_SIZE_T)sym_size);
   \   0000006E   0x002A             MOVS     R2,R5
   \   00000070   0x0021             MOVS     R1,R4
   \   00000072   0x9801             LDR      R0,[SP, #+4]
   \   00000074   0x.... 0x....      BL       Mem_Copy
   1276          
   1277                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1278              tx_len = sym_size + PROBE_COM_SIZE_TX_HDR;
   \   00000078   0x1D28             ADDS     R0,R5,#+4
   1279              return (tx_len);                                            /* Tx pkt size = nbytes (= Tx data   size)              */
   \                     ??ProbeCom_ReqRd_1:
   \   0000007A   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1280                                                                          /*             + 4      (= Tx header size).             */
   1281          }
   1282          
   1283          
   1284          /*
   1285          *********************************************************************************************************
   1286          *                                        ProbeCom_ReqRdMulti()
   1287          *
   1288          * Description : Parse the FMT_RD_MULTI request & formulate respnse.  This command causes the target to
   1289          *               send data read from its memory for a certain set of {memory address, data length} pairs
   1290          *               (which are given in the request).
   1291          *
   1292          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1293          *
   1294          *               ptx_buf         Pointer to the transmit buffer
   1295          *
   1296          *               rx_pkt_size     Size of the receive  packet
   1297          *
   1298          *               tx_buf_size     Size of the transmit buffer
   1299          *
   1300          * Return(s)   : The number of bytes written to the tx buffer.
   1301          *
   1302          * Caller(s)   : ProbeCom_ParseRxPkt().
   1303          *
   1304          * Note(s)     : (1) The RX format:
   1305          *
   1306          *                   (A) A 2-byte format,          indicating the data segment format;
   1307          *                   (B) A 5-byte item descriptor, for each item in the list, consisting of:
   1308          *
   1309          *                       (1) A 4-byte address, the starting address of the data to read;
   1310          *                       (2) A 1-byte length,  indicating the number of bytes to read.
   1311          *
   1312          *                         +-------------------------+------------+------------+
   1313          *                         |          Format         | Num. bytes |         Addr       ---
   1314          *                         +-------------------------+------------+------------+        |    Item 1
   1315          *                         ress                                   | Num. bytes |       ---
   1316          *                         +--------------------------------------+------------+        |
   1317          *                         |                      Address                      |        |    Item 2
   1318          *                         +------------+--------------------------------------+       ---
   1319          *                         | Num. bytes |                                   Addr        |    Item 3
   1320          *                         +------------+--------------------------------------+        .
   1321          *                         |                         .                         |        .
   1322          *                         |                         .                         |        .
   1323          *                         |                         .                         |        .
   1324          *                         |                         .                         |        .
   1325          *                         +--------------------------------------+------------+        .
   1326          *                         ress                                   | Num. bytes |       ---
   1327          *                         ---------------------------------------+------------+        |   Item n
   1328          *                         |                      Address                      |        |
   1329          *                         +---------------------------------------------------+       ---
   1330          *
   1331          *               (2) The TX format:
   1332          *
   1333          *                   (A) A 2-byte format, indicating the data segment format;
   1334          *                   (B) A 1-byte status, indicating the status after the request;
   1335          *                   (C) A 1-byte modifier;
   1336          *                   (D) For each item, the following is sent:
   1337          *
   1338          *                       (1) The memory data.
   1339          *
   1340          *                         +-------------------------+------------+------------+
   1341          *                         |          Format         |   Status   |  Modifier  |
   1342          *                         +-------------------------+------------+------------+       ---
   1343          *                         |                        Data                       |        |    Item 1
   1344          *                         |                         .                         |        |
   1345          *                         |                         .                         |        |
   1346          *                         |                         .                         |        |
   1347          *                         +---------------------------------------------------+       ---
   1348          *                         |                         .                         |        .
   1349          *                         |                         .                         |        .
   1350          *                         |                         .                         |        .
   1351          *                         |                         .                         |        .
   1352          *                         |                         .                         |        .
   1353          *                         +---------------------------------------------------+       ---
   1354          *                         |                        Data                       |        |    Item n
   1355          *                         |                         .                         |        |
   1356          *                         |                         .                         |        |
   1357          *                         |                         .                         |        |
   1358          *                         +---------------------------------------------------+       ---
   1359          *
   1360          *********************************************************************************************************
   1361          */
   1362          

   \                                 In section .text, align 2, keep-with-next
   1363          static  CPU_SIZE_T  ProbeCom_ReqRdMulti (CPU_INT08U  *prx_buf,
   1364                                                   CPU_INT08U  *ptx_buf,
   1365                                                   CPU_SIZE_T   rx_pkt_size,
   1366                                                   CPU_SIZE_T   tx_buf_size)
   1367          {
   \                     ProbeCom_ReqRdMulti:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000E             MOVS     R6,R1
   \   0000000A   0x0015             MOVS     R5,R2
   1368              CPU_SIZE_T   rx_pkt_ix;
   1369          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1370              CPU_INT32U   sym_byte_ctr;
   1371              CPU_INT32U   sym_ctr;
   1372          #endif
   1373              CPU_ADDR     sym_addr;
   1374              CPU_SIZE_T   sym_size;
   1375              CPU_SIZE_T   tx_len;
   1376              CPU_INT08U  *ptx_buf_start;
   1377          
   1378          
   1379                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1380                                                                          /* Expected size >= 2 (= Rx hdr size)                   */
   1381                                                                          /*                + 5 (= 1 item desc).                  */
   1382              if (rx_pkt_size  < 7) {
   \   0000000C   0x2D07             CMP      R5,#+7
   \   0000000E   0xD206             BCS.N    ??ProbeCom_ReqRdMulti_0
   1383                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   \   00000010   0x21FE             MOVS     R1,#+254
   \   00000012   0x0030             MOVS     R0,R6
   \   00000014   0x.... 0x....      BL       ProbeCom_ReqErr
   \   00000018   0x0007             MOVS     R7,R0
   1384                  return (tx_len);
   \   0000001A   0x0038             MOVS     R0,R7
   \   0000001C   0xE048             B.N      ??ProbeCom_ReqRdMulti_1
   1385              }
   1386          
   1387                                                                          /* -------------------- HANDLE RD --------------------- */
   1388              ptx_buf_start = ptx_buf;                                    /* Save ptr to tx buf in case pkt is too long for buf.  */
   \                     ??ProbeCom_ReqRdMulti_0:
   \   0000001E   0x9600             STR      R6,[SP, #+0]
   1389              tx_len        = PROBE_COM_SIZE_TX_HDR;                      /* Init tx pkt len = 4 = size of hdr.                   */
   \   00000020   0x2704             MOVS     R7,#+4
   1390          
   1391                                                                          /* Store TX pkt hdr :                                   */
   1392              ptx_buf[0]    = PROBE_COM_FMT_TX_RD_MULTI_LO;               /* (a) TX pkt fmt.                                      */
   \   00000022   0x2007             MOVS     R0,#+7
   \   00000024   0x7030             STRB     R0,[R6, #+0]
   1393              ptx_buf[1]    = PROBE_COM_FMT_TX_RD_MULTI_HI;
   \   00000026   0x2080             MOVS     R0,#+128
   \   00000028   0x7070             STRB     R0,[R6, #+1]
   1394              ptx_buf[2]    = PROBE_COM_STATUS_OK;                        /* (b) Target status.                                   */
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x70B0             STRB     R0,[R6, #+2]
   1395              ptx_buf[3]    = ProbeCom_PktModifier();                     /* (c) Modifier.                                        */
   \   0000002E   0x.... 0x....      BL       ProbeCom_PktModifier
   \   00000032   0x70F0             STRB     R0,[R6, #+3]
   1396              ptx_buf      += PROBE_COM_SIZE_TX_HDR;
   \   00000034   0x1D36             ADDS     R6,R6,#+4
   1397          
   1398              rx_pkt_ix     = 7;                                          /* Tx pkt ix after 1st item = 2 (= Rx hdr size)         */
   \   00000036   0xF05F 0x0807      MOVS     R8,#+7
   1399                                                                          /*                          + 5 (= 1 item desc).        */
   1400          
   1401          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1402              sym_ctr      = 0;
   \   0000003A   0xF05F 0x0900      MOVS     R9,#+0
   1403              sym_byte_ctr = 0;
   \   0000003E   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000042   0xE009             B.N      ??ProbeCom_ReqRdMulti_2
   1404          #endif
   1405                                                                          /* Sto data for each item.                              */
   1406              while (rx_pkt_ix <= rx_pkt_size) {
   1407                  sym_size   =  prx_buf[0];                               /* (a) Get nbr of bytes to rd.                          */
   1408          
   1409                                                                          /* (b) Get rd addr.                                     */
   1410          #if ((!defined(CPU_CFG_ADDR_SIZE)) || \
   1411               ((defined(CPU_CFG_ADDR_SIZE)) && \
   1412                        (CPU_CFG_ADDR_SIZE   != CPU_WORD_SIZE_16)))
   1413                  sym_addr   = (prx_buf[4] << 8) + prx_buf[3];
   1414                  sym_addr   = (sym_addr   << 8) + prx_buf[2];
   1415                  sym_addr   = (sym_addr   << 8) + prx_buf[1];
   1416          #else
   1417                  sym_addr   = (prx_buf[2] << 8) + prx_buf[1];
   1418          #endif
   1419          
   1420                  prx_buf   += 5;
   1421                  rx_pkt_ix += 5;
   1422          
   1423                  tx_len    += sym_size;                                  /* (c) Add nbr of bytes to pkt len.                     */
   1424          
   1425                  if (tx_len > tx_buf_size) {                             /* (d) Will pkt be too long for TX buf? ...             */
   1426                      ptx_buf = ptx_buf_start;                            /*     ... rtn err.                                     */
   1427                      tx_len  = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_TX_PKT_TOO_LARGE);
   1428                      return (tx_len);
   1429                  }
   1430          
   1431          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1432                  sym_ctr++;                                              /* (e) Inc local sym ctr.                               */
   \                     ??ProbeCom_ReqRdMulti_3:
   \   00000044   0xF119 0x0901      ADDS     R9,R9,#+1
   1433                  sym_byte_ctr += sym_size;
   \   00000048   0xEB1B 0x0A0A      ADDS     R10,R11,R10
   1434          #endif
   1435                                                                          /* (f) Otherwise, save TX data.                         */
   1436                  Mem_Copy((void     *)ptx_buf,
   1437                           (void     *)sym_addr,
   1438                           (CPU_SIZE_T)sym_size);
   \   0000004C   0x465A             MOV      R2,R11
   \   0000004E   0x0030             MOVS     R0,R6
   \   00000050   0x.... 0x....      BL       Mem_Copy
   1439          
   1440                  ptx_buf += sym_size;
   \   00000054   0xEB1B 0x0606      ADDS     R6,R11,R6
   \                     ??ProbeCom_ReqRdMulti_2:
   \   00000058   0x4545             CMP      R5,R8
   \   0000005A   0xD31C             BCC.N    ??ProbeCom_ReqRdMulti_4
   \   0000005C   0xF894 0xB000      LDRB     R11,[R4, #+0]
   \   00000060   0x7920             LDRB     R0,[R4, #+4]
   \   00000062   0x78E1             LDRB     R1,[R4, #+3]
   \   00000064   0xEB11 0x2100      ADDS     R1,R1,R0, LSL #+8
   \   00000068   0x78A0             LDRB     R0,[R4, #+2]
   \   0000006A   0xEB10 0x2101      ADDS     R1,R0,R1, LSL #+8
   \   0000006E   0x7860             LDRB     R0,[R4, #+1]
   \   00000070   0xEB10 0x2101      ADDS     R1,R0,R1, LSL #+8
   \   00000074   0xF204 0x0405      ADDW     R4,R4,#+5
   \   00000078   0xF118 0x0805      ADDS     R8,R8,#+5
   \   0000007C   0xEB1B 0x0707      ADDS     R7,R11,R7
   \   00000080   0x9802             LDR      R0,[SP, #+8]
   \   00000082   0x42B8             CMP      R0,R7
   \   00000084   0xD2DE             BCS.N    ??ProbeCom_ReqRdMulti_3
   \   00000086   0x9E00             LDR      R6,[SP, #+0]
   \   00000088   0x21FD             MOVS     R1,#+253
   \   0000008A   0x0030             MOVS     R0,R6
   \   0000008C   0x.... 0x....      BL       ProbeCom_ReqErr
   \   00000090   0x0007             MOVS     R7,R0
   \   00000092   0x0038             MOVS     R0,R7
   \   00000094   0xE00C             B.N      ??ProbeCom_ReqRdMulti_1
   1441              }
   1442          
   1443          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1444              ProbeCom_TxSymCtr     += sym_ctr;                           /* Inc global sym ctr.                                  */
   \                     ??ProbeCom_ReqRdMulti_4:
   \   00000096   0x....             LDR.N    R0,??DataTable16_8
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0xEB19 0x0000      ADDS     R0,R9,R0
   \   0000009E   0x....             LDR.N    R1,??DataTable16_8
   \   000000A0   0x6008             STR      R0,[R1, #+0]
   1445              ProbeCom_TxSymByteCtr += sym_byte_ctr;
   \   000000A2   0x....             LDR.N    R0,??DataTable16_9
   \   000000A4   0x6800             LDR      R0,[R0, #+0]
   \   000000A6   0xEB1A 0x0000      ADDS     R0,R10,R0
   \   000000AA   0x....             LDR.N    R1,??DataTable16_9
   \   000000AC   0x6008             STR      R0,[R1, #+0]
   1446          #endif
   1447          
   1448                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1449              return (tx_len);
   \   000000AE   0x0038             MOVS     R0,R7
   \                     ??ProbeCom_ReqRdMulti_1:
   \   000000B0   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   1450          }
   1451          
   1452          
   1453          /*
   1454          *********************************************************************************************************
   1455          *                                          ProbeCom_ReqWr()
   1456          *
   1457          * Description : Parse the FMT_WR request & formulate response.  This command causes the target to write
   1458          *               into its memory data from a certain {memory address, data length, data} triplet which is
   1459          *               given in the request.
   1460          *
   1461          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1462          *
   1463          *               ptx_buf         Pointer to the transmit buffer
   1464          *
   1465          *               rx_pkt_size     Size of the receive  packet
   1466          *
   1467          *               tx_buf_size     Size of the transmit buffer
   1468          *
   1469          * Return(s)   : The number of bytes written to the tx buffer.
   1470          *
   1471          * Caller(s)   : ProbeCom_ParseRxPkt().
   1472          *
   1473          * Note(s)     : (1) The RX format:
   1474          *
   1475          *                   (A) A 2-byte format,  indicating the data segment format;
   1476          *                   (B) A 2-byte length,  indicating the number of bytes to write;
   1477          *                   (C) A 4-byte address, the starting address at which the data should be written;
   1478          *                   (D) The memory data.
   1479          *
   1480          *                         +-------------------------+-------------------------+
   1481          *                         |          Format         |      Number of bytes    |
   1482          *                         +-------------------------+-------------------------+
   1483          *                         |                      Address                      |
   1484          *                         +---------------------------------------------------+
   1485          *                         |                        Data                       |
   1486          *                         |                         .                         |
   1487          *                         |                         .                         |
   1488          *                         |                         .                         |
   1489          *                         +---------------------------------------------------+
   1490          *
   1491          *               (2) The TX format:
   1492          *
   1493          *                   (A) A 2-byte format, indicating the data segment format;
   1494          *                   (B) A 1-byte status, indicating the status after the request;
   1495          *                   (C) A 1-byte modifier.
   1496          *
   1497          *                         +-------------------------+------------+------------+
   1498          *                         |          Format         |   Status   |  Modifier  |
   1499          *                         +-------------------------+------------+------------+
   1500          *
   1501          *********************************************************************************************************
   1502          */
   1503          
   1504          #if (PROBE_COM_CFG_WR_REQ_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1505          static  CPU_SIZE_T  ProbeCom_ReqWr (CPU_INT08U  *prx_buf,
   1506                                              CPU_INT08U  *ptx_buf,
   1507                                              CPU_SIZE_T   rx_pkt_size,
   1508                                              CPU_SIZE_T   tx_buf_size)
   1509          {
   \                     ProbeCom_ReqWr:
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x0015             MOVS     R5,R2
   1510          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
   1511              CPU_SR      cpu_sr;
   1512          #endif
   1513              CPU_SIZE_T  sym_size;
   1514              CPU_ADDR    sym_addr;
   1515              CPU_SIZE_T  tx_len;
   1516          
   1517          
   1518                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1519                                                                          /* Expected size >= 2      (= Rx hdr size)              */
   1520                                                                          /*                + 2      (= Sym size   )              */
   1521                                                                          /*                + 4      (= Sym addr   )              */
   1522                                                                          /*                + nbytes (= Data       ).             */
   1523              if (rx_pkt_size < 8) {
   \   00000004   0x2D08             CMP      R5,#+8
   \   00000006   0xD204             BCS.N    ??ProbeCom_ReqWr_0
   1524                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   \   00000008   0x21FE             MOVS     R1,#+254
   \   0000000A   0x9801             LDR      R0,[SP, #+4]
   \   0000000C   0x.... 0x....      BL       ProbeCom_ReqErr
   1525                  return (tx_len);
   \   00000010   0xE036             B.N      ??ProbeCom_ReqWr_1
   1526              }
   1527          
   1528          
   1529          
   1530                                                                          /* -------------------- HANDLE WR --------------------- */
   1531              sym_size = ProbeCom_GetINT16U(&prx_buf);                    /* Get nbr of bytes to wr.                              */
   \                     ??ProbeCom_ReqWr_0:
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       ProbeCom_GetINT16U
   \   00000018   0x0004             MOVS     R4,R0
   1532          
   1533                                                                          /* Get wr addr.                                         */
   1534          #if ((!defined(CPU_CFG_ADDR_SIZE)) || \
   1535               ((defined(CPU_CFG_ADDR_SIZE)) && \
   1536                        (CPU_CFG_ADDR_SIZE   != CPU_WORD_SIZE_16)))
   1537              sym_addr = (CPU_ADDR)ProbeCom_GetINT32U(&prx_buf);
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0x.... 0x....      BL       ProbeCom_GetINT32U
   \   00000020   0x0006             MOVS     R6,R0
   1538          #else
   1539              sym_addr = (CPU_ADDR)ProbeCom_GetINT16U(&prx_buf);
   1540              prx_buf += 2;
   1541          #endif
   1542          
   1543              if (rx_pkt_size != (8 + sym_size)) {                        /* If rx data segment is NOT expected size ... rtn err. */
   \   00000022   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xD004             BEQ.N    ??ProbeCom_ReqWr_2
   1544                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   \   0000002A   0x21FE             MOVS     R1,#+254
   \   0000002C   0x9801             LDR      R0,[SP, #+4]
   \   0000002E   0x.... 0x....      BL       ProbeCom_ReqErr
   1545                  return (tx_len);
   \   00000032   0xE025             B.N      ??ProbeCom_ReqWr_1
   1546              }
   1547          
   1548                                                                          /* Copy data into mem.                                  */
   1549              CPU_CRITICAL_ENTER();
   \                     ??ProbeCom_ReqWr_2:
   \   00000034   0x.... 0x....      BL       CPU_SR_Save
   \   00000038   0x0005             MOVS     R5,R0
   1550              Mem_Copy((void     *)sym_addr,
   1551                       (void     *)prx_buf,
   1552                       (CPU_SIZE_T)sym_size);
   \   0000003A   0x0022             MOVS     R2,R4
   \   0000003C   0x9900             LDR      R1,[SP, #+0]
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0x.... 0x....      BL       Mem_Copy
   1553              CPU_CRITICAL_EXIT();
   \   00000044   0x0028             MOVS     R0,R5
   \   00000046   0x.... 0x....      BL       CPU_SR_Restore
   1554          
   1555          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1556              ProbeCom_RxSymCtr++;                                        /* Inc global sym ctr.                                  */
   \   0000004A   0x....             LDR.N    R0,??DataTable16_11
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x1C40             ADDS     R0,R0,#+1
   \   00000050   0x....             LDR.N    R1,??DataTable16_11
   \   00000052   0x6008             STR      R0,[R1, #+0]
   1557              ProbeCom_RxSymByteCtr += sym_size;
   \   00000054   0x....             LDR.N    R0,??DataTable16_12
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x1820             ADDS     R0,R4,R0
   \   0000005A   0x....             LDR.N    R1,??DataTable16_12
   \   0000005C   0x6008             STR      R0,[R1, #+0]
   1558          #endif
   1559          
   1560                                                                          /* Store TX pkt hdr :                                   */
   1561              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_WR);          /* (a) TX pkt fmt.                                      */
   \   0000005E   0xF248 0x0103      MOVW     R1,#+32771
   \   00000062   0xA801             ADD      R0,SP,#+4
   \   00000064   0x.... 0x....      BL       ProbeCom_StoINT16U
   1562              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   \   00000068   0x2101             MOVS     R1,#+1
   \   0000006A   0xA801             ADD      R0,SP,#+4
   \   0000006C   0x.... 0x....      BL       ProbeCom_StoINT08U
   1563              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* (c) Modifier.                                        */
   \   00000070   0x.... 0x....      BL       ProbeCom_PktModifier
   \   00000074   0x0001             MOVS     R1,R0
   \   00000076   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000078   0xA801             ADD      R0,SP,#+4
   \   0000007A   0x.... 0x....      BL       ProbeCom_StoINT08U
   1564          
   1565          
   1566          
   1567                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1568              tx_len = (CPU_SIZE_T)PROBE_COM_SIZE_TX_HDR;                 /* Tx pkt size = 4 (= Tx hdr size).                     */
   \   0000007E   0x2004             MOVS     R0,#+4
   1569              return (tx_len);
   \                     ??ProbeCom_ReqWr_1:
   \   00000080   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1570          }
   1571          #endif
   1572          
   1573          
   1574          /*
   1575          *********************************************************************************************************
   1576          *                                        ProbeCom_ReqWrMulti()
   1577          *
   1578          * Description : Parse the FMT_WR_MULTI request & formulate response.  This command causes the target to
   1579          *               write certain data into its memroy, for a certain number of {memory address, data length,
   1580          *               data} triplets (which are given in the request).
   1581          *
   1582          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1583          *
   1584          *               ptx_buf         Pointer to the transmit buffer
   1585          *
   1586          *               rx_pkt_size     Size of the receive  packet
   1587          *
   1588          *               tx_buf_size     Size of the transmit buffer
   1589          *
   1590          * Return(s)   : The number of bytes written to the tx buffer.
   1591          *
   1592          * Caller(s)   : ProbeCom_ParseRxPkt().
   1593          *
   1594          * Note(s)     : (1) The RX format:
   1595          *
   1596          *                   (A) A 2-byte format,  indicating the data segment format;
   1597          *                   (B) A n-byte item descriptor, for each item in the list, consiting of the following:
   1598          *
   1599          *                       (1) A 1-byte length,  indicating the number of bytes to write;
   1600          *                       (2) A 4-byte address, the starting address at which the data should be written;
   1601          *                       (3) The memory data.
   1602          *
   1603          *                         +-------------------------+------------+------------+
   1604          *                         |          Format         | Num. bytes |         Addr       ---
   1605          *                         +-------------------------+------------+------------+        |
   1606          *                         ress                                   |            |        |
   1607          *                         +--------------------------------------+            |        |    Item 1
   1608          *                         |                       Data                        |        |
   1609          *                         |                         .                         |        |
   1610          *                         |                         .                         |        |
   1611          *                         +------------+--------------------------------------+       ---
   1612          *                         | Num. bytes |                                   Addr        |    Item 2
   1613          *                         +------------+--------------------------------------+        .
   1614          *                         |                         .                         |        .
   1615          *                         |                         .                         |        .
   1616          *                         |                         .            +------------+        .
   1617          *                         |                         .            | Num. bytes |       ---
   1618          *                         ---------------------------------------+------------+        |
   1619          *                         |                      Address                      |        |
   1620          *                         +---------------------------------------------------+        |    Item n
   1621          *                         |                       Data                        |        |
   1622          *                         |                         .                         |        |
   1623          *                         |                         .                         |        |
   1624          *                         +------------+--------------------------------------+       ---
   1625          *
   1626          *               (2) The TX format:
   1627          *
   1628          *                   (A) A 2-byte format, indicating the data segment format;
   1629          *                   (B) A 1-byte status, indicating the status after the request;
   1630          *                   (C) A 1-byte modifier.
   1631          *
   1632          *                         +-------------------------+------------+------------+
   1633          *                         |          Format         |   Status   |  Modifier  |
   1634          *                         +-------------------------+------------+------------+
   1635          *
   1636          *********************************************************************************************************
   1637          */
   1638          
   1639          #if (PROBE_COM_CFG_WR_REQ_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1640          static  CPU_SIZE_T  ProbeCom_ReqWrMulti (CPU_INT08U  *prx_buf,
   1641                                                   CPU_INT08U  *ptx_buf,
   1642                                                   CPU_SIZE_T   rx_pkt_size,
   1643                                                   CPU_SIZE_T   tx_buf_size)
   1644          {
   \                     ProbeCom_ReqWrMulti:
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x0014             MOVS     R4,R2
   1645          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
   1646              CPU_SR      cpu_sr;
   1647          #endif
   1648              CPU_SIZE_T  rx_pkt_ix;
   1649          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1650              CPU_INT32U  sym_ctr;
   1651              CPU_INT32U  sym_byte_ctr;
   1652          #endif
   1653              CPU_ADDR    sym_addr;
   1654              CPU_SIZE_T  sym_size;
   1655              CPU_SIZE_T  tx_len;
   1656          
   1657                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1658                                                                          /* Expected size >= 2      (= Rx hdr size )             */
   1659                                                                          /*                + 1      (= Nbr of bytes)             */
   1660                                                                          /*                + 4      (= Addr        )             */
   1661                                                                          /*                + nbytes (= Data        ).            */
   1662              if (rx_pkt_size < 7) {
   \   00000008   0x2C07             CMP      R4,#+7
   \   0000000A   0xD204             BCS.N    ??ProbeCom_ReqWrMulti_0
   1663                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   \   0000000C   0x21FE             MOVS     R1,#+254
   \   0000000E   0x9800             LDR      R0,[SP, #+0]
   \   00000010   0x.... 0x....      BL       ProbeCom_ReqErr
   1664                  return (tx_len);
   \   00000014   0xE04C             B.N      ??ProbeCom_ReqWrMulti_1
   1665              }
   1666          
   1667                                                                          /* -------------------- HANDLE WR --------------------- */
   1668              rx_pkt_ix  = 7;                                             /* Rx pkt ix after 1st item = 2 (= Rx hdr size)         */
   \                     ??ProbeCom_ReqWrMulti_0:
   \   00000016   0xF05F 0x0807      MOVS     R8,#+7
   1669                                                                          /*                          + 5 (= 1 item desc).        */
   1670          
   1671          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1672              sym_ctr      = 0;
   \   0000001A   0x2500             MOVS     R5,#+0
   1673              sym_byte_ctr = 0;
   \   0000001C   0x2600             MOVS     R6,#+0
   \   0000001E   0xE013             B.N      ??ProbeCom_ReqWrMulti_2
   1674          #endif
   1675                                                                          /* Sto data for each item.                              */
   1676              while (rx_pkt_ix <= rx_pkt_size) {
   1677                  sym_size = prx_buf[0];                                  /* (a) Get nbr of bytes to wr.                          */
   1678          
   1679                                                                          /* (b) Get wr addr.                                     */
   1680          #if ((!defined(CPU_CFG_ADDR_SIZE)) || \
   1681               ((defined(CPU_CFG_ADDR_SIZE)) && \
   1682                        (CPU_CFG_ADDR_SIZE   != CPU_WORD_SIZE_16)))
   1683                  sym_addr = (prx_buf[4] << 8) + prx_buf[3];
   1684                  sym_addr = (sym_addr   << 8) + prx_buf[2];
   1685                  sym_addr = (sym_addr   << 8) + prx_buf[1];
   1686          #else
   1687                  sym_addr = (prx_buf[2] << 8) + prx_buf[1];
   1688          #endif
   1689          
   1690                  prx_buf += 5;
   1691          
   1692                  if (rx_pkt_ix + sym_size > rx_pkt_size) {
   1693                      tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   1694                      return (tx_len);
   1695                  }
   1696          
   1697          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1698                  sym_ctr++;                                              /* (c) Inc local sym ctr.                               */
   \                     ??ProbeCom_ReqWrMulti_3:
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   1699                  sym_byte_ctr += sym_size;
   \   00000022   0xEB19 0x0606      ADDS     R6,R9,R6
   1700          #endif
   1701                                                                          /* (d) Sto data into pkt.                               */
   1702                  CPU_CRITICAL_ENTER();
   \   00000026   0x.... 0x....      BL       CPU_SR_Save
   \   0000002A   0x4683             MOV      R11,R0
   1703                  Mem_Copy((void     *)sym_addr,
   1704                           (void     *)prx_buf,
   1705                           (CPU_SIZE_T)sym_size);
   \   0000002C   0x464A             MOV      R2,R9
   \   0000002E   0x0039             MOVS     R1,R7
   \   00000030   0x4650             MOV      R0,R10
   \   00000032   0x.... 0x....      BL       Mem_Copy
   1706                  CPU_CRITICAL_EXIT();
   \   00000036   0x4658             MOV      R0,R11
   \   00000038   0x.... 0x....      BL       CPU_SR_Restore
   1707          
   1708                  prx_buf   += sym_size;
   \   0000003C   0xEB19 0x0707      ADDS     R7,R9,R7
   1709                  rx_pkt_ix += 5 + sym_size;
   \   00000040   0xF119 0x0005      ADDS     R0,R9,#+5
   \   00000044   0xEB10 0x0808      ADDS     R8,R0,R8
   \                     ??ProbeCom_ReqWrMulti_2:
   \   00000048   0x4544             CMP      R4,R8
   \   0000004A   0xD316             BCC.N    ??ProbeCom_ReqWrMulti_4
   \   0000004C   0xF897 0x9000      LDRB     R9,[R7, #+0]
   \   00000050   0x7938             LDRB     R0,[R7, #+4]
   \   00000052   0x78F9             LDRB     R1,[R7, #+3]
   \   00000054   0xEB11 0x2A00      ADDS     R10,R1,R0, LSL #+8
   \   00000058   0x78B8             LDRB     R0,[R7, #+2]
   \   0000005A   0xEB10 0x2A0A      ADDS     R10,R0,R10, LSL #+8
   \   0000005E   0x7878             LDRB     R0,[R7, #+1]
   \   00000060   0xEB10 0x2A0A      ADDS     R10,R0,R10, LSL #+8
   \   00000064   0xF207 0x0705      ADDW     R7,R7,#+5
   \   00000068   0xEB19 0x0008      ADDS     R0,R9,R8
   \   0000006C   0x4284             CMP      R4,R0
   \   0000006E   0xD2D7             BCS.N    ??ProbeCom_ReqWrMulti_3
   \   00000070   0x21FE             MOVS     R1,#+254
   \   00000072   0x9800             LDR      R0,[SP, #+0]
   \   00000074   0x.... 0x....      BL       ProbeCom_ReqErr
   \   00000078   0xE01A             B.N      ??ProbeCom_ReqWrMulti_1
   1710              }
   1711          
   1712          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1713              ProbeCom_RxSymCtr     += sym_ctr;                           /* Inc global sym ctr.                                  */
   \                     ??ProbeCom_ReqWrMulti_4:
   \   0000007A   0x....             LDR.N    R0,??DataTable16_11
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x1828             ADDS     R0,R5,R0
   \   00000080   0x....             LDR.N    R1,??DataTable16_11
   \   00000082   0x6008             STR      R0,[R1, #+0]
   1714              ProbeCom_RxSymByteCtr += sym_byte_ctr;
   \   00000084   0x....             LDR.N    R0,??DataTable16_12
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x1830             ADDS     R0,R6,R0
   \   0000008A   0x....             LDR.N    R1,??DataTable16_12
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   1715          #endif
   1716          
   1717                                                                          /* Sto tx pkt hdr :                                     */
   1718              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_WR_MULTI);    /* (a) tx pkt fmt.                                      */
   \   0000008E   0xF248 0x0108      MOVW     R1,#+32776
   \   00000092   0xA800             ADD      R0,SP,#+0
   \   00000094   0x.... 0x....      BL       ProbeCom_StoINT16U
   1719              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   \   00000098   0x2101             MOVS     R1,#+1
   \   0000009A   0xA800             ADD      R0,SP,#+0
   \   0000009C   0x.... 0x....      BL       ProbeCom_StoINT08U
   1720              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* (c) Modifier.                                        */
   \   000000A0   0x.... 0x....      BL       ProbeCom_PktModifier
   \   000000A4   0x0001             MOVS     R1,R0
   \   000000A6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000A8   0xA800             ADD      R0,SP,#+0
   \   000000AA   0x.... 0x....      BL       ProbeCom_StoINT08U
   1721          
   1722                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1723              tx_len = (CPU_SIZE_T)PROBE_COM_SIZE_TX_HDR;                 /* Tx pkt size = 4 (= Tx hdr size).                     */
   \   000000AE   0x2004             MOVS     R0,#+4
   1724              return (tx_len);
   \                     ??ProbeCom_ReqWrMulti_1:
   \   000000B0   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1725          }
   1726          #endif
   1727          
   1728          
   1729          /*
   1730          *********************************************************************************************************
   1731          *                                         ProbeCom_ReqStrIn()
   1732          *
   1733          * Description : Parse the FMT_STR_IN command & formulate response.  This command sends a string to the
   1734          *               target.
   1735          *
   1736          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1737          *
   1738          *               ptx_buf         Pointer to the transmit buffer
   1739          *
   1740          *               rx_pkt_size     Size of the receive  packet
   1741          *
   1742          *               tx_buf_size     Size of the transmit buffer
   1743          *
   1744          * Return(s)   : The number of bytes written to the tx buffer.
   1745          *
   1746          * Caller(s)   : ProbeCom_ParseRxPkt().
   1747          *
   1748          * Note(s)     : (1) The RX format:
   1749          *
   1750          *                   (A) A 2-byte format, indicating the data segment format;
   1751          *                   (B) A 2-byte padding;
   1752          *                   (C) A n-byte string.
   1753          *
   1754          *                         +-------------------------+-------------------------+
   1755          *                         |          Format         |         Padding         |
   1756          *                         +-------------------------+-------------------------+
   1757          *                         |                       String                      |
   1758          *                         |                         .                         |
   1759          *                         |                         .                         |
   1760          *                         |                         .                         |
   1761          *                         +---------------------------------------------------+
   1762          *
   1763          *               (2) The TX format:
   1764          *
   1765          *                   (A) A 2-byte format, indicating the data segment format;
   1766          *                   (B) A 1-byte status, indicating the status after the request;
   1767          *                   (C) A 1-byte modifier.
   1768          *
   1769          *                         +-------------------------+------------+------------+
   1770          *                         |          Format         |   Status   |  Modifier  |
   1771          *                         +-------------------------+------------+------------+
   1772          *
   1773          *********************************************************************************************************
   1774          */
   1775          
   1776          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_ENABLED)
   1777          static  CPU_SIZE_T  ProbeCom_ReqStrIn (CPU_INT08U  *prx_buf,
   1778                                                 CPU_INT08U  *ptx_buf,
   1779                                                 CPU_SIZE_T   rx_pkt_size,
   1780                                                 CPU_SIZE_T   tx_buf_size)
   1781          {
   1782              CPU_SIZE_T   len;
   1783              CPU_SIZE_T   len_wr;
   1784              CPU_SIZE_T   tx_len;
   1785              CPU_CHAR    *pstr;
   1786          
   1787          
   1788                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1789                                                                          /* Expected size = 2 (= Rx hdr size)                    */
   1790                                                                          /*               + 2 (= Padding    ).                   */
   1791              if (rx_pkt_size <= 4) {
   1792                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   1793                  return (tx_len);
   1794              }
   1795          
   1796          
   1797          
   1798                                                                          /* ------------------- HANDLE STR --------------------- */
   1799              pstr   = prx_buf     + 2;                                   /* Ignore padding.                                      */
   1800              len    = rx_pkt_size - 4;
   1801          
   1802              len_wr = ProbeCom_BufWr(&ProbeCom_StrInBuf,                 /* Rd str from buf.                                     */
   1803                                       pstr,
   1804                                       len);
   1805          
   1806          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1807              if (len_wr < len) {
   1808                  ProbeCom_StrRxOvfErrCtr++;
   1809              }
   1810          
   1811              ProbeCom_StrRxCtr += len_wr;
   1812          #endif
   1813          
   1814          
   1815                                                                          /* ------------------ STORE RESPONSE ------------------ */
   1816                                                                          /* Sto tx pkt hdr :                                     */
   1817              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_STR_IN);      /* (a) Tx pkt fmt.                                      */
   1818              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   1819              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* (c) Modifier.                                        */
   1820          
   1821          
   1822          
   1823                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1824              tx_len = (CPU_SIZE_T)PROBE_COM_SIZE_TX_HDR;                 /* Tx pkt size = 4 (= Tx hdr size).                     */
   1825              return (tx_len);
   1826          }
   1827          #endif
   1828          
   1829          
   1830          /*
   1831          *********************************************************************************************************
   1832          *                                        ProbeCom_ReqStrOut()
   1833          *
   1834          * Description : Parse the FMT_STR_OUT command & formulate response.  This command asks the target to send
   1835          *               a string that it is currently storing.
   1836          *
   1837          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1838          *
   1839          *               ptx_buf         Pointer to the transmit buffer
   1840          *
   1841          *               rx_pkt_size     Size of the receive  packet
   1842          *
   1843          *               tx_buf_size     Size of the transmit buffer
   1844          *
   1845          * Return(s)   : The number of bytes written to the tx buffer.
   1846          *
   1847          * Caller(s)   : ProbeCom_ParseRxPkt().
   1848          *
   1849          * Note(s)     : (1) The RX format:
   1850          *
   1851          *                   (A) A 2-byte format, indicating the data segment format;
   1852          *                   (B) A 2-byte padding.
   1853          *
   1854          *                         +-------------------------+-------------------------+
   1855          *                         |          Format         |         Padding         |
   1856          *                         +-------------------------+-------------------------+
   1857          *
   1858          *               (2) The TX format:
   1859          *
   1860          *                   (A) A 2-byte format, indicating the data segment format;
   1861          *                   (B) A 1-byte status, indicating the status after the request;
   1862          *                   (C) A 1-byte modifier;
   1863          *                   (D) A n-byte string, the string which is stored in the target's buffer.
   1864          *
   1865          *                         +-------------------------+------------+------------+
   1866          *                         |          Format         |   Status   |  Modifier  |
   1867          *                         +-------------------------+------------+------------+
   1868          *                         |                       String                      |
   1869          *                         |                         .                         |
   1870          *                         |                         .                         |
   1871          *                         |                         .                         |
   1872          *                         +---------------------------------------------------+
   1873          *
   1874          *               (3) See Notes for 'ProbeCom_StrWr()'.
   1875          *
   1876          *               (4) Probe requires that a NULL byte ends the string.  Consequently, if the data
   1877          *                   section of the TX packet is n bytes long, then only (n - 1) bytes have been read from
   1878          *                   the string buffer.
   1879          *********************************************************************************************************
   1880          */
   1881          
   1882          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_TRUE)
   1883          static  CPU_SIZE_T  ProbeCom_ReqStrOut (CPU_INT08U  *prx_buf,
   1884                                                  CPU_INT08U  *ptx_buf,
   1885                                                  CPU_SIZE_T   rx_pkt_size,
   1886                                                  CPU_SIZE_T   tx_buf_size)
   1887          {
   1888              CPU_SIZE_T  len_rd;
   1889              CPU_SIZE_T  tx_len;
   1890              CPU_SIZE_T  tx_max;
   1891          
   1892          
   1893                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1894                                                                          /* Expected size = 2 (= Rx hdr size)                    */
   1895                                                                          /*               + 2 (= Padding    ).                   */
   1896              if (rx_pkt_size != 4) {
   1897                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   1898                  return (tx_len);
   1899              }
   1900          
   1901                                                                          /* --------------------- STORE STR -------------------- */
   1902                                                                          /* Sto TX pkt hdr :                                     */
   1903              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_STR_OUT);     /* (a) TX pkt fmt.                                      */
   1904              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   1905              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* (c) Modifier.                                        */
   1906          
   1907              tx_max = tx_buf_size - PROBE_COM_SIZE_TX_HDR - 1;           /* Calc size of largest tx str.                         */
   1908          
   1909              len_rd = ProbeCom_BufRd(&ProbeCom_StrOutBuf,                /* Rd str from buf.                                     */
   1910                                       ptx_buf,
   1911                                       tx_max);
   1912          
   1913              if (len_rd == 0) {                                          /* If there is NO str ... rtn err.                      */
   1914                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_STR_OUT_NONE);
   1915                  return (tx_len);
   1916              }
   1917          
   1918             *(ptx_buf + len_rd) = (CPU_INT08U)0;                         /* Wr NULL byte.                                        */
   1919          
   1920          #if (PROBE_COM_CFG_STAT_EN == DEF_ENABLED)
   1921              ProbeCom_StrTxCtr += len_rd;
   1922          #endif
   1923          
   1924          
   1925                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   1926              tx_len = PROBE_COM_SIZE_TX_HDR + len_rd + 1;
   1927              return (tx_len);                                            /* Tx pkt size = 4      (= Tx hdr size)                 */
   1928                                                                          /*             + nbytes (= Str    size)                 */
   1929                                                                          /*             + 1      (= NULL byte  ).                */
   1930          }
   1931          #endif
   1932          
   1933          
   1934          /*
   1935          *********************************************************************************************************
   1936          *                                     ProbeCom_ReqTerminalExec()
   1937          *
   1938          * Description : Parse the FMT_TERMINAL_EXEC command & formulate response.  This command sends a terminal
   1939          *               command to the target for execution.
   1940          *
   1941          * Argument(s) : prx_buf         Pointer to the receive  buffer
   1942          *
   1943          *               ptx_buf         Pointer to the transmit buffer
   1944          *
   1945          *               rx_pkt_size     Size of the receive  packet
   1946          *
   1947          *               tx_buf_size     Size of the transmit buffer
   1948          *
   1949          * Return(s)   : The number of bytes written to the tx buffer.
   1950          *
   1951          * Caller(s)   : ProbeCom_ParseRxPkt().
   1952          *
   1953          * Note(s)     : (1) The RX format:
   1954          *
   1955          *                   (A) A 2-byte format, indicating the data segment format;
   1956          *                   (B) A 2-byte padding;
   1957          *                   (C) A n-byte string.
   1958          *
   1959          *                         +-------------------------+-------------------------+
   1960          *                         |          Format         |         Padding         |
   1961          *                         +-------------------------+-------------------------+
   1962          *                         |                  Terminal Command                 |
   1963          *                         |                         .                         |
   1964          *                         |                         .                         |
   1965          *                         |                         .                         |
   1966          *                         +---------------------------------------------------+
   1967          *
   1968          *               (2) The TX format:
   1969          *
   1970          *                   (A) A 2-byte format, indicating the data segment format;
   1971          *                   (B) A 1-byte status, indicating the status after the request;
   1972          *                   (C) A 1-byte modifier.
   1973          *
   1974          *                         +-------------------------+------------+------------+
   1975          *                         |          Format         |   Status   |  Modifier  |
   1976          *                         +-------------------------+------------+------------+
   1977          *
   1978          *********************************************************************************************************
   1979          */
   1980          
   1981          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   1982          static  CPU_SIZE_T  ProbeCom_ReqTerminalExec (CPU_INT08U  *prx_buf,
   1983                                                        CPU_INT08U  *ptx_buf,
   1984                                                        CPU_SIZE_T   rx_pkt_size,
   1985                                                        CPU_SIZE_T   tx_buf_size)
   1986          {
   \                     ProbeCom_ReqTerminalExec:
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   1987          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
   1988              CPU_SR                         cpu_sr;
   1989          #endif
   1990              PROBE_COM_TERMINAL_EXEC_FNCT   handler;
   1991              CPU_SIZE_T                     len;
   1992              CPU_SIZE_T                     tx_len;
   1993              CPU_CHAR                      *pstr;
   1994          
   1995          
   1996                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   1997                                                                          /* Expected size = 2 (= Rx hdr size)                    */
   1998                                                                          /*               + 2 (= Padding    ).                   */
   1999              if (rx_pkt_size <= 4) {
   \   00000006   0x2D05             CMP      R5,#+5
   \   00000008   0xD204             BCS.N    ??ProbeCom_ReqTerminalExec_0
   2000                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   \   0000000A   0x21FE             MOVS     R1,#+254
   \   0000000C   0x9801             LDR      R0,[SP, #+4]
   \   0000000E   0x.... 0x....      BL       ProbeCom_ReqErr
   2001                  return (tx_len);
   \   00000012   0xE01F             B.N      ??ProbeCom_ReqTerminalExec_1
   2002              }
   2003          
   2004          
   2005          
   2006                                                                          /* -------------------- HANDLE STR -------------------- */
   2007              CPU_CRITICAL_ENTER();
   \                     ??ProbeCom_ReqTerminalExec_0:
   \   00000014   0x.... 0x....      BL       CPU_SR_Save
   2008              handler = ProbeCom_TerminalExecHandler;
   \   00000018   0x....             LDR.N    R1,??DataTable16
   \   0000001A   0x680E             LDR      R6,[R1, #+0]
   2009              CPU_CRITICAL_EXIT();
   \   0000001C   0x.... 0x....      BL       CPU_SR_Restore
   2010          
   2011              if (handler != (PROBE_COM_TERMINAL_EXEC_FNCT)0) {           /* If handler assigned ...                              */
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD005             BEQ.N    ??ProbeCom_ReqTerminalExec_2
   2012                  pstr = prx_buf     + 2;                                 /* ... ignore padding  ...                              */
   \   00000026   0x1CA0             ADDS     R0,R4,#+2
   2013                  len  = rx_pkt_size - 2;
   \   00000028   0x1EA9             SUBS     R1,R5,#+2
   2014          
   2015                  ProbeCom_TerminalExecuting = DEF_YES;
   \   0000002A   0x....             LDR.N    R2,??DataTable16_1
   \   0000002C   0x2301             MOVS     R3,#+1
   \   0000002E   0x7013             STRB     R3,[R2, #+0]
   2016          
   2017                  handler(pstr, len);                                     /* ... exec handler.                                    */
   \   00000030   0x47B0             BLX      R6
   2018              }
   2019          
   2020          
   2021          
   2022                                                                          /* ------------------ STORE RESPONSE ------------------ */
   2023                                                                          /* Sto tx pkt hdr :                                     */
   2024                                                                          /* (a) Tx pkt fmt.                                      */
   2025              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_TERMINAL_EXEC);
   \                     ??ProbeCom_ReqTerminalExec_2:
   \   00000032   0xF248 0x010B      MOVW     R1,#+32779
   \   00000036   0xA801             ADD      R0,SP,#+4
   \   00000038   0x.... 0x....      BL       ProbeCom_StoINT16U
   2026              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   \   0000003C   0x2101             MOVS     R1,#+1
   \   0000003E   0xA801             ADD      R0,SP,#+4
   \   00000040   0x.... 0x....      BL       ProbeCom_StoINT08U
   2027              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* (c) Modifier.                                        */
   \   00000044   0x.... 0x....      BL       ProbeCom_PktModifier
   \   00000048   0x0001             MOVS     R1,R0
   \   0000004A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004C   0xA801             ADD      R0,SP,#+4
   \   0000004E   0x.... 0x....      BL       ProbeCom_StoINT08U
   2028          
   2029          
   2030          
   2031                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   2032              tx_len = (CPU_SIZE_T)PROBE_COM_SIZE_TX_HDR;                 /* Tx pkt size = 4 (= Tx hdr size).                     */
   \   00000052   0x2004             MOVS     R0,#+4
   2033              return (tx_len);
   \                     ??ProbeCom_ReqTerminalExec_1:
   \   00000054   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   2034          }
   2035          #endif
   2036          
   2037          
   2038          /*
   2039          *********************************************************************************************************
   2040          *                                      ProbeCom_ReqTerminalIn()
   2041          *
   2042          * Description : Parse the FMT_TERMINAL_IN command & formulate response.  This command sends a terminal
   2043          *               input to the target.
   2044          *
   2045          * Argument(s) : prx_buf         Pointer to the receive  buffer
   2046          *
   2047          *               ptx_buf         Pointer to the transmit buffer
   2048          *
   2049          *               rx_pkt_size     Size of the receive  packet
   2050          *
   2051          *               tx_buf_size     Size of the transmit buffer
   2052          *
   2053          * Return(s)   : The number of bytes written to the tx buffer.
   2054          *
   2055          * Caller(s)   : ProbeCom_ParseRxPkt().
   2056          *
   2057          * Note(s)     : (1) The RX format:
   2058          *
   2059          *                   (A) A 2-byte format, indicating the data segment format;
   2060          *                   (B) A 2-byte padding;
   2061          *                   (C) A n-byte string.
   2062          *
   2063          *                         +-------------------------+-------------------------+
   2064          *                         |          Format         |         Padding         |
   2065          *                         +-------------------------+-------------------------+
   2066          *                         |                   Terminal Input                  |
   2067          *                         |                         .                         |
   2068          *                         |                         .                         |
   2069          *                         |                         .                         |
   2070          *                         +---------------------------------------------------+
   2071          *
   2072          *               (2) The TX format:
   2073          *
   2074          *                   (A) A 2-byte format, indicating the data segment format;
   2075          *                   (B) A 1-byte status, indicating the status after the request;
   2076          *                   (C) A 1-byte modifier.
   2077          *
   2078          *                         +-------------------------+------------+------------+
   2079          *                         |          Format         |   Status   |  Modifier  |
   2080          *                         +-------------------------+------------+------------+
   2081          *
   2082          *********************************************************************************************************
   2083          */
   2084          
   2085          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_ENABLED)

   \                                 In section .text, align 2, keep-with-next
   2086          static  CPU_SIZE_T  ProbeCom_ReqTerminalIn (CPU_INT08U  *prx_buf,
   2087                                                      CPU_INT08U  *ptx_buf,
   2088                                                      CPU_SIZE_T   rx_pkt_size,
   2089                                                      CPU_SIZE_T   tx_buf_size)
   2090          {
   \                     ProbeCom_ReqTerminalIn:
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   2091          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
   2092              CPU_SR                       cpu_sr;
   2093          #endif
   2094              PROBE_COM_TERMINAL_IN_FNCT   handler;
   2095              CPU_SIZE_T                   len;
   2096              CPU_SIZE_T                   tx_len;
   2097              CPU_CHAR                    *pstr;
   2098          
   2099          
   2100                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   2101                                                                          /* Expected size = 2 (= Rx hdr size)                    */
   2102                                                                          /*               + 2 (= Padding    ).                   */
   2103              if (rx_pkt_size <= 4) {
   \   00000006   0x2D05             CMP      R5,#+5
   \   00000008   0xD204             BCS.N    ??ProbeCom_ReqTerminalIn_0
   2104                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   \   0000000A   0x21FE             MOVS     R1,#+254
   \   0000000C   0x9801             LDR      R0,[SP, #+4]
   \   0000000E   0x.... 0x....      BL       ProbeCom_ReqErr
   2105                  return (tx_len);
   \   00000012   0xE01C             B.N      ??ProbeCom_ReqTerminalIn_1
   2106              }
   2107          
   2108          
   2109          
   2110                                                                          /* -------------------- HANDLE STR -------------------- */
   2111              CPU_CRITICAL_ENTER();
   \                     ??ProbeCom_ReqTerminalIn_0:
   \   00000014   0x.... 0x....      BL       CPU_SR_Save
   2112              handler = ProbeCom_TerminalInHandler;
   \   00000018   0x....             LDR.N    R1,??DataTable16_2
   \   0000001A   0x680E             LDR      R6,[R1, #+0]
   2113              CPU_CRITICAL_EXIT();
   \   0000001C   0x.... 0x....      BL       CPU_SR_Restore
   2114          
   2115              if (handler != (PROBE_COM_TERMINAL_IN_FNCT)0) {             /* If handler assigned.                                 */
   \   00000020   0x0030             MOVS     R0,R6
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD002             BEQ.N    ??ProbeCom_ReqTerminalIn_2
   2116                  pstr = prx_buf     + 4;
   \   00000026   0x1D20             ADDS     R0,R4,#+4
   2117                  len  = rx_pkt_size - 4;
   \   00000028   0x1F29             SUBS     R1,R5,#+4
   2118          
   2119                  handler(pstr, len);
   \   0000002A   0x47B0             BLX      R6
   2120              }
   2121          
   2122          
   2123          
   2124                                                                          /* ------------------ STORE RESPONSE ------------------ */
   2125                                                                          /* Sto tx pkt hdr :                                     */
   2126              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_TERMINAL_IN); /* (a) Tx pkt fmt.                                      */
   \                     ??ProbeCom_ReqTerminalIn_2:
   \   0000002C   0xF248 0x010D      MOVW     R1,#+32781
   \   00000030   0xA801             ADD      R0,SP,#+4
   \   00000032   0x.... 0x....      BL       ProbeCom_StoINT16U
   2127              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0xA801             ADD      R0,SP,#+4
   \   0000003A   0x.... 0x....      BL       ProbeCom_StoINT08U
   2128              ProbeCom_StoINT08U(&ptx_buf, ProbeCom_PktModifier());       /* (c) Modifier.                                        */
   \   0000003E   0x.... 0x....      BL       ProbeCom_PktModifier
   \   00000042   0x0001             MOVS     R1,R0
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0xA801             ADD      R0,SP,#+4
   \   00000048   0x.... 0x....      BL       ProbeCom_StoINT08U
   2129          
   2130          
   2131          
   2132                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   2133              tx_len = (CPU_SIZE_T)PROBE_COM_SIZE_TX_HDR;                 /* Tx pkt size = 4 (= Tx hdr size).                     */
   \   0000004C   0x2004             MOVS     R0,#+4
   2134              return (tx_len);
   \                     ??ProbeCom_ReqTerminalIn_1:
   \   0000004E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   2135          }
   2136          #endif
   2137          
   2138          
   2139          /*
   2140          *********************************************************************************************************
   2141          *                                      ProbeCom_ReqTerminalOut()
   2142          *
   2143          * Description : Parse the FMT_TERMINAL_OUT command & formulate response.  This command asks the target to
   2144          *               send terminal output that it is currently storing.
   2145          *
   2146          * Argument(s) : prx_buf         Pointer to the receive  buffer
   2147          *
   2148          *               ptx_buf         Pointer to the transmit buffer
   2149          *
   2150          *               rx_pkt_size     Size of the receive  packet
   2151          *
   2152          *               tx_buf_size     Size of the transmit buffer
   2153          *
   2154          * Return(s)   : The number of bytes written to the tx buffer.
   2155          *
   2156          * Caller(s)   : ProbeCom_ParseRxPkt().
   2157          *
   2158          * Note(s)     : (1) The RX format:
   2159          *
   2160          *                   (A) A 2-byte format, indicating the data segment format;
   2161          *                   (B) A 2-byte padding.
   2162          *
   2163          *                         +-------------------------+-------------------------+
   2164          *                         |          Format         |         Padding         |
   2165          *                         +-------------------------+-------------------------+
   2166          *
   2167          *               (2) The TX format:
   2168          *
   2169          *                   (A) A 2-byte format, indicating the data segment format;
   2170          *                   (B) A 1-byte status, indicating the status after the request;
   2171          *                   (C) A 1-byte modifier;
   2172          *                   (D) A n-byte string, the string which is stored in the target's buffer.
   2173          *
   2174          *                         +-------------------------+------------+------------+
   2175          *                         |          Format         |   Status   |  Modifier  |
   2176          *                         +-------------------------+------------+------------+
   2177          *                         |                  Terminal Output                  |
   2178          *                         |                         .                         |
   2179          *                         |                         .                         |
   2180          *                         |                         .                         |
   2181          *                         +---------------------------------------------------+
   2182          *
   2183          *               (3) See Notes for 'ProbeCom_StrWr()'.
   2184          *
   2185          *               (4) Probe requires that a NULL byte ends the string.  Consequently, if the data
   2186          *                   section of the TX packet is n bytes long, then only (n - 1) bytes have been read from
   2187          *                   the string buffer.
   2188          *
   2189          *               (5) A NULL modifier is returned so that string transmission will not monopolize the
   2190          *                   transmission channel.  If more string is queued in the string buffer, additional
   2191          *                   string bytes will be sent following the response to the next received packet.
   2192          *********************************************************************************************************
   2193          */
   2194          
   2195          #if (PROBE_COM_CFG_TERMINAL_REQ_EN == DEF_TRUE)

   \                                 In section .text, align 2, keep-with-next
   2196          static  CPU_SIZE_T  ProbeCom_ReqTerminalOut (CPU_INT08U  *prx_buf,
   2197                                                       CPU_INT08U  *ptx_buf,
   2198                                                       CPU_SIZE_T   rx_pkt_size,
   2199                                                       CPU_SIZE_T   tx_buf_size)
   2200          {
   \                     ProbeCom_ReqTerminalOut:
   \   00000000   0xE92D 0x41F3      PUSH     {R0,R1,R4-R8,LR}
   \   00000004   0x001C             MOVS     R4,R3
   2201          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
   2202              CPU_SR       cpu_sr;
   2203          #endif
   2204              CPU_SIZE_T   buf_ix;
   2205              CPU_SIZE_T   buf_len;
   2206              CPU_SIZE_T   tx_len;
   2207              CPU_SIZE_T   tx_max;
   2208              CPU_INT08U  *pbuf;
   2209          
   2210          
   2211                                                                          /* ------------------- CHK PKT SIZE ------------------- */
   2212                                                                          /* Expected size = 2 (= Rx hdr size)                    */
   2213                                                                          /*               + 2 (= Padding    ).                   */
   2214              if (rx_pkt_size != 4) {
   \   00000006   0x2A04             CMP      R2,#+4
   \   00000008   0xD004             BEQ.N    ??ProbeCom_ReqTerminalOut_0
   2215                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_RX_PKT_WRONG_SIZE);
   \   0000000A   0x21FE             MOVS     R1,#+254
   \   0000000C   0x9801             LDR      R0,[SP, #+4]
   \   0000000E   0x.... 0x....      BL       ProbeCom_ReqErr
   2216                  return (tx_len);
   \   00000012   0xE044             B.N      ??ProbeCom_ReqTerminalOut_1
   2217              }
   2218          
   2219              CPU_CRITICAL_ENTER();
   \                     ??ProbeCom_ReqTerminalOut_0:
   \   00000014   0x.... 0x....      BL       CPU_SR_Save
   2220              pbuf    = ProbeCom_TerminalOutBufPtr;
   \   00000018   0x....             LDR.N    R1,??DataTable16_3
   \   0000001A   0x680D             LDR      R5,[R1, #+0]
   2221              buf_ix  = ProbeCom_TerminalOutBufIx;
   \   0000001C   0x....             LDR.N    R1,??DataTable16_4
   \   0000001E   0x680E             LDR      R6,[R1, #+0]
   2222              buf_len = ProbeCom_TerminalOutBufLen;
   \   00000020   0x....             LDR.N    R1,??DataTable16_5
   \   00000022   0x680F             LDR      R7,[R1, #+0]
   2223              CPU_CRITICAL_EXIT();
   \   00000024   0x.... 0x....      BL       CPU_SR_Restore
   2224          
   2225              if (pbuf == (CPU_INT08U *)0) {
   \   00000028   0x2D00             CMP      R5,#+0
   \   0000002A   0xD104             BNE.N    ??ProbeCom_ReqTerminalOut_2
   2226                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_TERMINAL_OUT_NONE);
   \   0000002C   0x21F6             MOVS     R1,#+246
   \   0000002E   0x9801             LDR      R0,[SP, #+4]
   \   00000030   0x.... 0x....      BL       ProbeCom_ReqErr
   2227                  return (tx_len);
   \   00000034   0xE033             B.N      ??ProbeCom_ReqTerminalOut_1
   2228              }
   2229          
   2230              if (buf_ix == buf_len) {
   \                     ??ProbeCom_ReqTerminalOut_2:
   \   00000036   0x42BE             CMP      R6,R7
   \   00000038   0xD104             BNE.N    ??ProbeCom_ReqTerminalOut_3
   2231                  tx_len = ProbeCom_ReqErr(ptx_buf, PROBE_COM_STATUS_TERMINAL_OUT_NONE);
   \   0000003A   0x21F6             MOVS     R1,#+246
   \   0000003C   0x9801             LDR      R0,[SP, #+4]
   \   0000003E   0x.... 0x....      BL       ProbeCom_ReqErr
   2232                  return (tx_len);
   \   00000042   0xE02C             B.N      ??ProbeCom_ReqTerminalOut_1
   2233              }
   2234          
   2235              tx_max = buf_len - buf_ix;
   \                     ??ProbeCom_ReqTerminalOut_3:
   \   00000044   0xEBB7 0x0806      SUBS     R8,R7,R6
   2236              if (tx_max > tx_buf_size - PROBE_COM_SIZE_TX_HDR - 1) {
   \   00000048   0x1F60             SUBS     R0,R4,#+5
   \   0000004A   0x4540             CMP      R0,R8
   \   0000004C   0xD201             BCS.N    ??ProbeCom_ReqTerminalOut_4
   2237                  tx_max = tx_buf_size - PROBE_COM_SIZE_TX_HDR - 1;
   \   0000004E   0xF1B4 0x0805      SUBS     R8,R4,#+5
   2238              }
   2239          
   2240          
   2241                                                                          /* --------------------- STORE OUT -------------------- */
   2242                                                                          /* Sto TX pkt hdr :                                     */
   2243              ProbeCom_StoINT16U(&ptx_buf, PROBE_COM_FMT_TX_TERMINAL_OUT);/* (a) TX pkt fmt.                                      */
   \                     ??ProbeCom_ReqTerminalOut_4:
   \   00000052   0xF248 0x010C      MOVW     R1,#+32780
   \   00000056   0xA801             ADD      R0,SP,#+4
   \   00000058   0x.... 0x....      BL       ProbeCom_StoINT16U
   2244              ProbeCom_StoINT08U(&ptx_buf, PROBE_COM_STATUS_OK);          /* (b) Target status.                                   */
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0xA801             ADD      R0,SP,#+4
   \   00000060   0x.... 0x....      BL       ProbeCom_StoINT08U
   2245              ProbeCom_StoINT08U(&ptx_buf, 0);                            /* (c) Modifier (see Notes #5).                         */
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0xA801             ADD      R0,SP,#+4
   \   00000068   0x.... 0x....      BL       ProbeCom_StoINT08U
   2246          
   2247              Mem_Copy((void       *) ptx_buf,                            /* Copy str from buf.                                   */
   2248                       (void       *)&pbuf[buf_ix],
   2249                       (CPU_SIZE_T  ) tx_max);
   \   0000006C   0x4642             MOV      R2,R8
   \   0000006E   0x1971             ADDS     R1,R6,R5
   \   00000070   0x9801             LDR      R0,[SP, #+4]
   \   00000072   0x.... 0x....      BL       Mem_Copy
   2250          
   2251             *(ptx_buf + tx_max)        = (CPU_INT08U)0;                  /* Wr NULL byte.                                        */
   \   00000076   0x9801             LDR      R0,[SP, #+4]
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0xF808 0x1000      STRB     R1,[R8, R0]
   2252          
   2253              CPU_CRITICAL_ENTER();
   \   0000007E   0x.... 0x....      BL       CPU_SR_Save
   2254              ProbeCom_TerminalOutBufIx = buf_ix + tx_max;                /* Update buf ix.                                       */
   \   00000082   0xEB18 0x0106      ADDS     R1,R8,R6
   \   00000086   0x....             LDR.N    R2,??DataTable16_4
   \   00000088   0x6011             STR      R1,[R2, #+0]
   2255              CPU_CRITICAL_EXIT();
   \   0000008A   0x.... 0x....      BL       CPU_SR_Restore
   2256          
   2257              if (buf_ix + tx_max >= buf_len) {
   \   0000008E   0xEB18 0x0006      ADDS     R0,R8,R6
   \   00000092   0x42B8             CMP      R0,R7
   \   00000094   0xD301             BCC.N    ??ProbeCom_ReqTerminalOut_5
   2258                  ProbeCom_OS_TerminalOutSignal();
   \   00000096   0x.... 0x....      BL       ProbeCom_OS_TerminalOutSignal
   2259              }
   2260          
   2261          
   2262                                                                          /* ------------------ RTN TX PKT SIZE ----------------- */
   2263              tx_len = PROBE_COM_SIZE_TX_HDR + tx_max + 1;
   \                     ??ProbeCom_ReqTerminalOut_5:
   \   0000009A   0xF118 0x0005      ADDS     R0,R8,#+5
   2264              return (tx_len);                                            /* Tx pkt size = 4      (= Tx hdr size)                 */
   \                     ??ProbeCom_ReqTerminalOut_1:
   \   0000009E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
   2265                                                                          /*             + nbytes (= Str    size)                 */
   2266                                                                          /*             + 1      (= NULL byte  ).                */
   2267          }
   2268          #endif
   2269          
   2270          
   2271          /*
   2272          *********************************************************************************************************
   2273          *                                         ProbeCom_BufInit()
   2274          *
   2275          * Description : Initialize buffer.
   2276          *
   2277          * Argument(s) : pbuf            Pointer to buffer.
   2278          *
   2279          *               pdata           Pointer to buffer data.
   2280          *
   2281          *               len             Buffer length.
   2282          *
   2283          * Return(s)   : none.
   2284          *
   2285          * Caller(s)   : Application.
   2286          *
   2287          * Note(s)     : (1) The string buffer is implemented as a circular buffer.  This function is one of two
   2288          *                   points of access for this buffer, the other being in the task or ISR which forms the
   2289          *                   tx packets.  Only this function should modify the global current write index
   2290          *                   (pbuf->IxWr); only the task or ISR which forms the packets should modify the global
   2291          *                   current read index (pbuf->IxRd).
   2292          *
   2293          *               (2) The global current write index (pbuf->IxWr) is the index of the next location in the
   2294          *                   buffer to write.  The global current read index (pbuf->IxRd) is the index of the next
   2295          *                   location in the buffer to read.
   2296          *
   2297          *               (3) The string buffer, an array of pbuf->Len bytes, can only hold (pbuf->Len - 1) bytes
   2298          *                   so that the condition
   2299          *
   2300          *                                        pbuf->IxWr == pbuf->IxRd
   2301          *
   2302          *                   will be true if and only if the buffer is empty.  Consequently, this function
   2303          *                   always leaves an empty space in the buffer.
   2304          *********************************************************************************************************
   2305          */
   2306          
   2307          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_TRUE)
   2308          static  void  ProbeCom_BufInit (PROBE_COM_BUF  *pbuf,
   2309                                          CPU_INT08U     *pdata,
   2310                                          CPU_SIZE_T      len)
   2311          {
   2312              pbuf->Len      = len;
   2313              pbuf->IxRd     = 0;
   2314              pbuf->IxWr     = 0;
   2315              pbuf->DataPtr  = pdata;
   2316          }
   2317          #endif
   2318          
   2319          
   2320          /*
   2321          *********************************************************************************************************
   2322          *                                          ProbeCom_BufRd()
   2323          *
   2324          * Description : Read from buffer.
   2325          *
   2326          * Argument(s) : pbuf            Pointer to buffer.
   2327          *
   2328          *               pdest           Pointer to destination buffer.
   2329          *
   2330          *               len             Number of octets to read.
   2331          *
   2332          * Return(s)   : The number of octets read from buffer.
   2333          *
   2334          * Caller(s)   : Application.
   2335          *
   2336          * Note(s)     : none.
   2337          *********************************************************************************************************
   2338          */
   2339          
   2340          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_TRUE)
   2341          static  CPU_SIZE_T  ProbeCom_BufRd (PROBE_COM_BUF  *pbuf,
   2342                                              CPU_INT08U     *pdest,
   2343                                              CPU_SIZE_T      len)
   2344          {
   2345          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
   2346              CPU_SR       cpu_sr;
   2347          #endif
   2348              CPU_SIZE_T  cnt_copy;
   2349              CPU_SIZE_T  cnt_full;
   2350              CPU_SIZE_T  cnt_rem;
   2351              CPU_SIZE_T  ix_rd;
   2352              CPU_SIZE_T  ix_wr;
   2353              CPU_SIZE_T  len_buf;
   2354          
   2355          
   2356              CPU_CRITICAL_ENTER();
   2357              ix_rd   = pbuf->IxRd;
   2358              ix_wr   = pbuf->IxWr;
   2359              len_buf = pbuf->Len;
   2360          
   2361              if (ix_wr == ix_rd) {                                       /* Buf is empty.                                        */
   2362                  CPU_CRITICAL_EXIT();
   2363                  return ((CPU_SIZE_T)0);
   2364              }
   2365          
   2366          
   2367          
   2368                                                                          /* -------------- COPY DATA FROM BUF END -------------- */
   2369              if (ix_wr > ix_rd) {                                        /* Get str at buf interval [rd_ix, wr_ix).              */
   2370                  cnt_full = ix_wr - ix_rd;
   2371              } else {                                                    /* Get str at buf interval [rd_ix, end_ix).             */
   2372                  cnt_full = len_buf - ix_rd;
   2373              }
   2374          
   2375              cnt_copy  = DEF_MIN(cnt_full, len);                         /* Copy data.                                           */
   2376              Mem_Copy((void *)pdest, (void *)&pbuf->DataPtr[ix_rd], cnt_copy);
   2377          
   2378          
   2379              if ((ix_wr > ix_rd) || (ix_wr == 0)) {
   2380                  ix_rd += cnt_copy;
   2381                  if (ix_rd == len_buf) {
   2382                      pbuf->IxRd = 0;
   2383                  } else {
   2384                      pbuf->IxRd = ix_rd;
   2385                  }
   2386                  CPU_CRITICAL_EXIT();
   2387          
   2388                  return (cnt_copy);
   2389              }
   2390          
   2391          
   2392          
   2393                                                                          /* -------------- COPY DATA AT BUF START -------------- */
   2394              ix_rd    += cnt_copy;
   2395              pdest    += cnt_copy;                                       /* Adj buf ptr.                                         */
   2396              cnt_rem   = len - cnt_copy;                                 /* Calc nbr data octets to copy from buf start.         */
   2397              cnt_copy  = DEF_MIN(ix_wr, cnt_rem);
   2398          
   2399              if (cnt_copy > 0) {
   2400                                                                          /* Copy data.                                           */
   2401                  Mem_Copy((void *)pdest, (void *)&pbuf->DataPtr[0], cnt_copy);
   2402                  pbuf->IxRd = cnt_copy;
   2403              } else {
   2404                  if (ix_rd == len_buf) {
   2405                      pbuf->IxRd = 0;
   2406                  } else {
   2407                      pbuf->IxRd = ix_rd;
   2408                  }
   2409              }
   2410              CPU_CRITICAL_EXIT();
   2411          
   2412              return (len - cnt_rem + cnt_copy);
   2413          }
   2414          #endif
   2415          
   2416          
   2417          /*
   2418          *********************************************************************************************************
   2419          *                                          ProbeCom_BufWr()
   2420          *
   2421          * Description : Write to buffer.
   2422          *
   2423          * Argument(s) : pbuf            Pointer to buffer.
   2424          *
   2425          *               psrc            Pointer to source buffer.
   2426          *
   2427          *               len             Number of octets to write.
   2428          *
   2429          *
   2430          * Return(s)   : Number of octets stored in buffer.
   2431          *
   2432          * Caller(s)   : Hardware Port's ISR.
   2433          *
   2434          * Note(s)     : none.
   2435          *********************************************************************************************************
   2436          */
   2437          
   2438          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_TRUE)
   2439          static  CPU_SIZE_T  ProbeCom_BufWr (PROBE_COM_BUF  *pbuf,
   2440                                              CPU_INT08U     *psrc,
   2441                                              CPU_SIZE_T      len)
   2442          {
   2443          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
   2444              CPU_SR       cpu_sr;
   2445          #endif
   2446              CPU_SIZE_T  cnt_copy;
   2447              CPU_SIZE_T  cnt_empty;
   2448              CPU_SIZE_T  cnt_rem;
   2449              CPU_SIZE_T  ix_rd;
   2450              CPU_SIZE_T  ix_wr;
   2451              CPU_SIZE_T  len_buf;
   2452          
   2453          
   2454              CPU_CRITICAL_ENTER();
   2455              ix_rd   = pbuf->IxRd;
   2456              ix_wr   = pbuf->IxWr;
   2457              len_buf = pbuf->Len;
   2458          
   2459                                                                          /* --------------- COPY DATA AT BUF END --------------- */
   2460              if (ix_rd > ix_wr) {                                        /* Sto str at buf interval [wr_ix, rd_ix - 1).          */
   2461                  cnt_empty = ix_rd - ix_wr - 1;
   2462              } else if (ix_rd == 0) {                                    /* Sto str at buf interval [wr_ix, end_ix - 1).         */
   2463                  cnt_empty = len_buf - ix_wr - 1;
   2464              } else {                                                    /* Sto str at buf interval [wr_ix, end_ix).             */
   2465                  cnt_empty = len_buf - ix_wr;
   2466              }
   2467          
   2468              cnt_copy  = DEF_MIN(cnt_empty, len);                        /* Copy data.                                           */
   2469              Mem_Copy((void *)&pbuf->DataPtr[ix_wr], (void *)psrc, cnt_copy);
   2470          
   2471          
   2472              if ((ix_rd > ix_wr) || (ix_rd == 0)) {
   2473                  pbuf->IxWr = ix_wr + cnt_copy;
   2474                  CPU_CRITICAL_EXIT();
   2475          
   2476                  return (cnt_copy);
   2477              }
   2478          
   2479          
   2480          
   2481                                                                          /* -------------- COPY DATA AT BUF START -------------- */
   2482              ix_wr    += cnt_copy;
   2483              psrc     += cnt_copy;                                       /* Adj buf ptr.                                         */
   2484              cnt_rem   = len - cnt_copy;                                 /* Calc nbr data octets to copy from buf start.         */
   2485              cnt_copy  = DEF_MIN(ix_rd - 1, cnt_rem);
   2486          
   2487              if (cnt_copy > 0) {
   2488                                                                          /* Copy data.                                           */
   2489                  Mem_Copy((void *)&pbuf->DataPtr[0], (void *)psrc, cnt_copy);
   2490                  pbuf->IxWr = cnt_copy;
   2491              } else {
   2492                  if (ix_wr == len_buf) {
   2493                      pbuf->IxWr = 0;
   2494                  } else {
   2495                      pbuf->IxWr = ix_wr;
   2496                  }
   2497              }
   2498              CPU_CRITICAL_EXIT();
   2499          
   2500              return (len - cnt_rem + cnt_copy);
   2501          }
   2502          #endif
   2503          
   2504          
   2505          /*
   2506          *********************************************************************************************************
   2507          *                                        ProbeCom_BufIsEmpty()
   2508          *
   2509          * Description : Determine whether buffer is empty.
   2510          *
   2511          * Argument(s) : pbuf            Pointer to buffer.
   2512          *
   2513          * Return(s)   : DEF_YES, if buffer is empty.
   2514          *               DEF_NO,  if buffer contains any data.
   2515          *
   2516          * Caller(s)   : Application.
   2517          *
   2518          * Note(s)     : none.
   2519          *********************************************************************************************************
   2520          */
   2521          
   2522          #if (PROBE_COM_CFG_STR_REQ_EN == DEF_TRUE)
   2523          static  CPU_BOOLEAN  ProbeCom_BufIsEmpty  (PROBE_COM_BUF  *pbuf)
   2524          {
   2525          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
   2526              CPU_SR       cpu_sr;
   2527          #endif
   2528              CPU_BOOLEAN  empty;
   2529          
   2530          
   2531              CPU_CRITICAL_ENTER();
   2532              empty = ((pbuf->IxRd == pbuf->IxWr) ? (DEF_YES) : (DEF_NO));
   2533              CPU_CRITICAL_EXIT();
   2534          
   2535              return (empty);
   2536          }
   2537          #endif
   2538          
   2539          
   2540          /*
   2541          *********************************************************************************************************
   2542          *                                        ProbeCom_BufIsFull()
   2543          *
   2544          * Description : Determine whether buffer is full.
   2545          *
   2546          * Argument(s) : pbuf            Pointer to buffer.
   2547          *
   2548          * Return(s)   : DEF_YES, if buffer is full.
   2549          *               DEF_NO,  otherwise.
   2550          *
   2551          * Caller(s)   : Application.
   2552          *
   2553          * Note(s)     : none.
   2554          *********************************************************************************************************
   2555          */
   2556          
   2557          #if 0
   2558          static  CPU_BOOLEAN  ProbeCom_BufIsFull  (PROBE_COM_BUF  *pbuf)
   2559          {
   2560          #if (CPU_CFG_CRITICAL_METHOD == CPU_CRITICAL_METHOD_STATUS_LOCAL)
   2561              CPU_SR       cpu_sr;
   2562          #endif
   2563              CPU_BOOLEAN  full;
   2564          
   2565          
   2566              CPU_CRITICAL_ENTER();
   2567              if (pbuf->IxWr == 0) {
   2568                  full = ((pbuf->IxRd == pbuf->Len  - 1) ? (DEF_YES) : (DEF_NO));
   2569              } else {
   2570                  full = ((pbuf->IxRd == pbuf->IxWr - 1) ? (DEF_YES) : (DEF_NO));
   2571              }
   2572              CPU_CRITICAL_EXIT();
   2573          
   2574              return (full);
   2575          }
   2576          #endif
   2577          
   2578          
   2579          /*
   2580          *********************************************************************************************************
   2581          *                                        ProbeCom_GetINT08U()
   2582          *                                        ProbeCom_GetINT16U()
   2583          *                                        ProbeCom_GetINT32U()
   2584          *
   2585          * Description : Retrieve data from a buffer and increment buffer pointer.
   2586          *
   2587          * Argument(s) : pbuf            The pointer to the buffer pointer.
   2588          *
   2589          * Return(s)   : A 8-, 16-, or 32-bit datum, respectively.
   2590          *
   2591          * Caller(s)   : various.
   2592          *
   2593          * Note(s)     : none.
   2594          *********************************************************************************************************
   2595          */
   2596          

   \                                 In section .text, align 2, keep-with-next
   2597          static  CPU_INT08U  ProbeCom_GetINT08U (CPU_INT08U **pbuf)
   2598          {
   2599              return (*((*pbuf)++));
   \                     ProbeCom_GetINT08U:
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x1C4A             ADDS     R2,R1,#+1
   \   00000004   0x6002             STR      R2,[R0, #+0]
   \   00000006   0x7808             LDRB     R0,[R1, #+0]
   \   00000008   0x4770             BX       LR               ;; return
   2600          }
   2601          
   2602          

   \                                 In section .text, align 2, keep-with-next
   2603          static  CPU_INT16U  ProbeCom_GetINT16U (CPU_INT08U **pbuf)
   2604          {
   \                     ProbeCom_GetINT16U:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2605              CPU_INT16U  lowbyte;
   2606              CPU_INT16U  highbyte;
   2607          
   2608          
   2609              lowbyte  = ProbeCom_GetINT08U(pbuf);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       ProbeCom_GetINT08U
   \   0000000A   0x0005             MOVS     R5,R0
   2610              highbyte = ProbeCom_GetINT08U(pbuf);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       ProbeCom_GetINT08U
   2611              return ((CPU_INT16U)((CPU_INT16U)(highbyte << 8) | (CPU_INT16U)lowbyte));
   \   00000012   0xEA55 0x2000      ORRS     R0,R5,R0, LSL #+8
   \   00000016   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2612          }
   2613          

   \                                 In section .text, align 2, keep-with-next
   2614          static  CPU_INT32U  ProbeCom_GetINT32U (CPU_INT08U **pbuf)
   2615          {
   \                     ProbeCom_GetINT32U:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   2616              CPU_INT32U  highword;
   2617              CPU_INT32U  lowword;
   2618          
   2619          
   2620              lowword  = ProbeCom_GetINT16U(pbuf);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       ProbeCom_GetINT16U
   \   0000000A   0x0005             MOVS     R5,R0
   2621              highword = ProbeCom_GetINT16U(pbuf);
   \   0000000C   0x0020             MOVS     R0,R4
   \   0000000E   0x.... 0x....      BL       ProbeCom_GetINT16U
   2622              return ((CPU_INT32U)((highword << 16) | lowword));
   \   00000012   0xEA55 0x4000      ORRS     R0,R5,R0, LSL #+16
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   2623          }
   2624          
   2625          
   2626          /*
   2627          *********************************************************************************************************
   2628          *                                        ProbeCom_StoINT08U()
   2629          *                                        ProbeCom_StoINT16U()
   2630          *                                        ProbeCom_StoINT32U()
   2631          *
   2632          * Description : Store data into a buffer and increment the buffer pointer.
   2633          *
   2634          * Argument(s) : pbuf            The pointer to the buffer pointer.
   2635          *
   2636          *               data            A 8-, 16-, or 32-bit datum, respectively.
   2637          *
   2638          * Return(s)   : none.
   2639          *
   2640          * Caller(s)   : various.
   2641          *
   2642          * Note(s)     : none.
   2643          *********************************************************************************************************
   2644          */
   2645          

   \                                 In section .text, align 2, keep-with-next
   2646          static  void  ProbeCom_StoINT08U (CPU_INT08U **pbuf, CPU_INT08U data)
   2647          {
   2648              *((*pbuf)++) = data;
   \                     ProbeCom_StoINT08U:
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x1C53             ADDS     R3,R2,#+1
   \   00000004   0x6003             STR      R3,[R0, #+0]
   \   00000006   0x7011             STRB     R1,[R2, #+0]
   2649          }
   \   00000008   0x4770             BX       LR               ;; return
   2650          
   2651          

   \                                 In section .text, align 2, keep-with-next
   2652          static  void  ProbeCom_StoINT16U (CPU_INT08U **pbuf, CPU_INT16U data)
   2653          {
   \                     ProbeCom_StoINT16U:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   2654              ProbeCom_StoINT08U(pbuf, (CPU_INT08U)(data & 0x00FF));
   \   00000006   0x0029             MOVS     R1,R5
   \   00000008   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x.... 0x....      BL       ProbeCom_StoINT08U
   2655              ProbeCom_StoINT08U(pbuf, (CPU_INT08U)(data >> 8));
   \   00000010   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000012   0x0A29             LSRS     R1,R5,#+8
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x.... 0x....      BL       ProbeCom_StoINT08U
   2656          }
   \   0000001C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     ProbeCom_TerminalExecHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     ProbeCom_TerminalExecuting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     ProbeCom_TerminalInHandler

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     ProbeCom_TerminalOutBufPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     ProbeCom_TerminalOutBufIx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     ProbeCom_TerminalOutBufLen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     ProbeCom_RxPktCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     ProbeCom_TxPktCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x........         DC32     ProbeCom_TxSymCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x........         DC32     ProbeCom_TxSymByteCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x........         DC32     ProbeCom_ErrPktCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x........         DC32     ProbeCom_RxSymCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x........         DC32     ProbeCom_RxSymByteCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x........         DC32     ProbeCom_EndiannessTest

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   0x12345678         DC32     0x12345678
   2657          
   2658          
   2659          #if 0
   2660          static  void  ProbeCom_StoINT32U (CPU_INT08U **pbuf, CPU_INT32U data)
   2661          {
   2662              ProbeCom_StoINT16U(pbuf, (CPU_INT16U)(data & 0x0000FFFFL));
   2663              ProbeCom_StoINT16U(pbuf, (CPU_INT16U)(data >> 16));
   2664          }
   2665          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ProbeCom_GetINT08U
      16   ProbeCom_GetINT16U
        16   -> ProbeCom_GetINT08U
      16   ProbeCom_GetINT32U
        16   -> ProbeCom_GetINT16U
       8   ProbeCom_Init
         8   -> ProbeCom_OS_Init
      16   ProbeCom_ParseRxPkt
        16   -> ProbeCom_ReqErr
        16   -> ProbeCom_ReqQuery
        16   -> ProbeCom_ReqRd
        16   -> ProbeCom_ReqRdMulti
        16   -> ProbeCom_ReqTerminalExec
        16   -> ProbeCom_ReqTerminalIn
        16   -> ProbeCom_ReqTerminalOut
        16   -> ProbeCom_ReqWr
        16   -> ProbeCom_ReqWrMulti
       8   ProbeCom_PktModifier
         8   -> ProbeCom_TerminalExecDone
         8   -> ProbeCom_TerminalOutAvail
      16   ProbeCom_ReqErr
        16   -> ProbeCom_PktModifier
        16   -> ProbeCom_StoINT08U
        16   -> ProbeCom_StoINT16U
      32   ProbeCom_ReqQuery
        32   -> Mem_Copy
        32   -> ProbeCom_GetINT16U
        32   -> ProbeCom_PktModifier
        32   -> ProbeCom_ReqErr
        32   -> ProbeCom_StoINT08U
        32   -> ProbeCom_StoINT16U
      24   ProbeCom_ReqRd
        24   -> Mem_Copy
        24   -> ProbeCom_GetINT16U
        24   -> ProbeCom_GetINT32U
        24   -> ProbeCom_PktModifier
        24   -> ProbeCom_ReqErr
        24   -> ProbeCom_StoINT08U
        24   -> ProbeCom_StoINT16U
      48   ProbeCom_ReqRdMulti
        48   -> Mem_Copy
        48   -> ProbeCom_PktModifier
        48   -> ProbeCom_ReqErr
      24   ProbeCom_ReqTerminalExec
        24   -- Indirect call
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> ProbeCom_PktModifier
        24   -> ProbeCom_ReqErr
        24   -> ProbeCom_StoINT08U
        24   -> ProbeCom_StoINT16U
      24   ProbeCom_ReqTerminalIn
        24   -- Indirect call
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> ProbeCom_PktModifier
        24   -> ProbeCom_ReqErr
        24   -> ProbeCom_StoINT08U
        24   -> ProbeCom_StoINT16U
      32   ProbeCom_ReqTerminalOut
        32   -> CPU_SR_Restore
        32   -> CPU_SR_Save
        32   -> Mem_Copy
        32   -> ProbeCom_OS_TerminalOutSignal
        32   -> ProbeCom_ReqErr
        32   -> ProbeCom_StoINT08U
        32   -> ProbeCom_StoINT16U
      24   ProbeCom_ReqWr
        24   -> CPU_SR_Restore
        24   -> CPU_SR_Save
        24   -> Mem_Copy
        24   -> ProbeCom_GetINT16U
        24   -> ProbeCom_GetINT32U
        24   -> ProbeCom_PktModifier
        24   -> ProbeCom_ReqErr
        24   -> ProbeCom_StoINT08U
        24   -> ProbeCom_StoINT16U
      40   ProbeCom_ReqWrMulti
        40   -> CPU_SR_Restore
        40   -> CPU_SR_Save
        40   -> Mem_Copy
        40   -> ProbeCom_PktModifier
        40   -> ProbeCom_ReqErr
        40   -> ProbeCom_StoINT08U
        40   -> ProbeCom_StoINT16U
       0   ProbeCom_StoINT08U
      16   ProbeCom_StoINT16U
        16   -> ProbeCom_StoINT08U
       8   ProbeCom_TerminalExecComplete
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
       8   ProbeCom_TerminalExecDone
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
       8   ProbeCom_TerminalExecSet
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
       8   ProbeCom_TerminalInSet
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save
      16   ProbeCom_TerminalOut
        16   -> CPU_SR_Restore
        16   -> CPU_SR_Save
        16   -> ProbeCom_OS_TerminalOutWait
       8   ProbeCom_TerminalOutAvail
         8   -> CPU_SR_Restore
         8   -> CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ProbeCom_EndiannessTest
       4  ProbeCom_ErrPktCtr
      10  ProbeCom_GetINT08U
      26  ProbeCom_GetINT16U
      24  ProbeCom_GetINT32U
     122  ProbeCom_Init
     160  ProbeCom_ParseRxPkt
      38  ProbeCom_PktModifier
      58  ProbeCom_ReqErr
     338  ProbeCom_ReqQuery
     124  ProbeCom_ReqRd
     180  ProbeCom_ReqRdMulti
      86  ProbeCom_ReqTerminalExec
      80  ProbeCom_ReqTerminalIn
     162  ProbeCom_ReqTerminalOut
     130  ProbeCom_ReqWr
     180  ProbeCom_ReqWrMulti
       4  ProbeCom_RxPktCtr
       4  ProbeCom_RxSymByteCtr
       4  ProbeCom_RxSymCtr
      10  ProbeCom_StoINT08U
      30  ProbeCom_StoINT16U
      32  ProbeCom_TerminalExecComplete
      32  ProbeCom_TerminalExecDone
       4  ProbeCom_TerminalExecHandler
      20  ProbeCom_TerminalExecSet
       1  ProbeCom_TerminalExecuting
       4  ProbeCom_TerminalInHandler
      20  ProbeCom_TerminalInSet
     114  ProbeCom_TerminalOut
      30  ProbeCom_TerminalOutAvail
       4  ProbeCom_TerminalOutBufIx
       4  ProbeCom_TerminalOutBufLen
       4  ProbeCom_TerminalOutBufPtr
       4  ProbeCom_TxPktCtr
       4  ProbeCom_TxSymByteCtr
       4  ProbeCom_TxSymCtr

 
    53 bytes in section .bss
 2 066 bytes in section .text
 
 2 066 bytes of CODE memory
    53 bytes of DATA memory

Errors: none
Warnings: none
