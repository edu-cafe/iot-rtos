###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      11/Mar/2013  20:18:54 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\BookSrc_CM3_IAR\Software\CPU\ST\STM32\src\stm32f10x_s #
#                    pi.c                                                     #
#    Command line =  C:\BookSrc_CM3_IAR\Software\CPU\ST\STM32\src\stm32f10x_s #
#                    pi.c -lCN C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANG #
#                    O-Z1\IAR\OS-Probe\Flash\List\ -o                         #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\Obj\ --no_cse --no_unroll --no_inline      #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANG #
#                    O-Z1\IAR\OS-Probe\ -I C:\BookSrc_CM3_IAR\Software\EvalBo #
#                    ards\ST\MANGO-Z1\IAR\OS-Probe\..\BSP\ -I                 #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\CPU\ST\STM32\inc\ -I              #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-CPU\ -I                        #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\ -I      #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-LCD\Source\ -I                 #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-LIB\ -I                        #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex-M3\Gener #
#                    ic\IAR\ -I C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MAN #
#                    GO-Z1\IAR\OS-Probe\..\..\..\..\..\uCOS-II\Source\ -I     #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Gen #
#                    eric\RS-232\Source\ -I C:\BookSrc_CM3_IAR\Software\EvalB #
#                    oards\ST\MANGO-Z1\IAR\OS-Probe\..\..\..\..\..\uC-Probe\T #
#                    arget\Communication\Generic\RS-232\Ports\ST\STM32\ -I    #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Gen #
#                    eric\Source\ -I C:\BookSrc_CM3_IAR\Software\EvalBoards\S #
#                    T\MANGO-Z1\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\P #
#                    lugins\uCOS-II\ -Ol --use_c++_inline                     #
#    List file    =  C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\List\stm32f10x_spi.lst                     #
#    Object file  =  C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\Obj\stm32f10x_spi.o                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\BookSrc_CM3_IAR\Software\CPU\ST\STM32\src\stm32f10x_spi.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_spi.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.3
      5          * Date               : 09/22/2008
      6          * Description        : This file provides all the SPI firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_spi.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          /* Private define ------------------------------------------------------------*/
     22          /* SPI SPE mask */
     23          #define CR1_SPE_Set          ((u16)0x0040)
     24          #define CR1_SPE_Reset        ((u16)0xFFBF)
     25          
     26          /* I2S I2SE mask */
     27          #define I2SCFGR_I2SE_Set     ((u16)0x0400)
     28          #define I2SCFGR_I2SE_Reset   ((u16)0xFBFF)
     29          
     30          /* SPI CRCNext mask */
     31          #define CR1_CRCNext_Set      ((u16)0x1000)
     32          
     33          /* SPI CRCEN mask */
     34          #define CR1_CRCEN_Set        ((u16)0x2000)
     35          #define CR1_CRCEN_Reset      ((u16)0xDFFF)
     36          
     37          /* SPI SSOE mask */
     38          #define CR2_SSOE_Set         ((u16)0x0004)
     39          #define CR2_SSOE_Reset       ((u16)0xFFFB)
     40          
     41          /* SPI registers Masks */
     42          #define CR1_CLEAR_Mask       ((u16)0x3040)
     43          #define I2SCFGR_CLEAR_Mask   ((u16)0xF040)
     44          
     45          /* SPI or I2S mode selection masks */
     46          #define SPI_Mode_Select      ((u16)0xF7FF)
     47          #define I2S_Mode_Select      ((u16)0x0800) 
     48          
     49          /* Private macro -------------------------------------------------------------*/
     50          /* Private variables ---------------------------------------------------------*/
     51          /* Private function prototypes -----------------------------------------------*/
     52          /* Private functions ---------------------------------------------------------*/
     53          
     54          /*******************************************************************************
     55          * Function Name  : SPI_I2S_DeInit
     56          * Description    : Deinitializes the SPIx peripheral registers to their default
     57          *                  reset values (Affects also the I2Ss).
     58          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
     59          * Output         : None
     60          * Return         : None
     61          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     62          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
     63          {
   \                     SPI_I2S_DeInit:
   \   00000000   0xB580             PUSH     {R7,LR}
     64            /* Check the parameters */
     65            assert_param(IS_SPI_ALL_PERIPH(SPIx));
     66            
     67            switch (*(u32*)&SPIx)
   \   00000002   0x....             LDR.N    R1,??DataTable0  ;; 0x40003800
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD010             BEQ.N    ??SPI_I2S_DeInit_0
   \   00000008   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40003c00
   \   0000000A   0x4288             CMP      R0,R1
   \   0000000C   0xD018             BEQ.N    ??SPI_I2S_DeInit_1
   \   0000000E   0x....             LDR.N    R1,??DataTable0_2  ;; 0x40013000
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xD120             BNE.N    ??SPI_I2S_DeInit_2
     68            {
     69              case SPI1_BASE:
     70                /* Enable SPI1 reset state */
     71                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   \                     ??SPI_I2S_DeInit_3:
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0xF44F 0x5080      MOV      R0,#+4096
   \   0000001A   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     72                /* Release SPI1 from reset state */
     73                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0xF44F 0x5080      MOV      R0,#+4096
   \   00000024   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
     74                break;
   \   00000028   0xE015             B.N      ??SPI_I2S_DeInit_4
     75          
     76              case SPI2_BASE:
     77                /* Enable SPI2 reset state */
     78                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   \                     ??SPI_I2S_DeInit_0:
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0xF44F 0x4080      MOV      R0,#+16384
   \   00000030   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     79                /* Release SPI2 from reset state */
     80                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0xF44F 0x4080      MOV      R0,#+16384
   \   0000003A   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     81                break;
   \   0000003E   0xE00A             B.N      ??SPI_I2S_DeInit_4
     82          
     83              case SPI3_BASE:
     84                /* Enable SPI3 reset state */
     85                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
   \                     ??SPI_I2S_DeInit_1:
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0xF44F 0x4000      MOV      R0,#+32768
   \   00000046   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     86                /* Release SPI3 from reset state */
     87                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0xF44F 0x4000      MOV      R0,#+32768
   \   00000050   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
     88                break;
   \   00000054   0xE7FF             B.N      ??SPI_I2S_DeInit_4
     89          
     90              default:
     91                break;
     92            }
     93          }
   \                     ??SPI_I2S_DeInit_2:
   \                     ??SPI_I2S_DeInit_4:
   \   00000056   0xBD01             POP      {R0,PC}          ;; return
     94          
     95          /*******************************************************************************
     96          * Function Name  : SPI_Init
     97          * Description    : Initializes the SPIx peripheral according to the specified 
     98          *                  parameters in the SPI_InitStruct.
     99          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    100          *                  - SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    101          *                    contains the configuration information for the specified
    102          *                    SPI peripheral.
    103          * Output         : None
    104          * Return         : None
    105          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    106          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    107          {
   \                     SPI_Init:
   \   00000000   0xB410             PUSH     {R4}
    108            u16 tmpreg = 0;
   \   00000002   0x2200             MOVS     R2,#+0
    109            
    110            /* check the parameters */
    111            assert_param(IS_SPI_ALL_PERIPH(SPIx));   
    112            
    113            /* Check the SPI parameters */
    114            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
    115            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    116            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
    117            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    118            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    119            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
    120            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
    121            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
    122            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
    123          
    124          /*---------------------------- SPIx CR1 Configuration ------------------------*/
    125            /* Get the SPIx CR1 value */
    126            tmpreg = SPIx->CR1;
   \   00000004   0x8803             LDRH     R3,[R0, #+0]
   \   00000006   0x001A             MOVS     R2,R3
    127            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    128            tmpreg &= CR1_CLEAR_Mask;
   \   00000008   0xF412 0x5241      ANDS     R2,R2,#0x3040
    129            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    130               master/salve mode, CPOL and CPHA */
    131            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    132            /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    133            /* Set LSBFirst bit according to SPI_FirstBit value */
    134            /* Set BR bits according to SPI_BaudRatePrescaler value */
    135            /* Set CPOL bit according to SPI_CPOL value */
    136            /* Set CPHA bit according to SPI_CPHA value */
    137            tmpreg |= (u16)((u32)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
    138                            SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
    139                            SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
    140                            SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
   \   0000000C   0x880B             LDRH     R3,[R1, #+0]
   \   0000000E   0x884C             LDRH     R4,[R1, #+2]
   \   00000010   0x4323             ORRS     R3,R4,R3
   \   00000012   0x888C             LDRH     R4,[R1, #+4]
   \   00000014   0x4323             ORRS     R3,R4,R3
   \   00000016   0x88CC             LDRH     R4,[R1, #+6]
   \   00000018   0x4323             ORRS     R3,R4,R3
   \   0000001A   0x890C             LDRH     R4,[R1, #+8]
   \   0000001C   0x4323             ORRS     R3,R4,R3
   \   0000001E   0x894C             LDRH     R4,[R1, #+10]
   \   00000020   0x4323             ORRS     R3,R4,R3
   \   00000022   0x898C             LDRH     R4,[R1, #+12]
   \   00000024   0x4323             ORRS     R3,R4,R3
   \   00000026   0x89CC             LDRH     R4,[R1, #+14]
   \   00000028   0x4323             ORRS     R3,R4,R3
   \   0000002A   0x431A             ORRS     R2,R3,R2
    141            /* Write to SPIx CR1 */
    142            SPIx->CR1 = tmpreg;
   \   0000002C   0x8002             STRH     R2,[R0, #+0]
    143            
    144            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    145            SPIx->I2SCFGR &= SPI_Mode_Select;		
   \   0000002E   0x8B82             LDRH     R2,[R0, #+28]
   \   00000030   0xF24F 0x73FF      MOVW     R3,#+63487
   \   00000034   0x401A             ANDS     R2,R3,R2
   \   00000036   0x8382             STRH     R2,[R0, #+28]
    146          
    147          /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    148            /* Write to SPIx CRCPOLY */
    149            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
   \   00000038   0x8A09             LDRH     R1,[R1, #+16]
   \   0000003A   0x8201             STRH     R1,[R0, #+16]
    150          }
   \   0000003C   0xBC10             POP      {R4}
   \   0000003E   0x4770             BX       LR               ;; return
    151          
    152          /*******************************************************************************
    153          * Function Name  : I2S_Init
    154          * Description    : Initializes the SPIx peripheral according to the specified 
    155          *                  parameters in the I2S_InitStruct.
    156          * Input          : - SPIx: where x can be  2 or 3 to select the SPI peripheral
    157          *                     (configured in I2S mode).
    158          *                  - I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    159          *                    contains the configuration information for the specified
    160          *                    SPI peripheral configured in I2S mode.
    161          * Output         : None
    162          * Return         : None
    163          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    164          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    165          {
   \                     I2S_Init:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    166            u16 tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x2701             MOVS     R7,#+1
    167            u32 tmp = 0;
   \   00000010   0x2200             MOVS     R2,#+0
    168            RCC_ClocksTypeDef RCC_Clocks;
    169             
    170            /* Check the I2S parameters */
    171            assert_param(IS_SPI_23_PERIPH(SPIx));
    172            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    173            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    174            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    175            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
    176            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
    177            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
    178          
    179          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    180          
    181            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    182            SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
   \   00000012   0x8BA3             LDRH     R3,[R4, #+28]
   \   00000014   0xF24F 0x0C40      MOVW     R12,#+61504
   \   00000018   0xEA1C 0x0303      ANDS     R3,R12,R3
   \   0000001C   0x83A3             STRH     R3,[R4, #+28]
    183            SPIx->I2SPR = 0x0002;
   \   0000001E   0x2302             MOVS     R3,#+2
   \   00000020   0x8423             STRH     R3,[R4, #+32]
    184            
    185            /* Get the I2SCFGR register value */
    186            tmpreg = SPIx->I2SCFGR;
   \   00000022   0x8BA3             LDRH     R3,[R4, #+28]
   \   00000024   0x001E             MOVS     R6,R3
    187            
    188            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    189            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
   \   00000026   0x892B             LDRH     R3,[R5, #+8]
   \   00000028   0x2B02             CMP      R3,#+2
   \   0000002A   0xD102             BNE.N    ??I2S_Init_0
    190            {
    191              i2sodd = (u16)0;
   \   0000002C   0x2000             MOVS     R0,#+0
    192              i2sdiv = (u16)2;   
   \   0000002E   0x2102             MOVS     R1,#+2
   \   00000030   0xE02D             B.N      ??I2S_Init_1
    193            }
    194            /* If the requested audio frequency is not the default, compute the prescaler */
    195            else
    196            {
    197              /* Check the frame length (For the Prescaler computing) */
    198              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
   \                     ??I2S_Init_0:
   \   00000032   0x88A8             LDRH     R0,[R5, #+4]
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD101             BNE.N    ??I2S_Init_2
    199              {
    200                /* Packet length is 16 bits */
    201                packetlength = 1;
   \   00000038   0x2701             MOVS     R7,#+1
   \   0000003A   0xE000             B.N      ??I2S_Init_3
    202              }
    203              else
    204              {
    205                /* Packet length is 32 bits */
    206                packetlength = 2;
   \                     ??I2S_Init_2:
   \   0000003C   0x2702             MOVS     R7,#+2
    207              }
    208              /* Get System Clock frequency */
    209              RCC_GetClocksFreq(&RCC_Clocks);
   \                     ??I2S_Init_3:
   \   0000003E   0xA800             ADD      R0,SP,#+0
   \   00000040   0x.... 0x....      BL       RCC_GetClocksFreq
    210              
    211              /* Compute the Real divider depending on the MCLK output state with a flaoting point */
    212              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
   \   00000044   0x88E8             LDRH     R0,[R5, #+6]
   \   00000046   0xF5B0 0x7F00      CMP      R0,#+512
   \   0000004A   0xD10B             BNE.N    ??I2S_Init_4
    213              {
    214                /* MCLK output is enabled */
    215                tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (256 * I2S_InitStruct->I2S_AudioFreq)) + 5);
   \   0000004C   0x9800             LDR      R0,[SP, #+0]
   \   0000004E   0x210A             MOVS     R1,#+10
   \   00000050   0x4348             MULS     R0,R1,R0
   \   00000052   0x8929             LDRH     R1,[R5, #+8]
   \   00000054   0xF44F 0x7280      MOV      R2,#+256
   \   00000058   0x4351             MULS     R1,R2,R1
   \   0000005A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000005E   0x1D42             ADDS     R2,R0,#+5
   \   00000060   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000062   0xE00B             B.N      ??I2S_Init_5
    216              }
    217              else
    218              {
    219                /* MCLK output is disabled */
    220                tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (32 * packetlength * I2S_InitStruct->I2S_AudioFreq)) + 5);
   \                     ??I2S_Init_4:
   \   00000064   0x9800             LDR      R0,[SP, #+0]
   \   00000066   0x210A             MOVS     R1,#+10
   \   00000068   0x4348             MULS     R0,R1,R0
   \   0000006A   0xB2BF             UXTH     R7,R7            ;; ZeroExt  R7,R7,#+16,#+16
   \   0000006C   0x8929             LDRH     R1,[R5, #+8]
   \   0000006E   0xFB01 0xF107      MUL      R1,R1,R7
   \   00000072   0x0149             LSLS     R1,R1,#+5
   \   00000074   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   00000078   0x1D42             ADDS     R2,R0,#+5
   \   0000007A   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
    221              }
    222              
    223              /* Remove the flaoting point */
    224              tmp = tmp/10;  
   \                     ??I2S_Init_5:
   \   0000007C   0x200A             MOVS     R0,#+10
   \   0000007E   0xFBB2 0xF2F0      UDIV     R2,R2,R0
    225                
    226              /* Check the parity of the divider */
    227              i2sodd = (u16)(tmp & (u16)0x0001);
   \   00000082   0xF012 0x0001      ANDS     R0,R2,#0x1
    228             
    229              /* Compute the i2sdiv prescaler */
    230              i2sdiv = (u16)((tmp - i2sodd) / 2);
   \   00000086   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000088   0x1A11             SUBS     R1,R2,R0
   \   0000008A   0x0849             LSRS     R1,R1,#+1
    231             
    232              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    233              i2sodd = (u16) (i2sodd << 8);
   \   0000008C   0x0200             LSLS     R0,R0,#+8
    234            }
    235            
    236            /* Test if the divider is 1 or 0 */
    237            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
   \                     ??I2S_Init_1:
   \   0000008E   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000090   0x1E8A             SUBS     R2,R1,#+2
   \   00000092   0x2AFE             CMP      R2,#+254
   \   00000094   0xD301             BCC.N    ??I2S_Init_6
    238            {
    239              /* Set the default values */
    240              i2sdiv = 2;
   \   00000096   0x2102             MOVS     R1,#+2
    241              i2sodd = 0;
   \   00000098   0x2000             MOVS     R0,#+0
    242            }
    243          
    244            /* Write to SPIx I2SPR register the computed value */
    245            SPIx->I2SPR = (u16)(i2sdiv | i2sodd | I2S_InitStruct->I2S_MCLKOutput);  
   \                     ??I2S_Init_6:
   \   0000009A   0x4308             ORRS     R0,R0,R1
   \   0000009C   0x88E9             LDRH     R1,[R5, #+6]
   \   0000009E   0x4308             ORRS     R0,R1,R0
   \   000000A0   0x8420             STRH     R0,[R4, #+32]
    246           
    247            /* Configure the I2S with the SPI_InitStruct values */
    248            tmpreg |= (u16)(I2S_Mode_Select | I2S_InitStruct->I2S_Mode | \
    249                            I2S_InitStruct->I2S_Standard | I2S_InitStruct->I2S_DataFormat | \
    250                            I2S_InitStruct->I2S_CPOL);
   \   000000A2   0x8828             LDRH     R0,[R5, #+0]
   \   000000A4   0x8869             LDRH     R1,[R5, #+2]
   \   000000A6   0x4308             ORRS     R0,R1,R0
   \   000000A8   0x88A9             LDRH     R1,[R5, #+4]
   \   000000AA   0x4308             ORRS     R0,R1,R0
   \   000000AC   0x8969             LDRH     R1,[R5, #+10]
   \   000000AE   0x4308             ORRS     R0,R1,R0
   \   000000B0   0xF450 0x6000      ORRS     R0,R0,#0x800
   \   000000B4   0x4306             ORRS     R6,R0,R6
    251           
    252            /* Write to SPIx I2SCFGR */  
    253            SPIx->I2SCFGR = tmpreg;                                    
   \   000000B6   0x83A6             STRH     R6,[R4, #+28]
    254          }
   \   000000B8   0xB005             ADD      SP,SP,#+20
   \   000000BA   0xBDF0             POP      {R4-R7,PC}       ;; return
    255          
    256          /*******************************************************************************
    257          * Function Name  : SPI_StructInit
    258          * Description    : Fills each SPI_InitStruct member with its default value.
    259          * Input          : - SPI_InitStruct : pointer to a SPI_InitTypeDef structure
    260          *                    which will be initialized.
    261          * Output         : None
    262          * Return         : None
    263          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    264          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    265          {
    266          /*--------------- Reset SPI init structure parameters values -----------------*/
    267            /* Initialize the SPI_Direction member */
    268            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \                     SPI_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    269          
    270            /* initialize the SPI_Mode member */
    271            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    272          
    273            /* initialize the SPI_DataSize member */
    274            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    275          
    276            /* Initialize the SPI_CPOL member */
    277            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    278          
    279            /* Initialize the SPI_CPHA member */
    280            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    281          
    282            /* Initialize the SPI_NSS member */
    283            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8141             STRH     R1,[R0, #+10]
    284          
    285            /* Initialize the SPI_BaudRatePrescaler member */
    286            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x8181             STRH     R1,[R0, #+12]
    287          
    288            /* Initialize the SPI_FirstBit member */
    289            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x81C1             STRH     R1,[R0, #+14]
    290          
    291            /* Initialize the SPI_CRCPolynomial member */
    292            SPI_InitStruct->SPI_CRCPolynomial = 7;
   \   00000020   0x2107             MOVS     R1,#+7
   \   00000022   0x8201             STRH     R1,[R0, #+16]
    293          }
   \   00000024   0x4770             BX       LR               ;; return
    294          
    295          /*******************************************************************************
    296          * Function Name  : I2S_StructInit
    297          * Description    : Fills each I2S_InitStruct member with its default value.
    298          * Input          : - I2S_InitStruct : pointer to a I2S_InitTypeDef structure
    299          *                    which will be initialized.
    300          * Output         : None
    301          * Return         : None
    302          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    303          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    304          {
    305          /*--------------- Reset I2S init structure parameters values -----------------*/
    306            /* Initialize the I2S_Mode member */
    307            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
   \                     I2S_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    308            
    309            /* Initialize the I2S_Standard member */
    310            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    311            
    312            /* Initialize the I2S_DataFormat member */
    313            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
    314            
    315            /* Initialize the I2S_MCLKOutput member */
    316            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x80C1             STRH     R1,[R0, #+6]
    317            
    318            /* Initialize the I2S_AudioFreq member */
    319            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
   \   00000010   0x2102             MOVS     R1,#+2
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    320            
    321            /* Initialize the I2S_CPOL member */
    322            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x8141             STRH     R1,[R0, #+10]
    323          }
   \   00000018   0x4770             BX       LR               ;; return
    324          
    325          /*******************************************************************************
    326          * Function Name  : SPI_Cmd
    327          * Description    : Enables or disables the specified SPI peripheral.
    328          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    329          *                  - NewState: new state of the SPIx peripheral. 
    330          *                    This parameter can be: ENABLE or DISABLE.
    331          * Output         : None
    332          * Return         : None
    333          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    334          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    335          {
    336            /* Check the parameters */
    337            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    338            assert_param(IS_FUNCTIONAL_STATE(NewState));
    339          
    340            if (NewState != DISABLE)
   \                     SPI_Cmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??SPI_Cmd_0
    341            {
    342              /* Enable the selected SPI peripheral */
    343              SPIx->CR1 |= CR1_SPE_Set;
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xF051 0x0140      ORRS     R1,R1,#0x40
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
   \   0000000E   0xE004             B.N      ??SPI_Cmd_1
    344            }
    345            else
    346            {
    347              /* Disable the selected SPI peripheral */
    348              SPIx->CR1 &= CR1_SPE_Reset;
   \                     ??SPI_Cmd_0:
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0xF64F 0x72BF      MOVW     R2,#+65471
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    349            }
    350          }
   \                     ??SPI_Cmd_1:
   \   0000001A   0x4770             BX       LR               ;; return
    351          
    352          /*******************************************************************************
    353          * Function Name  : I2S_Cmd
    354          * Description    : Enables or disables the specified SPI peripheral (in I2S mode).
    355          * Input          : - SPIx: where x can be 2 or 3 to select the SPI peripheral.
    356          *                  - NewState: new state of the SPIx peripheral. 
    357          *                    This parameter can be: ENABLE or DISABLE.
    358          * Output         : None
    359          * Return         : None
    360          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    361          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    362          {
    363            /* Check the parameters */
    364            assert_param(IS_SPI_23_PERIPH(SPIx));
    365            assert_param(IS_FUNCTIONAL_STATE(NewState));
    366          
    367            if (NewState != DISABLE)
   \                     I2S_Cmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??I2S_Cmd_0
    368            {
    369              /* Enable the selected SPI peripheral (in I2S mode) */
    370              SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;
   \   00000006   0x8B81             LDRH     R1,[R0, #+28]
   \   00000008   0xF451 0x6180      ORRS     R1,R1,#0x400
   \   0000000C   0x8381             STRH     R1,[R0, #+28]
   \   0000000E   0xE004             B.N      ??I2S_Cmd_1
    371            }
    372            else
    373            {
    374              /* Disable the selected SPI peripheral (in I2S mode) */
    375              SPIx->I2SCFGR &= I2SCFGR_I2SE_Reset;
   \                     ??I2S_Cmd_0:
   \   00000010   0x8B81             LDRH     R1,[R0, #+28]
   \   00000012   0xF64F 0x32FF      MOVW     R2,#+64511
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8381             STRH     R1,[R0, #+28]
    376            }
    377          }
   \                     ??I2S_Cmd_1:
   \   0000001A   0x4770             BX       LR               ;; return
    378          
    379          /*******************************************************************************
    380          * Function Name  : SPI_I2S_ITConfig
    381          * Description    : Enables or disables the specified SPI/I2S interrupts.
    382          * Input          : - SPIx: where x can be :
    383          *                         - 1, 2 or 3 in SPI mode 
    384          *                         - 2 or 3 in I2S mode
    385          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to be 
    386          *                    enabled or disabled. 
    387          *                    This parameter can be one of the following values:
    388          *                       - SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
    389          *                       - SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
    390          *                       - SPI_I2S_IT_ERR: Error interrupt mask
    391          *                  - NewState: new state of the specified SPI/I2S interrupt.
    392          *                    This parameter can be: ENABLE or DISABLE.
    393          * Output         : None
    394          * Return         : None
    395          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    396          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, u8 SPI_I2S_IT, FunctionalState NewState)
    397          {
   \                     SPI_I2S_ITConfig:
   \   00000000   0xB410             PUSH     {R4}
    398            u16 itpos = 0, itmask = 0 ;
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0x2400             MOVS     R4,#+0
    399          
    400            /* Check the parameters */
    401            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    402            assert_param(IS_FUNCTIONAL_STATE(NewState));
    403            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
    404          
    405            /* Get the SPI/I2S IT index */
    406            itpos = SPI_I2S_IT >> 4;
   \   00000006   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000008   0x0909             LSRS     R1,R1,#+4
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x000B             MOVS     R3,R1
    407            /* Set the IT mask */
    408            itmask = (u16)((u16)1 << itpos);
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x4099             LSLS     R1,R1,R3
   \   00000012   0x000C             MOVS     R4,R1
    409          
    410            if (NewState != DISABLE)
   \   00000014   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD003             BEQ.N    ??SPI_I2S_ITConfig_0
    411            {
    412              /* Enable the selected SPI/I2S interrupt */
    413              SPIx->CR2 |= itmask;
   \   0000001A   0x8881             LDRH     R1,[R0, #+4]
   \   0000001C   0x4321             ORRS     R1,R4,R1
   \   0000001E   0x8081             STRH     R1,[R0, #+4]
   \   00000020   0xE002             B.N      ??SPI_I2S_ITConfig_1
    414            }
    415            else
    416            {
    417              /* Disable the selected SPI/I2S interrupt */
    418              SPIx->CR2 &= (u16)~itmask;
   \                     ??SPI_I2S_ITConfig_0:
   \   00000022   0x8881             LDRH     R1,[R0, #+4]
   \   00000024   0x43A1             BICS     R1,R1,R4
   \   00000026   0x8081             STRH     R1,[R0, #+4]
    419            }
    420          }
   \                     ??SPI_I2S_ITConfig_1:
   \   00000028   0xBC10             POP      {R4}
   \   0000002A   0x4770             BX       LR               ;; return
    421          
    422          /*******************************************************************************
    423          * Function Name  : SPI_I2S_DMACmd
    424          * Description    : Enables or disables the SPIx/I2Sx DMA interface.
    425          * Input          : - SPIx: where x can be :
    426          *                         - 1, 2 or 3 in SPI mode 
    427          *                         - 2 or 3 in I2S mode
    428          *                  - SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request 
    429          *                    to be enabled or disabled. 
    430          *                    This parameter can be any combination of the following values:
    431          *                       - SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    432          *                       - SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    433          *                  - NewState: new state of the selected SPI/I2S DMA transfer 
    434          *                    request.
    435          *                    This parameter can be: ENABLE or DISABLE.
    436          * Output         : None
    437          * Return         : None
    438          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    439          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, u16 SPI_I2S_DMAReq, FunctionalState NewState)
    440          {
    441            /* Check the parameters */
    442            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    443            assert_param(IS_FUNCTIONAL_STATE(NewState));
    444            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
    445          
    446            if (NewState != DISABLE)
   \                     SPI_I2S_DMACmd:
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD003             BEQ.N    ??SPI_I2S_DMACmd_0
    447            {
    448              /* Enable the selected SPI/I2S DMA requests */
    449              SPIx->CR2 |= SPI_I2S_DMAReq;
   \   00000006   0x8882             LDRH     R2,[R0, #+4]
   \   00000008   0x4311             ORRS     R1,R1,R2
   \   0000000A   0x8081             STRH     R1,[R0, #+4]
   \   0000000C   0xE003             B.N      ??SPI_I2S_DMACmd_1
    450            }
    451            else
    452            {
    453              /* Disable the selected SPI/I2S DMA requests */
    454              SPIx->CR2 &= (u16)~SPI_I2S_DMAReq;
   \                     ??SPI_I2S_DMACmd_0:
   \   0000000E   0x8882             LDRH     R2,[R0, #+4]
   \   00000010   0xEA32 0x0101      BICS     R1,R2,R1
   \   00000014   0x8081             STRH     R1,[R0, #+4]
    455            }
    456          }
   \                     ??SPI_I2S_DMACmd_1:
   \   00000016   0x4770             BX       LR               ;; return
    457          
    458          /*******************************************************************************
    459          * Function Name  : SPI_I2S_SendData
    460          * Description    : Transmits a Data through the SPIx/I2Sx peripheral.
    461          * Input          : - SPIx: where x can be :
    462          *                         - 1, 2 or 3 in SPI mode 
    463          *                         - 2 or 3 in I2S mode
    464          *                  - Data : Data to be transmitted..
    465          * Output         : None
    466          * Return         : None
    467          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    468          void SPI_I2S_SendData(SPI_TypeDef* SPIx, u16 Data)
    469          {
    470            /* Check the parameters */
    471            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    472            
    473            /* Write in the DR register the data to be sent */
    474            SPIx->DR = Data;
   \                     SPI_I2S_SendData:
   \   00000000   0x8181             STRH     R1,[R0, #+12]
    475          }
   \   00000002   0x4770             BX       LR               ;; return
    476          
    477          /*******************************************************************************
    478          * Function Name  : SPI_I2S_ReceiveData
    479          * Description    : Returns the most recent received data by the SPIx/I2Sx peripheral. 
    480          * Input          : - SPIx: where x can be :
    481          *                         - 1, 2 or 3 in SPI mode 
    482          *                         - 2 or 3 in I2S mode
    483          * Output         : None
    484          * Return         : The value of the received data.
    485          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    486          u16 SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    487          {
    488            /* Check the parameters */
    489            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    490            
    491            /* Return the data in the DR register */
    492            return SPIx->DR;
   \                     SPI_I2S_ReceiveData:
   \   00000000   0x8980             LDRH     R0,[R0, #+12]
   \   00000002   0x4770             BX       LR               ;; return
    493          }
    494          
    495          /*******************************************************************************
    496          * Function Name  : SPI_NSSInternalSoftwareConfig
    497          * Description    : Configures internally by software the NSS pin for the selected 
    498          *                  SPI.
    499          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    500          *                  - SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    501          *                    This parameter can be one of the following values:
    502          *                       - SPI_NSSInternalSoft_Set: Set NSS pin internally
    503          *                       - SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    504          * Output         : None
    505          * Return         : None
    506          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    507          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, u16 SPI_NSSInternalSoft)
    508          {
    509            /* Check the parameters */
    510            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    511            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
    512          
    513            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
   \                     SPI_NSSInternalSoftwareConfig:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0xF64F 0x62FF      MOVW     R2,#+65279
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD004             BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
    514            {
    515              /* Set NSS pin internally by software */
    516              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
   \   0000000A   0x8801             LDRH     R1,[R0, #+0]
   \   0000000C   0xF451 0x7180      ORRS     R1,R1,#0x100
   \   00000010   0x8001             STRH     R1,[R0, #+0]
   \   00000012   0xE004             B.N      ??SPI_NSSInternalSoftwareConfig_1
    517            }
    518            else
    519            {
    520              /* Reset NSS pin internally by software */
    521              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
   \                     ??SPI_NSSInternalSoftwareConfig_0:
   \   00000014   0x8801             LDRH     R1,[R0, #+0]
   \   00000016   0xF64F 0x62FF      MOVW     R2,#+65279
   \   0000001A   0x4011             ANDS     R1,R2,R1
   \   0000001C   0x8001             STRH     R1,[R0, #+0]
    522            }
    523          }
   \                     ??SPI_NSSInternalSoftwareConfig_1:
   \   0000001E   0x4770             BX       LR               ;; return
    524          
    525          /*******************************************************************************
    526          * Function Name  : SPI_SSOutputCmd
    527          * Description    : Enables or disables the SS output for the selected SPI.
    528          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    529          *                  - NewState: new state of the SPIx SS output. 
    530          *                    This parameter can be: ENABLE or DISABLE.
    531          * Output         : None
    532          * Return         : None
    533          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    534          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    535          {
    536            /* Check the parameters */
    537            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    538            assert_param(IS_FUNCTIONAL_STATE(NewState));
    539          
    540            if (NewState != DISABLE)
   \                     SPI_SSOutputCmd:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??SPI_SSOutputCmd_0
    541            {
    542              /* Enable the selected SPI SS output */
    543              SPIx->CR2 |= CR2_SSOE_Set;
   \   00000006   0x8881             LDRH     R1,[R0, #+4]
   \   00000008   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   0000000C   0x8081             STRH     R1,[R0, #+4]
   \   0000000E   0xE004             B.N      ??SPI_SSOutputCmd_1
    544            }
    545            else
    546            {
    547              /* Disable the selected SPI SS output */
    548              SPIx->CR2 &= CR2_SSOE_Reset;
   \                     ??SPI_SSOutputCmd_0:
   \   00000010   0x8881             LDRH     R1,[R0, #+4]
   \   00000012   0xF64F 0x72FB      MOVW     R2,#+65531
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8081             STRH     R1,[R0, #+4]
    549            }
    550          }
   \                     ??SPI_SSOutputCmd_1:
   \   0000001A   0x4770             BX       LR               ;; return
    551          
    552          /*******************************************************************************
    553          * Function Name  : SPI_DataSizeConfig
    554          * Description    : Configures the data size for the selected SPI.
    555          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    556          *                  - SPI_DataSize: specifies the SPI data size.
    557          *                    This parameter can be one of the following values:
    558          *                       - SPI_DataSize_16b: Set data frame format to 16bit
    559          *                       - SPI_DataSize_8b: Set data frame format to 8bit
    560          * Output         : None
    561          * Return         : None
    562          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    563          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, u16 SPI_DataSize)
    564          {
    565            /* Check the parameters */
    566            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    567            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
    568          
    569            /* Clear DFF bit */
    570            SPIx->CR1 &= (u16)~SPI_DataSize_16b;
   \                     SPI_DataSizeConfig:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xF24F 0x73FF      MOVW     R3,#+63487
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8002             STRH     R2,[R0, #+0]
    571            /* Set new DFF bit value */
    572            SPIx->CR1 |= SPI_DataSize;
   \   0000000A   0x8802             LDRH     R2,[R0, #+0]
   \   0000000C   0x4311             ORRS     R1,R1,R2
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
    573          }
   \   00000010   0x4770             BX       LR               ;; return
    574          
    575          /*******************************************************************************
    576          * Function Name  : SPI_TransmitCRC
    577          * Description    : Transmit the SPIx CRC value.
    578          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    579          * Output         : None
    580          * Return         : None
    581          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    582          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    583          {
    584            /* Check the parameters */
    585            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    586            
    587            /* Enable the selected SPI CRC transmission */
    588            SPIx->CR1 |= CR1_CRCNext_Set;
   \                     SPI_TransmitCRC:
   \   00000000   0x8801             LDRH     R1,[R0, #+0]
   \   00000002   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \   00000006   0x8001             STRH     R1,[R0, #+0]
    589          }
   \   00000008   0x4770             BX       LR               ;; return
    590          
    591          /*******************************************************************************
    592          * Function Name  : SPI_CalculateCRC
    593          * Description    : Enables or disables the CRC value calculation of the
    594          *                  transfered bytes.
    595          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    596          *                  - NewState: new state of the SPIx CRC value calculation.
    597          *                    This parameter can be: ENABLE or DISABLE.
    598          * Output         : None
    599          * Return         : None
    600          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    601          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    602          {
    603            /* Check the parameters */
    604            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    605            assert_param(IS_FUNCTIONAL_STATE(NewState));
    606          
    607            if (NewState != DISABLE)
   \                     SPI_CalculateCRC:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0xD004             BEQ.N    ??SPI_CalculateCRC_0
    608            {
    609              /* Enable the selected SPI CRC calculation */
    610              SPIx->CR1 |= CR1_CRCEN_Set;
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xF451 0x5100      ORRS     R1,R1,#0x2000
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
   \   0000000E   0xE004             B.N      ??SPI_CalculateCRC_1
    611            }
    612            else
    613            {
    614              /* Disable the selected SPI CRC calculation */
    615              SPIx->CR1 &= CR1_CRCEN_Reset;
   \                     ??SPI_CalculateCRC_0:
   \   00000010   0x8801             LDRH     R1,[R0, #+0]
   \   00000012   0xF64D 0x72FF      MOVW     R2,#+57343
   \   00000016   0x4011             ANDS     R1,R2,R1
   \   00000018   0x8001             STRH     R1,[R0, #+0]
    616            }
    617          }
   \                     ??SPI_CalculateCRC_1:
   \   0000001A   0x4770             BX       LR               ;; return
    618          
    619          /*******************************************************************************
    620          * Function Name  : SPI_GetCRC
    621          * Description    : Returns the transmit or the receive CRC register value for
    622          *                  the specified SPI.
    623          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    624          *                  - SPI_CRC: specifies the CRC register to be read.
    625          *                    This parameter can be one of the following values:
    626          *                       - SPI_CRC_Tx: Selects Tx CRC register
    627          *                       - SPI_CRC_Rx: Selects Rx CRC register
    628          * Output         : None
    629          * Return         : The selected CRC register value..
    630          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    631          u16 SPI_GetCRC(SPI_TypeDef* SPIx, u8 SPI_CRC)
    632          {
    633            u16 crcreg = 0;
   \                     SPI_GetCRC:
   \   00000000   0x2200             MOVS     R2,#+0
    634          
    635            /* Check the parameters */
    636            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    637            assert_param(IS_SPI_CRC(SPI_CRC));
    638          
    639            if (SPI_CRC != SPI_CRC_Rx)
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD001             BEQ.N    ??SPI_GetCRC_0
    640            {
    641              /* Get the Tx CRC register */
    642              crcreg = SPIx->TXCRCR;
   \   00000008   0x8B02             LDRH     R2,[R0, #+24]
   \   0000000A   0xE000             B.N      ??SPI_GetCRC_1
    643            }
    644            else
    645            {
    646              /* Get the Rx CRC register */
    647              crcreg = SPIx->RXCRCR;
   \                     ??SPI_GetCRC_0:
   \   0000000C   0x8A82             LDRH     R2,[R0, #+20]
    648            }
    649          
    650            /* Return the selected CRC register */
    651            return crcreg;
   \                     ??SPI_GetCRC_1:
   \   0000000E   0x0010             MOVS     R0,R2
   \   00000010   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000012   0x4770             BX       LR               ;; return
    652          }
    653          
    654          /*******************************************************************************
    655          * Function Name  : SPI_GetCRCPolynomial
    656          * Description    : Returns the CRC Polynomial register value for the specified SPI.
    657          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    658          * Output         : None
    659          * Return         : The CRC Polynomial register value.
    660          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    661          u16 SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    662          {
    663            /* Check the parameters */
    664            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    665            
    666            /* Return the CRC polynomial register */
    667            return SPIx->CRCPR;
   \                     SPI_GetCRCPolynomial:
   \   00000000   0x8A00             LDRH     R0,[R0, #+16]
   \   00000002   0x4770             BX       LR               ;; return
    668          }
    669          
    670          /*******************************************************************************
    671          * Function Name  : SPI_BiDirectionalLineConfig
    672          * Description    : Selects the data transfer direction in bi-directional mode
    673          *                  for the specified SPI.
    674          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    675          *                  - SPI_Direction: specifies the data transfer direction in
    676          *                    bi-directional mode. 
    677          *                    This parameter can be one of the following values:
    678          *                       - SPI_Direction_Tx: Selects Tx transmission direction
    679          *                       - SPI_Direction_Rx: Selects Rx receive direction
    680          * Output         : None
    681          * Return         : None
    682          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    683          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, u16 SPI_Direction)
    684          {
    685            /* Check the parameters */
    686            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    687            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    688          
    689            if (SPI_Direction == SPI_Direction_Tx)
   \                     SPI_BiDirectionalLineConfig:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0xF5B1 0x4F80      CMP      R1,#+16384
   \   00000006   0xD104             BNE.N    ??SPI_BiDirectionalLineConfig_0
    690            {
    691              /* Set the Tx only mode */
    692              SPIx->CR1 |= SPI_Direction_Tx;
   \   00000008   0x8801             LDRH     R1,[R0, #+0]
   \   0000000A   0xF451 0x4180      ORRS     R1,R1,#0x4000
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
   \   00000010   0xE004             B.N      ??SPI_BiDirectionalLineConfig_1
    693            }
    694            else
    695            {
    696              /* Set the Rx only mode */
    697              SPIx->CR1 &= SPI_Direction_Rx;
   \                     ??SPI_BiDirectionalLineConfig_0:
   \   00000012   0x8801             LDRH     R1,[R0, #+0]
   \   00000014   0xF64B 0x72FF      MOVW     R2,#+49151
   \   00000018   0x4011             ANDS     R1,R2,R1
   \   0000001A   0x8001             STRH     R1,[R0, #+0]
    698            }
    699          }
   \                     ??SPI_BiDirectionalLineConfig_1:
   \   0000001C   0x4770             BX       LR               ;; return
    700          
    701          /*******************************************************************************
    702          * Function Name  : SPI_I2S_GetFlagStatus
    703          * Description    : Checks whether the specified SPI/I2S flag is set or not.
    704          * Input          : - SPIx: where x can be :
    705          *                         - 1, 2 or 3 in SPI mode 
    706          *                         - 2 or 3 in I2S mode
    707          *                  - SPI_I2S_FLAG: specifies the SPI/I2S flag to check. 
    708          *                    This parameter can be one of the following values:
    709          *                       - SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
    710          *                       - SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
    711          *                       - SPI_I2S_FLAG_BSY: Busy flag.
    712          *                       - SPI_I2S_FLAG_OVR: Overrun flag.
    713          *                       - SPI_FLAG_MODF: Mode Fault flag.
    714          *                       - SPI_FLAG_CRCERR: CRC Error flag.
    715          *                       - I2S_FLAG_UDR: Underrun Error flag.
    716          *                       - I2S_FLAG_CHSIDE: Channel Side flag.
    717          * Output         : None
    718          * Return         : The new state of SPI_I2S_FLAG (SET or RESET).
    719          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    720          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
    721          {
    722            FlagStatus bitstatus = RESET;
   \                     SPI_I2S_GetFlagStatus:
   \   00000000   0x2200             MOVS     R2,#+0
    723          
    724            /* Check the parameters */
    725            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    726            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
    727          
    728            /* Check the status of the specified SPI/I2S flag */
    729            if ((SPIx->SR & SPI_I2S_FLAG) != (u16)RESET)
   \   00000002   0x8900             LDRH     R0,[R0, #+8]
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xD001             BEQ.N    ??SPI_I2S_GetFlagStatus_0
    730            {
    731              /* SPI_I2S_FLAG is set */
    732              bitstatus = SET;
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xE000             B.N      ??SPI_I2S_GetFlagStatus_1
    733            }
    734            else
    735            {
    736              /* SPI_I2S_FLAG is reset */
    737              bitstatus = RESET;
   \                     ??SPI_I2S_GetFlagStatus_0:
   \   0000000C   0x2200             MOVS     R2,#+0
    738            }
    739            /* Return the SPI_I2S_FLAG status */
    740            return  bitstatus;
   \                     ??SPI_I2S_GetFlagStatus_1:
   \   0000000E   0x0010             MOVS     R0,R2
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x4770             BX       LR               ;; return
    741          }
    742          
    743          /*******************************************************************************
    744          * Function Name  : SPI_I2S_ClearFlag
    745          * Description    : Clears the SPIx CRC Error (CRCERR) flag.
    746          * Input          : - SPIx: where x can be :
    747          *                         - 1, 2 or 3 in SPI mode 
    748          *                  - SPI_I2S_FLAG: specifies the SPI flag to clear. 
    749          *                    This function clears only CRCERR flag.                                           
    750          *                  Notes:
    751          *                       - OVR (OverRun error) flag is cleared by software 
    752          *                         sequence: a read operation to SPI_DR register 
    753          *                         (SPI_I2S_ReceiveData()) followed by a read operation 
    754          *                         to SPI_SR register (SPI_I2S_GetFlagStatus()).                           
    755          *                       - UDR (UnderRun error) flag is cleared by a read 
    756          *                         operation to SPI_SR register (SPI_I2S_GetFlagStatus()).                             
    757          *                       - MODF (Mode Fault) flag is cleared by software sequence: 
    758          *                         a read/write operation to SPI_SR register 
    759          *                         (SPI_I2S_GetFlagStatus()) followed by a write 
    760          *                         operation to SPI_CR1 register (SPI_Cmd() to enable 
    761          *                         the SPI).   
    762          * Output         : None
    763          * Return         : None
    764          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    765          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
    766          {
    767            /* Check the parameters */
    768            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    769            assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    770              
    771              /* Clear the selected SPI CRC Error (CRCERR) flag */
    772              SPIx->SR = (u16)~SPI_I2S_FLAG;
   \                     SPI_I2S_ClearFlag:
   \   00000000   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000002   0x43C9             MVNS     R1,R1
   \   00000004   0x8101             STRH     R1,[R0, #+8]
    773          }
   \   00000006   0x4770             BX       LR               ;; return
    774          
    775          /*******************************************************************************
    776          * Function Name  : SPI_I2S_GetITStatus
    777          * Description    : Checks whether the specified SPI/I2S interrupt has occurred or not.
    778          * Input          : - SPIx: where x can be :
    779          *                         - 1, 2 or 3 in SPI mode 
    780          *                         - 2 or 3 in I2S mode
    781          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to check. 
    782          *                    This parameter can be one of the following values:
    783          *                       - SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
    784          *                       - SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
    785          *                       - SPI_I2S_IT_OVR: Overrun interrupt.
    786          *                       - SPI_IT_MODF: Mode Fault interrupt.
    787          *                       - SPI_IT_CRCERR: CRC Error interrupt.
    788          *                       - I2S_IT_UDR: Underrun Error interrupt.
    789          * Output         : None
    790          * Return         : The new state of SPI_I2S_IT (SET or RESET).
    791          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    792          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
    793          {
   \                     SPI_I2S_GetITStatus:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x000A             MOVS     R2,R1
    794            ITStatus bitstatus = RESET;
   \   00000004   0x2100             MOVS     R1,#+0
    795            u16 itpos = 0, itmask = 0, enablestatus = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x2300             MOVS     R3,#+0
    796          
    797            /* Check the parameters */
    798            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    799            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
    800          
    801            /* Get the SPI/I2S IT index */
    802            itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
   \   0000000C   0x2601             MOVS     R6,#+1
   \   0000000E   0xF012 0x070F      ANDS     R7,R2,#0xF
   \   00000012   0x40BE             LSLS     R6,R6,R7
   \   00000014   0x0034             MOVS     R4,R6
    803          
    804            /* Get the SPI/I2S IT mask */
    805            itmask = SPI_I2S_IT >> 4;
   \   00000016   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000018   0x0912             LSRS     R2,R2,#+4
   \   0000001A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001C   0x0015             MOVS     R5,R2
    806            /* Set the IT mask */
    807            itmask = (u16)((u16)0x01 << itmask);
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0xFA12 0xF505      LSLS     R5,R2,R5
    808            /* Get the SPI_I2S_IT enable bit status */
    809            enablestatus = (SPIx->CR2 & itmask) ;
   \   00000024   0x8882             LDRH     R2,[R0, #+4]
   \   00000026   0x402A             ANDS     R2,R5,R2
   \   00000028   0x0013             MOVS     R3,R2
    810          
    811            /* Check the status of the specified SPI/I2S interrupt */
    812            if (((SPIx->SR & itpos) != (u16)RESET) && enablestatus)
   \   0000002A   0x8900             LDRH     R0,[R0, #+8]
   \   0000002C   0x4220             TST      R0,R4
   \   0000002E   0xD004             BEQ.N    ??SPI_I2S_GetITStatus_0
   \   00000030   0xB29B             UXTH     R3,R3            ;; ZeroExt  R3,R3,#+16,#+16
   \   00000032   0x2B00             CMP      R3,#+0
   \   00000034   0xD001             BEQ.N    ??SPI_I2S_GetITStatus_0
    813            {
    814              /* SPI_I2S_IT is set */
    815              bitstatus = SET;
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0xE000             B.N      ??SPI_I2S_GetITStatus_1
    816            }
    817            else
    818            {
    819              /* SPI_I2S_IT is reset */
    820              bitstatus = RESET;
   \                     ??SPI_I2S_GetITStatus_0:
   \   0000003A   0x2100             MOVS     R1,#+0
    821            }
    822            /* Return the SPI_I2S_IT status */
    823            return bitstatus;
   \                     ??SPI_I2S_GetITStatus_1:
   \   0000003C   0x0008             MOVS     R0,R1
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0xBCF0             POP      {R4-R7}
   \   00000042   0x4770             BX       LR               ;; return
    824          }
    825          
    826          /*******************************************************************************
    827          * Function Name  : SPI_I2S_ClearITPendingBit
    828          * Description    : Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
    829          * Input          : - SPIx: where x can be :
    830          *                         - 1, 2 or 3 in SPI mode 
    831          *                  - SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
    832          *                    This function clears only CRCERR intetrrupt pending bit.   
    833          *                  Notes:
    834          *                       - OVR (OverRun Error) interrupt pending bit is cleared 
    835          *                         by software sequence: a read operation to SPI_DR 
    836          *                         register (SPI_I2S_ReceiveData()) followed by a read 
    837          *                         operation to SPI_SR register (SPI_I2S_GetITStatus()).
    838          *                       - UDR (UnderRun Error) interrupt pending bit is cleared 
    839          *                         by a read operation to SPI_SR register 
    840          *                         (SPI_I2S_GetITStatus()).                           
    841          *                       - MODF (Mode Fault) interrupt pending bit is cleared by 
    842          *                         software sequence: a read/write operation to SPI_SR 
    843          *                         register (SPI_I2S_GetITStatus()) followed by a write 
    844          *                         operation to SPI_CR1 register (SPI_Cmd() to enable the 
    845          *                         SPI).   
    846          * Output         : None
    847          * Return         : None
    848          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    849          void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
    850          {
    851            u16 itpos = 0;
   \                     SPI_I2S_ClearITPendingBit:
   \   00000000   0x2200             MOVS     R2,#+0
    852          
    853            /* Check the parameters */
    854            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    855            assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
    856          
    857            /* Get the SPI IT index */
    858            itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
   \   00000002   0x2301             MOVS     R3,#+1
   \   00000004   0xF011 0x010F      ANDS     R1,R1,#0xF
   \   00000008   0xFA13 0xF101      LSLS     R1,R3,R1
   \   0000000C   0x000A             MOVS     R2,R1
    859            /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
    860            SPIx->SR = (u16)~itpos;
   \   0000000E   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   00000010   0x43D1             MVNS     R1,R2
   \   00000012   0x8101             STRH     R1,[R0, #+8]
    861          }
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x40013000         DC32     0x40013000
    862          
    863          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   I2S_Cmd
      40   I2S_Init
        40   -> RCC_GetClocksFreq
       0   I2S_StructInit
       0   SPI_BiDirectionalLineConfig
       0   SPI_CalculateCRC
       0   SPI_Cmd
       0   SPI_DataSizeConfig
       0   SPI_GetCRC
       0   SPI_GetCRCPolynomial
       0   SPI_I2S_ClearFlag
       0   SPI_I2S_ClearITPendingBit
       0   SPI_I2S_DMACmd
       8   SPI_I2S_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   SPI_I2S_GetFlagStatus
      16   SPI_I2S_GetITStatus
       4   SPI_I2S_ITConfig
       0   SPI_I2S_ReceiveData
       0   SPI_I2S_SendData
       4   SPI_Init
       0   SPI_NSSInternalSoftwareConfig
       0   SPI_SSOutputCmd
       0   SPI_StructInit
       0   SPI_TransmitCRC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
      28  I2S_Cmd
     188  I2S_Init
      26  I2S_StructInit
      30  SPI_BiDirectionalLineConfig
      28  SPI_CalculateCRC
      28  SPI_Cmd
      18  SPI_DataSizeConfig
      20  SPI_GetCRC
       4  SPI_GetCRCPolynomial
       8  SPI_I2S_ClearFlag
      22  SPI_I2S_ClearITPendingBit
      24  SPI_I2S_DMACmd
      88  SPI_I2S_DeInit
      20  SPI_I2S_GetFlagStatus
      68  SPI_I2S_GetITStatus
      44  SPI_I2S_ITConfig
       4  SPI_I2S_ReceiveData
       4  SPI_I2S_SendData
      64  SPI_Init
      32  SPI_NSSInternalSoftwareConfig
      28  SPI_SSOutputCmd
      38  SPI_StructInit
      10  SPI_TransmitCRC

 
 836 bytes in section .text
 
 836 bytes of CODE memory

Errors: none
Warnings: none
