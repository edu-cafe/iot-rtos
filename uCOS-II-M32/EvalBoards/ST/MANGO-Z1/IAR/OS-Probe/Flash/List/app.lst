###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      11/Mar/2013  20:18:34 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\app.c                                            #
#    Command line =  C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\app.c -lCN C:\BookSrc_CM3_IAR\Software\EvalBoard #
#                    s\ST\MANGO-Z1\IAR\OS-Probe\Flash\List\ -o                #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\Obj\ --no_cse --no_unroll --no_inline      #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.5\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANG #
#                    O-Z1\IAR\OS-Probe\ -I C:\BookSrc_CM3_IAR\Software\EvalBo #
#                    ards\ST\MANGO-Z1\IAR\OS-Probe\..\BSP\ -I                 #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\CPU\ST\STM32\inc\ -I              #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-CPU\ -I                        #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-CPU\ARM-Cortex-M3\IAR\ -I      #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-LCD\Source\ -I                 #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-LIB\ -I                        #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uCOS-II\Ports\ARM-Cortex-M3\Gener #
#                    ic\IAR\ -I C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MAN #
#                    GO-Z1\IAR\OS-Probe\..\..\..\..\..\uCOS-II\Source\ -I     #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Gen #
#                    eric\RS-232\Source\ -I C:\BookSrc_CM3_IAR\Software\EvalB #
#                    oards\ST\MANGO-Z1\IAR\OS-Probe\..\..\..\..\..\uC-Probe\T #
#                    arget\Communication\Generic\RS-232\Ports\ST\STM32\ -I    #
#                    C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Gen #
#                    eric\Source\ -I C:\BookSrc_CM3_IAR\Software\EvalBoards\S #
#                    T\MANGO-Z1\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\P #
#                    lugins\uCOS-II\ -Ol --use_c++_inline                     #
#    List file    =  C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\List\app.lst                               #
#    Object file  =  C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\O #
#                    S-Probe\Flash\Obj\app.o                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\BookSrc_CM3_IAR\Software\EvalBoards\ST\MANGO-Z1\IAR\OS-Probe\app.c
      1          /*
      2          *********************************************************************************************************
      3          *                                              EXAMPLE CODE
      4          *
      5          *                          (c) Copyright 2003-2006; Micrium, Inc.; Weston, FL
      6          *
      7          *               All rights reserved.  Protected by international copyright laws.
      8          *               Knowledge of the source code may NOT be used to develop a similar product.
      9          *               Please help us continue to provide the Embedded community with the finest
     10          *               software available.  Your honesty is greatly appreciated.
     11          *********************************************************************************************************
     12          */
     13          
     14          /*
     15          *********************************************************************************************************
     16          *
     17          *                                            EXAMPLE CODE
     18          *
     19          *                                     ST Microelectronics STM32
     20          *                                              with the
     21          *                                   STM3210B-EVAL Evaluation Board
     22          *
     23          * Filename      : app.c
     24          * Version       : V1.10
     25          * Programmer(s) : BAN
     26          *********************************************************************************************************
     27          */
     28          
     29          
     30          /*
     31          *********************************************************************************************************
     32          *                                             INCLUDE FILES
     33          *********************************************************************************************************
     34          */
     35          
     36          #include <includes.h>
     37          
     38          
     39          /*
     40          *********************************************************************************************************
     41          *                                            LOCAL DEFINES
     42          *********************************************************************************************************
     43          */
     44          
     45          
     46          /*
     47          *********************************************************************************************************
     48          *                                       LOCAL GLOBAL VARIABLES
     49          *********************************************************************************************************
     50          */
     51          

   \                                 In section .bss, align 4
     52          static  OS_STK         App_TaskStartStk[APP_TASK_START_STK_SIZE];
   \                     App_TaskStartStk:
   \   00000000                      DS8 512
     53          //static  OS_STK         App_TaskUserIFStk[APP_TASK_USER_IF_STK_SIZE];
     54          //static  OS_STK         App_TaskKbdStk[APP_TASK_KBD_STK_SIZE];
     55          

   \                                 In section .bss, align 4
     56          static  OS_STK         App_Task_LED1_Stack[APP_TASK_START_STK_SIZE];
   \                     App_Task_LED1_Stack:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
     57          static  OS_STK         App_Task_LED2_Stack[APP_TASK_START_STK_SIZE];
   \                     App_Task_LED2_Stack:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
     58          static  OS_STK         App_Task_LED3_Stack[APP_TASK_START_STK_SIZE];
   \                     App_Task_LED3_Stack:
   \   00000000                      DS8 512
     59          
     60          //static  OS_EVENT      *App_UserIFMbox;
     61          
     62          
     63          #if 0
     64          #if ((APP_OS_PROBE_EN   == DEF_ENABLED) && \
     65               (APP_PROBE_COM_EN  == DEF_ENABLED) && \
     66               (PROBE_COM_STAT_EN == DEF_ENABLED))
     67          static  CPU_FP32       App_ProbeComRxPktSpd;
     68          static  CPU_FP32       App_ProbeComTxPktSpd;
     69          static  CPU_FP32       App_ProbeComTxSymSpd;
     70          static  CPU_FP32       App_ProbeComTxSymByteSpd;
     71          
     72          static  CPU_INT32U     App_ProbeComRxPktLast;
     73          static  CPU_INT32U     App_ProbeComTxPktLast;
     74          static  CPU_INT32U     App_ProbeComTxSymLast;
     75          static  CPU_INT32U     App_ProbeComTxSymByteLast;
     76          
     77          static  CPU_INT32U     App_ProbeComCtrLast;
     78          #endif
     79          
     80          #if (APP_OS_PROBE_EN == DEF_ENABLED)
     81          static  CPU_INT32U     App_ProbeCounts;
     82          static  CPU_BOOLEAN    App_ProbeB1;
     83          static  CPU_BOOLEAN    App_ProbeJoystickLeft;
     84          static  CPU_BOOLEAN    App_ProbeJoystickRight;
     85          static  CPU_BOOLEAN    App_ProbeJoystickUp;
     86          static  CPU_BOOLEAN    App_ProbeJoystickDown;
     87          static  CPU_BOOLEAN    App_ProbeJoystickCenter;
     88          #endif
     89          
     90          #endif
     91          
     92          /*
     93          *********************************************************************************************************
     94          *                                      LOCAL FUNCTION PROTOTYPES
     95          *********************************************************************************************************
     96          */
     97          
     98          static  void  App_TaskStart        (void        *p_arg);
     99          
    100          #if 0
    101          static  void  App_TaskCreate       (void);
    102          static  void  App_EventCreate      (void);
    103          
    104          
    105          static  void  App_TaskUserIF       (void        *p_arg);
    106          static  void  App_TaskKbd          (void        *p_arg);
    107          
    108          static  void  App_DispScr_SignOn   (void);
    109          static  void  App_DispScr_TaskNames(void);
    110          
    111          
    112          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    113               (APP_OS_PROBE_EN  == DEF_ENABLED))
    114          static  void  App_InitProbe        (void);
    115          #endif
    116          
    117          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    118          static  void  App_ProbeCallback    (void);
    119          #endif
    120          
    121          
    122          static  void  App_FormatDec        (CPU_INT08U  *pstr,
    123                                              CPU_INT32U   value,
    124                                              CPU_INT08U   digits);
    125          #endif
    126          
    127          /*
    128          *********************************************************************************************************
    129          *                                                main()
    130          *
    131          * Description : This is the standard entry point for C code.  It is assumed that your code will call
    132          *               main() once you have performed all necessary initialization.
    133          *
    134          * Argument(s) : none.
    135          *
    136          * Return(s)   : none.
    137          *********************************************************************************************************
    138          */
    139          
    140          #ifndef SOO
    141          #if 0
    142          #define     __IO    volatile
    143          typedef struct {
    144            __IO unsigned int  SR;
    145            __IO unsigned int  DR;
    146            __IO unsigned int  BRR;
    147            __IO unsigned int  CR1;
    148            __IO unsigned int  CR2;
    149            __IO unsigned int  CR3;
    150            __IO unsigned int  GPTR;
    151          } USART_TYPE;
    152          #endif
    153          
    154          #include "stm32f10x_usart.h"
    155          #include "stm32f10x_gpio.h"
    156          
    157          
    158          //#define USART1_BASE         ((unsigned int)0x40000000 + 0x10000 + 0x3800)
    159          //#define USART1              ((USART_TYPE *) USART1_BASE)
    160          
    161          #define TXE     7
    162          #define RXNE    5
    163          

   \                                 In section .text, align 2, keep-with-next
    164          void PutChar(unsigned char c)
    165          {
   \                     PutChar:
   \   00000000   0xB580             PUSH     {R7,LR}
    166            while((USART1->SR & (1<<TXE)) == 0);
   \                     ??PutChar_0:
   \   00000002   0x....             LDR.N    R1,??DataTable5  ;; 0x40013800
   \   00000004   0x8809             LDRH     R1,[R1, #+0]
   \   00000006   0x0609             LSLS     R1,R1,#+24
   \   00000008   0xD5FB             BPL.N    ??PutChar_0
    167            USART1->DR = c;
   \   0000000A   0x....             LDR.N    R1,??DataTable5_1  ;; 0x40013804
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x8008             STRH     R0,[R1, #+0]
    168            if(c == '\n') PutChar('\r');
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x280A             CMP      R0,#+10
   \   00000014   0xD102             BNE.N    ??PutChar_1
   \   00000016   0x200D             MOVS     R0,#+13
   \   00000018   0xF7FF 0xFFF2      BL       PutChar
    169          }
   \                     ??PutChar_1:
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    170          

   \                                 In section .text, align 2, keep-with-next
    171          unsigned char GetChar(void)
    172          {
   \                     GetChar:
   \   00000000   0xB510             PUSH     {R4,LR}
    173            unsigned char data;
    174            
    175            while(!(USART1->SR & (1<<RXNE)));
   \                     ??GetChar_0:
   \   00000002   0x....             LDR.N    R0,??DataTable5  ;; 0x40013800
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x0680             LSLS     R0,R0,#+26
   \   00000008   0xD5FB             BPL.N    ??GetChar_0
    176            data = USART1->DR;
   \   0000000A   0x....             LDR.N    R0,??DataTable5_1  ;; 0x40013804
   \   0000000C   0x8804             LDRH     R4,[R0, #+0]
    177            if(data == '\r') PutChar('\n');   //echo
   \   0000000E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000010   0x2C0D             CMP      R4,#+13
   \   00000012   0xD103             BNE.N    ??GetChar_1
   \   00000014   0x200A             MOVS     R0,#+10
   \   00000016   0x.... 0x....      BL       PutChar
   \   0000001A   0xE003             B.N      ??GetChar_2
    178            else PutChar(data);   //echo
   \                     ??GetChar_1:
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       PutChar
    179            
    180            return data;
   \                     ??GetChar_2:
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
    181          }
    182          

   \                                 In section .text, align 2, keep-with-next
    183          void Puts(unsigned char *str)
    184          {
   \                     Puts:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xE003             B.N      ??Puts_0
    185            while(*str) {
    186              PutChar(*str);
   \                     ??Puts_1:
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x.... 0x....      BL       PutChar
    187              str++;
   \   0000000C   0x1C64             ADDS     R4,R4,#+1
    188            }
   \                     ??Puts_0:
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD1F8             BNE.N    ??Puts_1
    189          }
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    190          

   \                                 In section .text, align 2, keep-with-next
    191          void Gets(unsigned char *buff)
    192          {
   \                     Gets:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0xE001             B.N      ??Gets_0
    193            unsigned char data;
    194            
    195            while(1) {
    196              data = GetChar();
    197              if(data == '\r' || data == '\n') break;
    198              *buff = data;
   \                     ??Gets_1:
   \   00000006   0x7020             STRB     R0,[R4, #+0]
    199              buff++;
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \                     ??Gets_0:
   \   0000000A   0x.... 0x....      BL       GetChar
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x280D             CMP      R0,#+13
   \   00000012   0xD002             BEQ.N    ??Gets_2
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x280A             CMP      R0,#+10
   \   00000018   0xD1F5             BNE.N    ??Gets_1
    200            }
    201            *buff = '\0';
   \                     ??Gets_2:
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x7020             STRB     R0,[R4, #+0]
    202          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    203          
    204          //Define for printf 
    205          //int fputc(int ch, FILE *f)
    206          //{
    207          //  PutChar(ch);
    208          //  return ch;
    209          //}
    210          
    211          #endif
    212          
    213          
    214          #ifndef SOO
    215          #include "stm32f10x_usart.h"
    216          #include "stm32f10x_gpio.h"
    217          //#include "stm32f10x_exti.h"
    218          //#include "stm32f10x_fsmc.h"
    219          //#include <stdint.h>
    220          
    221          /* defines */
    222          
    223          

   \                                 In section .text, align 2, keep-with-next
    224          void USART1_Init(void)
    225          {
   \                     USART1_Init:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    226              USART_InitTypeDef USART_InitStructure;
    227          
    228          
    229              
    230              /* USARTx configuration ------------------------------------------------------*/
    231              /* USARTx configured as follow:
    232               - BaudRate = 115200 baud  
    233               - Word Length = 8 Bits
    234               - One Stop Bit
    235               - No parity
    236               - Hardware flow control disabled (RTS and CTS signals)
    237               - Receive and transmit enabled
    238               */
    239              USART_InitStructure.USART_BaudRate   = 115200;
   \   00000004   0xF45F 0x30E1      MOVS     R0,#+115200
   \   00000008   0x9000             STR      R0,[SP, #+0]
    240              USART_InitStructure.USART_WordLength = USART_WordLength_8b;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    241              USART_InitStructure.USART_StopBits   = USART_StopBits_1;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    242              USART_InitStructure.USART_Parity     = USART_Parity_No ;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    243              USART_InitStructure.USART_HardwareFlowControl
    244                                                   = USART_HardwareFlowControl_None;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    245              USART_InitStructure.USART_Mode       = USART_Mode_Rx | USART_Mode_Tx;
   \   00000022   0x200C             MOVS     R0,#+12
   \   00000024   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    246          
    247              /* Configure the USARTx */ 
    248              USART_Init(USART1, &USART_InitStructure);
   \   00000028   0xA900             ADD      R1,SP,#+0
   \   0000002A   0x....             LDR.N    R0,??DataTable5  ;; 0x40013800
   \   0000002C   0x.... 0x....      BL       USART_Init
    249          
    250              /* Enable the USART1 */
    251              USART_Cmd(USART1, ENABLE);
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x....             LDR.N    R0,??DataTable5  ;; 0x40013800
   \   00000034   0x.... 0x....      BL       USART_Cmd
    252          }
   \   00000038   0xB005             ADD      SP,SP,#+20
   \   0000003A   0xBD00             POP      {PC}             ;; return
    253          

   \                                 In section .text, align 2, keep-with-next
    254          void GPIO_Configuration(void)
    255          {
   \                     GPIO_Configuration:
   \   00000000   0xB580             PUSH     {R7,LR}
    256              GPIO_InitTypeDef GPIO_InitStructure;
    257              
    258          	/* Enable GPIOA clock */
    259              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    260              /* Enable USART1 clocks */
    261              RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0xF44F 0x4080      MOV      R0,#+16384
   \   00000010   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
    262              
    263          
    264              // UART configuration ...
    265          
    266              /* Configure USARTx_Tx as alternate function push-pull */
    267              GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_9;
   \   00000014   0xF44F 0x7000      MOV      R0,#+512
   \   00000018   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    268              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    269              GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
   \   00000022   0x2018             MOVS     R0,#+24
   \   00000024   0xF88D 0x0003      STRB     R0,[SP, #+3]
    270              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000028   0xA900             ADD      R1,SP,#+0
   \   0000002A   0x....             LDR.N    R0,??DataTable5_2  ;; 0x40010800
   \   0000002C   0x.... 0x....      BL       GPIO_Init
    271          
    272              /* Configure USARTx_Rx as input floating */
    273              GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_10;
   \   00000030   0xF44F 0x6080      MOV      R0,#+1024
   \   00000034   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    274              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   \   00000038   0x2004             MOVS     R0,#+4
   \   0000003A   0xF88D 0x0003      STRB     R0,[SP, #+3]
    275              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000003E   0xA900             ADD      R1,SP,#+0
   \   00000040   0x....             LDR.N    R0,??DataTable5_2  ;; 0x40010800
   \   00000042   0x.... 0x....      BL       GPIO_Init
    276              
    277             
    278              //USART_SendData() 사용 시 필요함
    279              //GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;
    280              //GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    281              //GPIO_Init(GPIOB, &GPIO_InitStructure);
    282          }
   \   00000046   0xBD01             POP      {R0,PC}          ;; return
    283          
    284          #if 0
    285          #ifdef __GNUC__
    286            #define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
    287          #else
    288            #define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
    289          #endif /* __GNUC__ */
    290          
    291          
    292          PUTCHAR_PROTOTYPE
    293          {
    294              /* Write a character to the USART */  
    295              if( ch == '\n') {
    296                  USART_SendData(USART1, '\r');
    297                  while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
    298                  USART_SendData(USART1, '\n');
    299              }else {
    300                  USART_SendData(USART1, (u8) ch);
    301              }
    302          
    303              /* Loop until the end of transmission */
    304              while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);
    305          
    306              return ch;
    307          }
    308          
    309          
    310          void Puts(USART_TypeDef *  usart_p, CPU_INT08U *str)
    311          {
    312            while(*str) {
    313              //PutChar(*str);
    314              USART_SendData(usart_p, *str);
    315              str++;
    316            }
    317          }
    318          
    319          CPU_INT08U GetChar(USART_TypeDef *  usart_p)
    320          {
    321              CPU_INT08U data;
    322          
    323              /* Loop until the end of transmission */
    324              while(USART_GetFlagStatus(usart_p, USART_FLAG_RXNE) == RESET);
    325          
    326              /* Write a character to the USART */
    327              data = USART_ReceiveData(usart_p);
    328          
    329              USART_SendData(usart_p, data);
    330              while(USART_GetFlagStatus(usart_p, USART_FLAG_TXE) == RESET);
    331          
    332              if( data == '\r' )  return (int)('\n');
    333              else                return(data);
    334          }
    335          #endif
    336          
    337          #endif
    338          

   \                                 In section .text, align 2, keep-with-next
    339          int  main (void)
    340          {
   \                     main:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    341              CPU_INT08U  os_err;
    342          
    343          	
    344              BSP_IntDisAll();   
   \   00000004   0x.... 0x....      BL       BSP_IntDisAll
    345              //printf("BSP_IntDisAll()..\n"); 
    346              //PutChar('B');                                            /* Disable all ints until we are ready to accept them.  */
    347          
    348              OSInit();  
   \   00000008   0x.... 0x....      BL       OSInit
    349              //printf("OSInit()..\n");
    350              //PutChar('C');  
    351                                                              /* Initialize "uC/OS-II, The Real-Time Kernel".         */
    352          
    353              os_err = OSTaskCreateExt((void (*)(void *)) App_TaskStart,  /* Create the start task.                               */
    354                                       (void          * ) 0,
    355                                       (OS_STK        * )&App_TaskStartStk[APP_TASK_START_STK_SIZE - 1],
    356                                       (INT8U           ) APP_TASK_START_PRIO,
    357                                       (INT16U          ) APP_TASK_START_PRIO,
    358                                       (OS_STK        * )&App_TaskStartStk[0],
    359                                       (INT32U          ) APP_TASK_START_STK_SIZE,
    360                                       (void          * )0,
    361                                       (INT16U          )(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0x9004             STR      R0,[SP, #+16]
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9003             STR      R0,[SP, #+12]
   \   00000014   0x2080             MOVS     R0,#+128
   \   00000016   0x9002             STR      R0,[SP, #+8]
   \   00000018   0x....             LDR.N    R0,??DataTable5_3
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0x2303             MOVS     R3,#+3
   \   00000022   0x....             LDR.N    R2,??DataTable5_4
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x.... 0x....      ADR.W    R0,App_TaskStart
   \   0000002A   0x.... 0x....      BL       OSTaskCreateExt
   \   0000002E   0xF88D 0x0014      STRB     R0,[SP, #+20]
    362          
    363          #if (OS_TASK_NAME_SIZE >= 11)
    364              OSTaskNameSet(APP_TASK_START_PRIO, (CPU_INT08U *)"Start Task", &os_err);
   \   00000032   0xAA05             ADD      R2,SP,#+20
   \   00000034   0x....             LDR.N    R1,??DataTable5_5
   \   00000036   0x2003             MOVS     R0,#+3
   \   00000038   0x.... 0x....      BL       OSTaskNameSet
    365          #endif
    366          
    367              OSStart();                                                  /* Start multitasking (i.e. give control to uC/OS-II).  */
   \   0000003C   0x.... 0x....      BL       OSStart
    368          
    369              return (0);
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xB007             ADD      SP,SP,#+28
   \   00000044   0xBD00             POP      {PC}             ;; return
    370          }
    371          

   \                                 In section .text, align 2, keep-with-next
    372          static void App_LED1_Task(void *p_arg)
    373          {
   \                     App_LED1_Task:
   \   00000000   0xB580             PUSH     {R7,LR}
    374              (void)p_arg;
    375          
    376          	//USART_SendData(USART1, '1');
    377          	PutChar('1');
   \   00000002   0x2031             MOVS     R0,#+49
   \   00000004   0x.... 0x....      BL       PutChar
    378              BSP_LED_On(1);
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       BSP_LED_On
    379              OSTimeDlyHMSM(0, 0, 0, 2000);
   \   0000000E   0xF44F 0x63FA      MOV      R3,#+2000
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       OSTimeDlyHMSM
    380              BSP_LED_Off(1);
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       BSP_LED_Off
    381          
    382              while (DEF_TRUE) {
    383                  BSP_LED_Toggle(1);
   \                     ??App_LED1_Task_0:
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      BL       BSP_LED_Toggle
    384                  OSTimeDlyHMSM(0, 0, 0, 100);
   \   00000028   0x2364             MOVS     R3,#+100
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      BL       OSTimeDlyHMSM
   \   00000034   0xE7F5             B.N      ??App_LED1_Task_0
    385              }
    386          }
    387          

   \                                 In section .text, align 2, keep-with-next
    388          static void App_LED2_Task(void *p_arg)
    389          {
   \                     App_LED2_Task:
   \   00000000   0xB580             PUSH     {R7,LR}
    390              (void)p_arg;
    391          
    392          	//USART_SendData(USART1, '2');
    393          	PutChar('2');
   \   00000002   0x2032             MOVS     R0,#+50
   \   00000004   0x.... 0x....      BL       PutChar
    394              BSP_LED_On(2);
   \   00000008   0x2002             MOVS     R0,#+2
   \   0000000A   0x.... 0x....      BL       BSP_LED_On
    395              OSTimeDlyHMSM(0, 0, 0, 2000);
   \   0000000E   0xF44F 0x63FA      MOV      R3,#+2000
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       OSTimeDlyHMSM
    396              BSP_LED_Off(2);
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0x.... 0x....      BL       BSP_LED_Off
    397          
    398              while (DEF_TRUE) {
    399                  BSP_LED_Toggle(2);
   \                     ??App_LED2_Task_0:
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x.... 0x....      BL       BSP_LED_Toggle
    400                  OSTimeDlyHMSM(0, 0, 0, 200);
   \   00000028   0x23C8             MOVS     R3,#+200
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      BL       OSTimeDlyHMSM
   \   00000034   0xE7F5             B.N      ??App_LED2_Task_0
    401              }
    402          }
    403          

   \                                 In section .text, align 2, keep-with-next
    404          static void App_LED3_Task(void *p_arg)
    405          {
   \                     App_LED3_Task:
   \   00000000   0xB580             PUSH     {R7,LR}
    406              (void)p_arg;
    407          
    408          	//USART_SendData(USART1, '3');
    409          	PutChar('3');
   \   00000002   0x2033             MOVS     R0,#+51
   \   00000004   0x.... 0x....      BL       PutChar
    410              BSP_LED_On(3);
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x.... 0x....      BL       BSP_LED_On
    411              OSTimeDlyHMSM(0, 0, 0, 2000);
   \   0000000E   0xF44F 0x63FA      MOV      R3,#+2000
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       OSTimeDlyHMSM
    412              BSP_LED_Off(3);
   \   0000001C   0x2003             MOVS     R0,#+3
   \   0000001E   0x.... 0x....      BL       BSP_LED_Off
    413          
    414              while (DEF_TRUE) {
    415                  BSP_LED_Toggle(3);
   \                     ??App_LED3_Task_0:
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0x.... 0x....      BL       BSP_LED_Toggle
    416                  OSTimeDlyHMSM(0, 0, 0, 300);
   \   00000028   0xF44F 0x7396      MOV      R3,#+300
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       OSTimeDlyHMSM
   \   00000036   0xE7F4             B.N      ??App_LED3_Task_0
    417              }
    418          }
    419          
    420          /*
    421          *********************************************************************************************************
    422          *                                          App_TaskStart()
    423          *
    424          * Description : The startup task.  The uC/OS-II ticker should only be initialize once multitasking starts.
    425          *
    426          * Argument(s) : p_arg       Argument passed to 'App_TaskStart()' by 'OSTaskCreate()'.
    427          *
    428          * Return(s)   : none.
    429          *
    430          * Caller(s)   : This is a task.
    431          *
    432          * Note(s)     : none.
    433          *********************************************************************************************************
    434          */
    435          

   \                                 In section .text, align 4, keep-with-next
    436          static  void  App_TaskStart (void *p_arg)
    437          {
   \                     App_TaskStart:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB0A7             SUB      SP,SP,#+156
    438          	char buff[128];
    439          	
    440              (void)p_arg;
    441          
    442              CPU_INT08U  os_err;
    443          	
    444          	
    445              BSP_Init(); 
   \   00000004   0x.... 0x....      BL       BSP_Init
    446              
    447              //added by SOO
    448              GPIO_Configuration();
   \   00000008   0x.... 0x....      BL       GPIO_Configuration
    449              USART1_Init(); 
   \   0000000C   0x.... 0x....      BL       USART1_Init
    450              //USART_SendData(USART1, '\r');
    451              //USART_SendData(USART1, '\n');
    452              //USART_SendData(USART1, 'B');
    453              //PutChar('\n');  
    454              //PutChar('A');
    455              Puts("\nBSP_Init() done!\n");
   \   00000010   0x....             LDR.N    R0,??DataTable5_6
   \   00000012   0x.... 0x....      BL       Puts
    456              sprintf(buff,"\nBSP_Init() done_%d!\n", 1);
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable5_7
   \   0000001A   0xA806             ADD      R0,SP,#+24
   \   0000001C   0x.... 0x....      BL       sprintf
    457              Puts((unsigned char*)buff);
   \   00000020   0xA806             ADD      R0,SP,#+24
   \   00000022   0x.... 0x....      BL       Puts
    458                  
    459                                                          /* Initialize BSP functions.                            */
    460              OS_CPU_SysTickInit();                                       /* Initialize the SysTick.                              */
   \   00000026   0x.... 0x....      BL       OS_CPU_SysTickInit
    461          	
    462              Puts("\nOS_CPU_SysTickInit() done!\n");       
   \   0000002A   0x....             LDR.N    R0,??DataTable5_8
   \   0000002C   0x.... 0x....      BL       Puts
    463          
    464          
    465          #if (OS_TASK_STAT_EN > 0)
    466              OSStatInit();                                               /* Determine CPU capacity.                              */
   \   00000030   0x.... 0x....      BL       OSStatInit
    467          #endif
    468          
    469          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    470               (APP_OS_PROBE_EN  == DEF_ENABLED))
    471              //App_InitProbe();
    472          #endif
    473          
    474              //App_EventCreate();                                          /* Create application events.                           */
    475              //App_TaskCreate();                                           /* Create application tasks.                            */
    476          
    477              BSP_LED_Off(0);
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x.... 0x....      BL       BSP_LED_Off
    478              OSTimeDlyHMSM(0, 0, 0, 1000);
   \   0000003A   0xF44F 0x737A      MOV      R3,#+1000
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      BL       OSTimeDlyHMSM
    479              
    480              //printf("All LED off..\n");
    481              
    482              //USART_SendData(USART1, 'E');
    483              //USART_SendData(USART1, '\r');
    484              //USART_SendData(USART1, '\n');
    485              //PutChar('\n');
    486              //PutChar('C');
    487          
    488              os_err = OSTaskCreateExt((void (*)(void *)) App_LED1_Task,  /* Create led task */
    489                              (void          * ) 0,
    490                              (OS_STK        * )&App_Task_LED1_Stack[APP_TASK_START_STK_SIZE - 1],
    491                              (INT8U           ) APP_TASK_LED1_PRIO,
    492                              (INT16U          ) APP_TASK_LED1_PRIO,
    493                              (OS_STK        * )&App_Task_LED1_Stack[0],
    494                              (INT32U          ) APP_TASK_START_STK_SIZE,
    495                              (void          * )0,
    496                              (INT16U          )(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \   00000048   0x2003             MOVS     R0,#+3
   \   0000004A   0x9004             STR      R0,[SP, #+16]
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x9003             STR      R0,[SP, #+12]
   \   00000050   0x2080             MOVS     R0,#+128
   \   00000052   0x9002             STR      R0,[SP, #+8]
   \   00000054   0x....             LDR.N    R0,??DataTable5_9
   \   00000056   0x9001             STR      R0,[SP, #+4]
   \   00000058   0x2007             MOVS     R0,#+7
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0x2307             MOVS     R3,#+7
   \   0000005E   0x....             LDR.N    R2,??DataTable5_10
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x....             LDR.N    R0,??DataTable5_11
   \   00000064   0x.... 0x....      BL       OSTaskCreateExt
   \   00000068   0xF88D 0x0014      STRB     R0,[SP, #+20]
    497          
    498          #if (OS_TASK_NAME_SIZE >= 9)
    499              OSTaskNameSet(APP_TASK_LED1_PRIO, "LED 1", &os_err);
   \   0000006C   0xAA05             ADD      R2,SP,#+20
   \   0000006E   0x....             LDR.N    R1,??DataTable5_12
   \   00000070   0x2007             MOVS     R0,#+7
   \   00000072   0x.... 0x....      BL       OSTaskNameSet
    500          #endif
    501          
    502              OSTimeDlyHMSM(0, 0, 0, 100);
   \   00000076   0x2364             MOVS     R3,#+100
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x.... 0x....      BL       OSTimeDlyHMSM
    503          
    504              os_err = OSTaskCreateExt((void (*)(void *)) App_LED2_Task,  /* Create led task */
    505                              (void          * ) 0,
    506                              (OS_STK        * )&App_Task_LED2_Stack[APP_TASK_START_STK_SIZE - 1],
    507                              (INT8U           ) APP_TASK_LED2_PRIO,
    508                              (INT16U          ) APP_TASK_LED2_PRIO,
    509                              (OS_STK        * )&App_Task_LED2_Stack[0],
    510                              (INT32U          ) APP_TASK_START_STK_SIZE,
    511                              (void          * )0,
    512                              (INT16U          )(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \   00000082   0x2003             MOVS     R0,#+3
   \   00000084   0x9004             STR      R0,[SP, #+16]
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0x9003             STR      R0,[SP, #+12]
   \   0000008A   0x2080             MOVS     R0,#+128
   \   0000008C   0x9002             STR      R0,[SP, #+8]
   \   0000008E   0x....             LDR.N    R0,??DataTable5_13
   \   00000090   0x9001             STR      R0,[SP, #+4]
   \   00000092   0x2008             MOVS     R0,#+8
   \   00000094   0x9000             STR      R0,[SP, #+0]
   \   00000096   0x2308             MOVS     R3,#+8
   \   00000098   0x....             LDR.N    R2,??DataTable5_14
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x....             LDR.N    R0,??DataTable5_15
   \   0000009E   0x.... 0x....      BL       OSTaskCreateExt
   \   000000A2   0xF88D 0x0014      STRB     R0,[SP, #+20]
    513          
    514          #if (OS_TASK_NAME_SIZE >= 9)
    515              OSTaskNameSet(APP_TASK_LED2_PRIO, "LED 2", &os_err);
   \   000000A6   0xAA05             ADD      R2,SP,#+20
   \   000000A8   0x....             LDR.N    R1,??DataTable5_16
   \   000000AA   0x2008             MOVS     R0,#+8
   \   000000AC   0x.... 0x....      BL       OSTaskNameSet
    516          #endif
    517          
    518              OSTimeDlyHMSM(0, 0, 0, 100);
   \   000000B0   0x2364             MOVS     R3,#+100
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x.... 0x....      BL       OSTimeDlyHMSM
    519          
    520              os_err = OSTaskCreateExt((void (*)(void *)) App_LED3_Task,  /* Create led task */
    521                              (void          * ) 0,
    522                              (OS_STK        * )&App_Task_LED3_Stack[APP_TASK_START_STK_SIZE - 1],
    523                              (INT8U           ) APP_TASK_LED3_PRIO,
    524                              (INT16U          ) APP_TASK_LED3_PRIO,
    525                              (OS_STK        * )&App_Task_LED3_Stack[0],
    526                              (INT32U          ) APP_TASK_START_STK_SIZE,
    527                              (void          * )0,
    528                              (INT16U          )(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \   000000BC   0x2003             MOVS     R0,#+3
   \   000000BE   0x9004             STR      R0,[SP, #+16]
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x9003             STR      R0,[SP, #+12]
   \   000000C4   0x2080             MOVS     R0,#+128
   \   000000C6   0x9002             STR      R0,[SP, #+8]
   \   000000C8   0x....             LDR.N    R0,??DataTable5_17
   \   000000CA   0x9001             STR      R0,[SP, #+4]
   \   000000CC   0x2009             MOVS     R0,#+9
   \   000000CE   0x9000             STR      R0,[SP, #+0]
   \   000000D0   0x2309             MOVS     R3,#+9
   \   000000D2   0x....             LDR.N    R2,??DataTable5_18
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0x....             LDR.N    R0,??DataTable5_19
   \   000000D8   0x.... 0x....      BL       OSTaskCreateExt
   \   000000DC   0xF88D 0x0014      STRB     R0,[SP, #+20]
    529          
    530          #if (OS_TASK_NAME_SIZE >= 9)
    531              OSTaskNameSet(APP_TASK_LED3_PRIO, "LED 3", &os_err);
   \   000000E0   0xAA05             ADD      R2,SP,#+20
   \   000000E2   0x....             LDR.N    R1,??DataTable5_20
   \   000000E4   0x2009             MOVS     R0,#+9
   \   000000E6   0x.... 0x....      BL       OSTaskNameSet
    532          #endif
    533          
    534          	Puts("\nLED_Task Created..\n");
   \   000000EA   0x....             LDR.N    R0,??DataTable5_21
   \   000000EC   0x.... 0x....      BL       Puts
    535          
    536              while (DEF_TRUE) { /* Task body, always written as an infinite loop. */
    537                  //OSTimeDlyHMSM(0, 0, 0, 100);
    538                  OSTimeDlyHMSM(0, 0, 1, 0);
   \                     ??App_TaskStart_0:
   \   000000F0   0x2300             MOVS     R3,#+0
   \   000000F2   0x2201             MOVS     R2,#+1
   \   000000F4   0x2100             MOVS     R1,#+0
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x.... 0x....      BL       OSTimeDlyHMSM
   \   000000FC   0xE7F8             B.N      ??App_TaskStart_0
    539              }
    540          }
    541          
    542          
    543          #if 0
    544          
    545          /*
    546          *********************************************************************************************************
    547          *                                             App_EventCreate()
    548          *
    549          * Description : Create the application events.
    550          *
    551          * Argument(s) : none.
    552          *
    553          * Return(s)   : none.
    554          *
    555          * Caller(s)   : App_TaskStart().
    556          *
    557          * Note(s)     : none.
    558          *********************************************************************************************************
    559          */
    560          
    561          static  void  App_EventCreate (void)
    562          {
    563          #if (OS_EVENT_NAME_SIZE > 12)
    564              CPU_INT08U  os_err;
    565          #endif
    566          
    567          
    568              App_UserIFMbox = OSMboxCreate((void *)0);                   /* Create MBOX for communication between Kbd and UserIF.*/
    569          #if (OS_EVENT_NAME_SIZE > 12)
    570              OSEventNameSet(App_UserIFMbox, "User IF Mbox", &os_err);
    571          #endif
    572          }
    573          
    574          
    575          /*
    576          *********************************************************************************************************
    577          *                                            App_TaskCreate()
    578          *
    579          * Description : Create the application tasks.
    580          *
    581          * Argument(s) : none.
    582          *
    583          * Return(s)   : none.
    584          *
    585          * Caller(s)   : App_TaskStart().
    586          *
    587          * Note(s)     : none.
    588          *********************************************************************************************************
    589          */
    590          
    591          static  void  App_TaskCreate (void)
    592          {
    593              CPU_INT08U  os_err;
    594          
    595          
    596              os_err = OSTaskCreateExt((void (*)(void *)) App_TaskUserIF,
    597                                       (void          * ) 0,
    598                                       (OS_STK        * )&App_TaskUserIFStk[APP_TASK_USER_IF_STK_SIZE - 1],
    599                                       (INT8U           ) APP_TASK_USER_IF_PRIO,
    600                                       (INT16U          ) APP_TASK_USER_IF_PRIO,
    601                                       (OS_STK        * )&App_TaskUserIFStk[0],
    602                                       (INT32U          ) APP_TASK_USER_IF_STK_SIZE,
    603                                       (void          * ) 0,
    604                                       (INT16U          )(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
    605          
    606          #if (OS_TASK_NAME_SIZE >= 9)
    607              OSTaskNameSet(APP_TASK_USER_IF_PRIO, "User I/F", &os_err);
    608          #endif
    609          
    610              os_err = OSTaskCreateExt((void (*)(void *)) App_TaskKbd,
    611                                       (void          * ) 0,
    612                                       (OS_STK        * )&App_TaskKbdStk[APP_TASK_KBD_STK_SIZE - 1],
    613                                       (INT8U           ) APP_TASK_KBD_PRIO,
    614                                       (INT16U          ) APP_TASK_KBD_PRIO,
    615                                       (OS_STK        * )&App_TaskKbdStk[0],
    616                                       (INT32U          ) APP_TASK_KBD_STK_SIZE,
    617                                       (void          * ) 0,
    618                                       (INT16U          )(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
    619          
    620          #if (OS_TASK_NAME_SIZE >= 9)
    621              OSTaskNameSet(APP_TASK_KBD_PRIO, "Keyboard", &os_err);
    622          #endif
    623          }
    624          
    625          
    626          /*
    627          *********************************************************************************************************
    628          *                                            App_TaskKbd()
    629          *
    630          * Description : Monitor the state of the push buttons and passes messages to AppTaskUserIF()
    631          *
    632          * Argument(s) : p_arg       Argument passed to 'App_TaskKbd()' by 'OSTaskCreate()'.
    633          *
    634          * Return(s)   : none.
    635          *
    636          * Caller(s)   : This is a task.
    637          *
    638          * Note(s)     : none.
    639          *********************************************************************************************************
    640          */
    641          
    642          static  void  App_TaskKbd (void *p_arg)
    643          {
    644              CPU_BOOLEAN  b1_prev;
    645              CPU_BOOLEAN  b1;
    646              CPU_INT08U   key;
    647          
    648          
    649              (void)p_arg;
    650          
    651              b1_prev = DEF_FALSE;
    652              key     = 1;
    653          
    654              while (DEF_TRUE) {
    655                  b1 = BSP_PB_GetStatus(BSP_PB_ID_KEY);
    656          
    657                  if ((b1 == DEF_TRUE) && (b1_prev == DEF_FALSE)) {
    658                      if (key == 2) {
    659                          key = 1;
    660                      } else {
    661                          key++;
    662                      }
    663          
    664                      OSMboxPost(App_UserIFMbox, (void *)key);
    665                  }
    666          
    667                  b1_prev = b1;
    668          
    669                  OSTimeDlyHMSM(0, 0, 0, 20);
    670              }
    671          }
    672          
    673          
    674          /*
    675          *********************************************************************************************************
    676          *                                            App_TaskUserIF()
    677          *
    678          * Description : Updates LCD.
    679          *
    680          * Argument(s) : p_arg       Argument passed to 'App_TaskUserIF()' by 'OSTaskCreate()'.
    681          *
    682          * Return(s)   : none.
    683          *
    684          * Caller(s)   : This is a task.
    685          *
    686          * Note(s)     : none.
    687          *********************************************************************************************************
    688          */
    689          
    690          static  void  App_TaskUserIF (void *p_arg)
    691          {
    692              CPU_INT08U  *msg;
    693              CPU_INT08U   err;
    694              CPU_INT32U   nstate;
    695              CPU_INT32U   pstate;
    696          
    697          
    698              (void)p_arg;
    699          
    700          
    701              App_DispScr_SignOn();
    702              OSTimeDlyHMSM(0, 0, 1, 0);
    703              nstate = 1;
    704              pstate = 1;
    705          
    706          
    707              while (DEF_TRUE) {
    708                  msg = (CPU_INT08U *)(OSMboxPend(App_UserIFMbox, OS_TICKS_PER_SEC / 10, &err));
    709                  if (err == OS_NO_ERR) {
    710                      nstate = (CPU_INT32U)msg;
    711                  }
    712          
    713                  if (nstate != pstate) {
    714                      LCD_Clear(APP_COLOR_WHITE);
    715                      pstate  = nstate;
    716                  }
    717          
    718                  switch (nstate) {
    719                      case 2:
    720                          App_DispScr_TaskNames();
    721                          break;
    722          
    723                      case 1:
    724                      default:
    725                          App_DispScr_SignOn();
    726                          break;
    727                  }
    728              }
    729          }
    730          
    731          
    732          /*
    733          *********************************************************************************************************
    734          *                                          App_DispScr_SignOn()
    735          *
    736          * Description : Display uC/OS-II system information on the LCD.
    737          *
    738          * Argument(s) : none.
    739          *
    740          * Return(s)   : none.
    741          *
    742          * Caller(s)   : App_TaskUserIF().
    743          *
    744          * Note(s)     : none.
    745          *********************************************************************************************************
    746          */
    747          
    748          static  void  App_DispScr_SignOn (void)
    749          {
    750              CPU_INT32U  value;
    751          
    752          
    753              Str_Copy(App_LCDLine0, "  Micrium uC/OS-II  ");
    754              Str_Copy(App_LCDLine1, "ST STM32 (Cortex-M3)");
    755          
    756              Str_Copy(App_LCDLine2, "                    ");
    757          
    758              Str_Copy(App_LCDLine3, "  uC/OS-II:  Vx.yy  ");
    759              value            = (CPU_INT32U)OSVersion();
    760              App_LCDLine3[14] =  value / 100 + '0';
    761              App_LCDLine3[16] = (value % 100) / 10 + '0';
    762              App_LCDLine3[17] = (value %  10) + '0';
    763          
    764              Str_Copy(App_LCDLine4, "  TickRate:   xxxx  ");
    765              value = (CPU_INT32U)OS_TICKS_PER_SEC;
    766              App_FormatDec(&App_LCDLine4[14], value, 4);
    767          
    768              Str_Copy(App_LCDLine5, "  CPU Usage:xx %    ");
    769              value            = (CPU_INT32U)OSCPUUsage;
    770              App_LCDLine5[12] = (value / 10) + '0';
    771              App_LCDLine5[13] = (value % 10) + '0';
    772          
    773              Str_Copy(App_LCDLine6, "  CPU Speed:xx MHz  ");
    774              value            = (CPU_INT32U)BSP_CPU_ClkFreq() / 1000000L;
    775              App_LCDLine6[12] = (value / 10) + '0';
    776              App_LCDLine6[13] = (value % 10) + '0';
    777          
    778              Str_Copy(App_LCDLine7, "  #Ticks: xxxxxxxx  ");
    779              value = (CPU_INT32U)OSTime;
    780              App_FormatDec(&App_LCDLine7[10], value, 8);
    781          
    782              Str_Copy(App_LCDLine8, "  #CtxSw: xxxxxxxx  ");
    783              value = (CPU_INT32U)OSCtxSwCtr;
    784              App_FormatDec(&App_LCDLine8[10], value, 8);
    785          
    786              Str_Copy(App_LCDLine9, "                    ");
    787          
    788              LCD_SetTextColor(APP_COLOR_BLUE);
    789              LCD_DisplayString(APP_LINE_0, App_LCDLine0);
    790              LCD_DisplayString(APP_LINE_1, App_LCDLine1);
    791              LCD_SetTextColor(APP_COLOR_BLACK);
    792              LCD_DisplayString(APP_LINE_2, App_LCDLine2);
    793              LCD_DisplayString(APP_LINE_3, App_LCDLine3);
    794              LCD_DisplayString(APP_LINE_4, App_LCDLine4);
    795              LCD_DisplayString(APP_LINE_5, App_LCDLine5);
    796              LCD_DisplayString(APP_LINE_6, App_LCDLine6);
    797              LCD_DisplayString(APP_LINE_7, App_LCDLine7);
    798              LCD_DisplayString(APP_LINE_8, App_LCDLine8);
    799          }
    800          
    801          
    802          
    803          /*
    804          *********************************************************************************************************
    805          *                                          App_DispScr_SignOn()
    806          *
    807          * Description : Display uC/OS-II system information on the LCD.
    808          *
    809          * Argument(s) : none.
    810          *
    811          * Return(s)   : none.
    812          *
    813          * Caller(s)   : App_TaskUserIF().
    814          *
    815          * Note(s)     : none.
    816          *********************************************************************************************************
    817          */
    818          
    819          static  void  App_DispScr_TaskNames (void)
    820          {
    821              CPU_INT08U   ix;
    822              OS_TCB      *ptcb;
    823              CPU_CHAR    *line;
    824              CPU_INT08U   value;
    825          
    826          
    827              ptcb = &OSTCBTbl[0];
    828              ix   = 0;
    829          
    830              Str_Copy(App_LCDLine0, "  Micrium uC/OS-II  ");
    831              Str_Copy(App_LCDLine1, "ST STM32 (Cortex-M3)");
    832          
    833              Str_Copy(App_LCDLine2, "  Prio   Taskname   ");
    834          
    835              while (ptcb != NULL) {
    836                  value = ptcb->OSTCBPrio;
    837          
    838                  switch (ix) {
    839                      case 0:
    840                           line = App_LCDLine3;
    841                           break;
    842          
    843                      case 1:
    844                           line = App_LCDLine4;
    845                           break;
    846          
    847                      case 2:
    848                           line = App_LCDLine5;
    849                           break;
    850          
    851                      case 3:
    852                           line = App_LCDLine6;
    853                           break;
    854          
    855                      case 4:
    856                           line = App_LCDLine7;
    857                           break;
    858          
    859                      case 5:
    860                           line = App_LCDLine8;
    861                           break;
    862          
    863                      case 6:
    864                           line = App_LCDLine9;
    865                           break;
    866          
    867                      default:
    868                           line = (CPU_CHAR *)0;
    869                           break;
    870                  }
    871          
    872                  if (line == (CPU_CHAR *)0) {
    873                      break;
    874                  }
    875          
    876                  line[0] = ' ';
    877                  line[1] = ' ';
    878                  line[2] = ' ';
    879                  line[3] = value / 10 + '0';
    880                  line[4] = value % 10 + '0';
    881                  line[5] = ' ';
    882                  Str_Copy_N(line + 6, ptcb->OSTCBTaskName, 14);
    883          
    884                  ptcb    = ptcb->OSTCBPrev;
    885                  ix++;
    886              }
    887          
    888              if (ix < 6) {
    889                  Str_Copy(App_LCDLine9, "                    ");
    890              }
    891          
    892              if (ix < 5) {
    893                  Str_Copy(App_LCDLine8, "                    ");
    894              }
    895          
    896              if (ix < 4) {
    897                  Str_Copy(App_LCDLine7, "                    ");
    898              }
    899          
    900              if (ix < 3) {
    901                  Str_Copy(App_LCDLine6, "                    ");
    902              }
    903          
    904              LCD_SetTextColor(APP_COLOR_BLUE);
    905              LCD_DisplayString(APP_LINE_0, App_LCDLine0);
    906              LCD_DisplayString(APP_LINE_1, App_LCDLine1);
    907              LCD_SetTextColor(APP_COLOR_RED);
    908              LCD_DisplayString(APP_LINE_2, App_LCDLine2);
    909              LCD_SetTextColor(APP_COLOR_BLACK);
    910              LCD_DisplayString(APP_LINE_3, App_LCDLine3);
    911              LCD_DisplayString(APP_LINE_4, App_LCDLine4);
    912              LCD_DisplayString(APP_LINE_5, App_LCDLine5);
    913              LCD_DisplayString(APP_LINE_6, App_LCDLine6);
    914              LCD_DisplayString(APP_LINE_7, App_LCDLine7);
    915              LCD_DisplayString(APP_LINE_8, App_LCDLine8);
    916              LCD_DisplayString(APP_LINE_9, App_LCDLine9);
    917          }
    918          
    919          
    920          /*
    921          *********************************************************************************************************
    922          *                                             App_InitProbe()
    923          *
    924          * Description : Initialize uC/Probe target code.
    925          *
    926          * Argument(s) : none.
    927          *
    928          * Return(s)   : none.
    929          *
    930          * Caller(s)   : App_TaskStart().
    931          *
    932          * Note(s)     : none.
    933          *********************************************************************************************************
    934          */
    935          
    936          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    937               (APP_OS_PROBE_EN  == DEF_ENABLED))
    938          static  void  App_InitProbe (void)
    939          {
    940          #if (APP_OS_PROBE_EN        == DEF_ENABLED)
    941              (void)App_ProbeCounts;
    942              (void)App_ProbeB1;
    943              (void)App_ProbeJoystickCenter;
    944              (void)App_ProbeJoystickDown;
    945              (void)App_ProbeJoystickLeft;
    946              (void)App_ProbeJoystickRight;
    947              (void)App_ProbeJoystickUp;
    948          
    949          #if ((APP_PROBE_COM_EN      == DEF_ENABLED) && \
    950               (PROBE_COM_STAT_EN     == DEF_ENABLED))
    951              (void)App_ProbeComRxPktSpd;
    952              (void)App_ProbeComTxPktSpd;
    953              (void)App_ProbeComTxSymSpd;
    954              (void)App_ProbeComTxSymByteSpd;
    955          #endif
    956          
    957              OSProbe_Init();
    958              OSProbe_SetCallback(App_ProbeCallback);
    959              OSProbe_SetDelay(250);
    960          #endif
    961          
    962          #if (APP_PROBE_COM_EN       == DEF_ENABLED)
    963              ProbeCom_Init();                                            /* Initialize the uC/Probe communications module.       */
    964          #if (PROBE_COM_METHOD_RS232 == DEF_ENABLED)
    965              ProbeRS232_Init(115200);
    966              ProbeRS232_RxIntEn();
    967          #endif
    968          #endif
    969          }
    970          #endif
    971          
    972          
    973          /*
    974          *********************************************************************************************************
    975          *                                         AppProbeCallback()
    976          *
    977          * Description : uC/Probe OS plugin callback.
    978          *
    979          * Argument(s) : none.
    980          *
    981          * Return(s)   : none.
    982          *
    983          * Caller(s)   : uC/Probe OS plugin task.
    984          *
    985          * Note(s)     : none.
    986          *********************************************************************************************************
    987          */
    988          
    989          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    990          static  void  App_ProbeCallback (void)
    991          {
    992          
    993          #if ((APP_PROBE_COM_EN  == DEF_ENABLED) && \
    994               (PROBE_COM_STAT_EN == DEF_ENABLED))
    995              CPU_INT32U  ctr_curr;
    996              CPU_INT32U  rxpkt_curr;
    997              CPU_INT32U  txpkt_curr;
    998              CPU_INT32U  sym_curr;
    999              CPU_INT32U  symbyte_curr;
   1000          #endif
   1001              CPU_INT32U  joystick;
   1002          
   1003          
   1004              App_ProbeCounts++;
   1005          
   1006              App_ProbeB1             = BSP_PB_GetStatus(1);
   1007          
   1008              joystick                = BSP_Joystick_GetStatus();
   1009              App_ProbeJoystickCenter = DEF_BIT_IS_SET(joystick, BSP_JOYSTICK_CENTER);
   1010              App_ProbeJoystickDown   = DEF_BIT_IS_SET(joystick, BSP_JOYSTICK_DOWN);
   1011              App_ProbeJoystickLeft   = DEF_BIT_IS_SET(joystick, BSP_JOYSTICK_LEFT);
   1012              App_ProbeJoystickRight  = DEF_BIT_IS_SET(joystick, BSP_JOYSTICK_RIGHT);
   1013              App_ProbeJoystickUp     = DEF_BIT_IS_SET(joystick, BSP_JOYSTICK_UP);
   1014          
   1015          
   1016          #if ((APP_PROBE_COM_EN  == DEF_ENABLED) && \
   1017               (PROBE_COM_STAT_EN == DEF_ENABLED))
   1018              ctr_curr     = OSTime;
   1019              rxpkt_curr   = ProbeCom_RxPktCtr;
   1020              txpkt_curr   = ProbeCom_TxPktCtr;
   1021              sym_curr     = ProbeCom_TxSymCtr;
   1022              symbyte_curr = ProbeCom_TxSymByteCtr;
   1023          
   1024              if ((ctr_curr - App_ProbeComCtrLast) >= OS_TICKS_PER_SEC) {
   1025                  App_ProbeComRxPktSpd      = ((CPU_FP32)(rxpkt_curr   - App_ProbeComRxPktLast)     / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
   1026                  App_ProbeComTxPktSpd      = ((CPU_FP32)(txpkt_curr   - App_ProbeComTxPktLast)     / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
   1027                  App_ProbeComTxSymSpd      = ((CPU_FP32)(sym_curr     - App_ProbeComTxSymLast)     / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
   1028                  App_ProbeComTxSymByteSpd  = ((CPU_FP32)(symbyte_curr - App_ProbeComTxSymByteLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
   1029          
   1030                  App_ProbeComCtrLast       = ctr_curr;
   1031                  App_ProbeComRxPktLast     = rxpkt_curr;
   1032                  App_ProbeComTxPktLast     = txpkt_curr;
   1033                  App_ProbeComTxSymLast     = sym_curr;
   1034                  App_ProbeComTxSymByteLast = symbyte_curr;
   1035              }
   1036          #endif
   1037          }
   1038          #endif
   1039          
   1040          
   1041          /*
   1042          *********************************************************************************************************
   1043          *                                      App_FormatDec()
   1044          *
   1045          * Description : Convert a decimal value to ASCII (without leading zeros).
   1046          *
   1047          * Argument(s) : pstr            Pointer to the destination ASCII string.
   1048          *
   1049          *               value           Value to convert (assumes an unsigned value).
   1050          *
   1051          *               digits          The desired number of digits.
   1052          *
   1053          * Return(s)   : none.
   1054          *
   1055          * Caller(s)   : various.
   1056          *
   1057          * Note(s)     : none.
   1058          *********************************************************************************************************
   1059          */
   1060          
   1061          static  void  App_FormatDec (CPU_INT08U *pstr, CPU_INT32U value, CPU_INT08U digits)
   1062          {
   1063              CPU_INT08U   i;
   1064              CPU_INT32U   mult;
   1065              CPU_BOOLEAN  found;
   1066              CPU_INT32U   nbr;
   1067          
   1068          
   1069              found = DEF_NO;
   1070              mult  = 1;
   1071              for (i = 0; i < (digits - 1); i++) {
   1072                  mult *= 10;
   1073              }
   1074              while (mult > 0) {
   1075                  nbr = value / mult;
   1076                  if (found == DEF_NO) {
   1077                      if (nbr != 0) {
   1078                          found = DEF_YES;
   1079                          *pstr = nbr + '0';
   1080                      } else{
   1081                          if (mult == 1) {
   1082                              *pstr = '0';
   1083                          } else {
   1084                              *pstr = ' ';
   1085                          }
   1086                      }
   1087                  } else {
   1088                      *pstr = nbr + '0';
   1089                  }
   1090                  pstr++;
   1091                  value %= mult;
   1092                  mult  /= 10;
   1093              }
   1094          }
   1095          
   1096          #endif
   1097          
   1098          
   1099          /*
   1100          *********************************************************************************************************
   1101          *********************************************************************************************************
   1102          *                                          uC/OS-II APP HOOKS
   1103          *********************************************************************************************************
   1104          *********************************************************************************************************
   1105          */
   1106          
   1107          #if (OS_APP_HOOKS_EN > 0)
   1108          /*
   1109          *********************************************************************************************************
   1110          *                                      TASK CREATION HOOK (APPLICATION)
   1111          *
   1112          * Description : This function is called when a task is created.
   1113          *
   1114          * Argument(s) : ptcb   is a pointer to the task control block of the task being created.
   1115          *
   1116          * Note(s)     : (1) Interrupts are disabled during this call.
   1117          *********************************************************************************************************
   1118          */
   1119          

   \                                 In section .text, align 2, keep-with-next
   1120          void  App_TaskCreateHook (OS_TCB *ptcb)
   1121          {
   \                     App_TaskCreateHook:
   \   00000000   0xB580             PUSH     {R7,LR}
   1122          #if ((APP_OS_PROBE_EN   == DEF_ENABLED) && \
   1123               (OS_PROBE_HOOKS_EN == DEF_ENABLED))
   1124              OSProbe_TaskCreateHook(ptcb);
   \   00000002   0x.... 0x....      BL       OSProbe_TaskCreateHook
   1125          #endif
   1126          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
   1127          
   1128          /*
   1129          *********************************************************************************************************
   1130          *                                    TASK DELETION HOOK (APPLICATION)
   1131          *
   1132          * Description : This function is called when a task is deleted.
   1133          *
   1134          * Argument(s) : ptcb   is a pointer to the task control block of the task being deleted.
   1135          *
   1136          * Note(s)     : (1) Interrupts are disabled during this call.
   1137          *********************************************************************************************************
   1138          */
   1139          

   \                                 In section .text, align 2, keep-with-next
   1140          void  App_TaskDelHook (OS_TCB *ptcb)
   1141          {
   1142              (void)ptcb;
   1143          }
   \                     App_TaskDelHook:
   \   00000000   0x4770             BX       LR               ;; return
   1144          
   1145          /*
   1146          *********************************************************************************************************
   1147          *                                      IDLE TASK HOOK (APPLICATION)
   1148          *
   1149          * Description : This function is called by OSTaskIdleHook(), which is called by the idle task.  This hook
   1150          *               has been added to allow you to do such things as STOP the CPU to conserve power.
   1151          *
   1152          * Argument(s) : none.
   1153          *
   1154          * Note(s)     : (1) Interrupts are enabled during this call.
   1155          *********************************************************************************************************
   1156          */
   1157          
   1158          #if OS_VERSION >= 251

   \                                 In section .text, align 2, keep-with-next
   1159          void  App_TaskIdleHook (void)
   1160          {
   1161          }
   \                     App_TaskIdleHook:
   \   00000000   0x4770             BX       LR               ;; return
   1162          #endif
   1163          
   1164          /*
   1165          *********************************************************************************************************
   1166          *                                        STATISTIC TASK HOOK (APPLICATION)
   1167          *
   1168          * Description : This function is called by OSTaskStatHook(), which is called every second by uC/OS-II's
   1169          *               statistics task.  This allows your application to add functionality to the statistics task.
   1170          *
   1171          * Argument(s) : none.
   1172          *********************************************************************************************************
   1173          */
   1174          

   \                                 In section .text, align 2, keep-with-next
   1175          void  App_TaskStatHook (void)
   1176          {
   1177          }
   \                     App_TaskStatHook:
   \   00000000   0x4770             BX       LR               ;; return
   1178          
   1179          /*
   1180          *********************************************************************************************************
   1181          *                                        TASK SWITCH HOOK (APPLICATION)
   1182          *
   1183          * Description : This function is called when a task switch is performed.  This allows you to perform other
   1184          *               operations during a context switch.
   1185          *
   1186          * Argument(s) : none.
   1187          *
   1188          * Note(s)     : (1) Interrupts are disabled during this call.
   1189          *
   1190          *               (2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
   1191          *                   will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
   1192          *                  task being switched out (i.e. the preempted task).
   1193          *********************************************************************************************************
   1194          */
   1195          
   1196          #if OS_TASK_SW_HOOK_EN > 0

   \                                 In section .text, align 2, keep-with-next
   1197          void  App_TaskSwHook (void)
   1198          {
   \                     App_TaskSwHook:
   \   00000000   0xB580             PUSH     {R7,LR}
   1199          #if ((APP_OS_PROBE_EN   == DEF_ENABLED) && \
   1200               (OS_PROBE_HOOKS_EN == DEF_ENABLED))
   1201              OSProbe_TaskSwHook();
   \   00000002   0x.... 0x....      BL       OSProbe_TaskSwHook
   1202          #endif
   1203          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return
   1204          #endif
   1205          
   1206          /*
   1207          *********************************************************************************************************
   1208          *                                     OS_TCBInit() HOOK (APPLICATION)
   1209          *
   1210          * Description : This function is called by OSTCBInitHook(), which is called by OS_TCBInit() after setting
   1211          *               up most of the TCB.
   1212          *
   1213          * Argument(s) : ptcb    is a pointer to the TCB of the task being created.
   1214          *
   1215          * Note(s)     : (1) Interrupts may or may not be ENABLED during this call.
   1216          *********************************************************************************************************
   1217          */
   1218          
   1219          #if OS_VERSION >= 204

   \                                 In section .text, align 2, keep-with-next
   1220          void  App_TCBInitHook (OS_TCB *ptcb)
   1221          {
   1222              (void)ptcb;
   1223          }
   \                     App_TCBInitHook:
   \   00000000   0x4770             BX       LR               ;; return
   1224          #endif
   1225          
   1226          /*
   1227          *********************************************************************************************************
   1228          *                                        TICK HOOK (APPLICATION)
   1229          *
   1230          * Description : This function is called every tick.
   1231          *
   1232          * Argument(s) : none.
   1233          *
   1234          * Note(s)     : (1) Interrupts may or may not be ENABLED during this call.
   1235          *********************************************************************************************************
   1236          */
   1237          
   1238          #if OS_TIME_TICK_HOOK_EN > 0

   \                                 In section .text, align 2, keep-with-next
   1239          void  App_TimeTickHook (void)
   1240          {
   \                     App_TimeTickHook:
   \   00000000   0xB580             PUSH     {R7,LR}
   1241          #if ((APP_OS_PROBE_EN   == DEF_ENABLED) && \
   1242               (OS_PROBE_HOOKS_EN == DEF_ENABLED))
   1243              OSProbe_TickHook();
   \   00000002   0x.... 0x....      BL       OSProbe_TickHook
   1244          #endif
   1245          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40013804         DC32     0x40013804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     App_TaskStartStk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     App_TaskStartStk+0x1FC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     `?<Constant "Start Task">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     `?<Constant "\\nBSP_Init() done!\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     `?<Constant "\\nBSP_Init() done_%d!\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     `?<Constant "\\nOS_CPU_SysTickInit()...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     App_Task_LED1_Stack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     App_Task_LED1_Stack+0x1FC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x........         DC32     App_LED1_Task

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x........         DC32     `?<Constant "LED 1">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x........         DC32     App_Task_LED2_Stack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x........         DC32     App_Task_LED2_Stack+0x1FC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x........         DC32     App_LED2_Task

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x........         DC32     `?<Constant "LED 2">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x........         DC32     App_Task_LED3_Stack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x........         DC32     App_Task_LED3_Stack+0x1FC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x........         DC32     App_LED3_Task

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_20:
   \   00000000   0x........         DC32     `?<Constant "LED 3">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_21:
   \   00000000   0x........         DC32     `?<Constant "\\nLED_Task Created..\\n">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "Start Task">`:
   \   00000000   0x53 0x74          DC8 "Start Task"
   \              0x61 0x72    
   \              0x74 0x20    
   \              0x54 0x61    
   \              0x73 0x6B    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nBSP_Init() done!\\n">`:
   \   00000000   0x0A 0x42          DC8 "\012BSP_Init() done!\012"
   \              0x53 0x50    
   \              0x5F 0x49    
   \              0x6E 0x69    
   \              0x74 0x28    
   \              0x29 0x20    
   \              0x64 0x6F    
   \              0x6E 0x65    
   \              0x21 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nBSP_Init() done_%d!\\n">`:
   \   00000000   0x0A 0x42          DC8 "\012BSP_Init() done_%d!\012"
   \              0x53 0x50    
   \              0x5F 0x49    
   \              0x6E 0x69    
   \              0x74 0x28    
   \              0x29 0x20    
   \              0x64 0x6F    
   \              0x6E 0x65    
   \              0x5F 0x25    
   \              0x64 0x21    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nOS_CPU_SysTickInit()...">`:
   \   00000000   0x0A 0x4F          DC8 "\012OS_CPU_SysTickInit() done!\012"
   \              0x53 0x5F    
   \              0x43 0x50    
   \              0x55 0x5F    
   \              0x53 0x79    
   \              0x73 0x54    
   \              0x69 0x63    
   \              0x6B 0x49    
   \              0x6E 0x69    
   \              0x74 0x28    
   \              0x29 0x20    
   \              0x64 0x6F    
   \              0x6E 0x65    
   \              0x21 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "LED 1">`:
   \   00000000   0x4C 0x45          DC8 "LED 1"
   \              0x44 0x20    
   \              0x31 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "LED 2">`:
   \   00000000   0x4C 0x45          DC8 "LED 2"
   \              0x44 0x20    
   \              0x32 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "LED 3">`:
   \   00000000   0x4C 0x45          DC8 "LED 3"
   \              0x44 0x20    
   \              0x33 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nLED_Task Created..\\n">`:
   \   00000000   0x0A 0x4C          DC8 "\012LED_Task Created..\012"
   \              0x45 0x44    
   \              0x5F 0x54    
   \              0x61 0x73    
   \              0x6B 0x20    
   \              0x43 0x72    
   \              0x65 0x61    
   \              0x74 0x65    
   \              0x64 0x2E    
   \              0x2E 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1246          #endif
   1247          #endif
   1248          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   App_LED1_Task
         8   -> BSP_LED_Off
         8   -> BSP_LED_On
         8   -> BSP_LED_Toggle
         8   -> OSTimeDlyHMSM
         8   -> PutChar
       8   App_LED2_Task
         8   -> BSP_LED_Off
         8   -> BSP_LED_On
         8   -> BSP_LED_Toggle
         8   -> OSTimeDlyHMSM
         8   -> PutChar
       8   App_LED3_Task
         8   -> BSP_LED_Off
         8   -> BSP_LED_On
         8   -> BSP_LED_Toggle
         8   -> OSTimeDlyHMSM
         8   -> PutChar
       0   App_TCBInitHook
       8   App_TaskCreateHook
         8   -> OSProbe_TaskCreateHook
       0   App_TaskDelHook
       0   App_TaskIdleHook
     160   App_TaskStart
       160   -> BSP_Init
       160   -> BSP_LED_Off
       160   -> GPIO_Configuration
       160   -> OSStatInit
       160   -> OSTaskCreateExt
       160   -> OSTaskNameSet
       160   -> OSTimeDlyHMSM
       160   -> OS_CPU_SysTickInit
       160   -> Puts
       160   -> USART1_Init
       160   -> sprintf
       0   App_TaskStatHook
       8   App_TaskSwHook
         8   -> OSProbe_TaskSwHook
       8   App_TimeTickHook
         8   -> OSProbe_TickHook
       8   GPIO_Configuration
         8   -> GPIO_Init
         8   -> RCC_APB2PeriphClockCmd
       8   GetChar
         8   -> PutChar
       8   Gets
         8   -> GetChar
       8   PutChar
         8   -> PutChar
       8   Puts
         8   -> PutChar
      24   USART1_Init
        24   -> USART_Cmd
        24   -> USART_Init
      32   main
        32   -> BSP_IntDisAll
        32   -> OSInit
        32   -> OSStart
        32   -> OSTaskCreateExt
        32   -> OSTaskNameSet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant "LED 1">
       8  ?<Constant "LED 2">
       8  ?<Constant "LED 3">
      12  ?<Constant "Start Task">
      20  ?<Constant "\nBSP_Init() done!\n">
      24  ?<Constant "\nBSP_Init() done_%d!\n">
      24  ?<Constant "\nLED_Task Created..\n">
      32  ?<Constant "\nOS_CPU_SysTickInit()...">
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      54  App_LED1_Task
      54  App_LED2_Task
      56  App_LED3_Task
       2  App_TCBInitHook
       8  App_TaskCreateHook
       2  App_TaskDelHook
       2  App_TaskIdleHook
     254  App_TaskStart
     512  App_TaskStartStk
       2  App_TaskStatHook
       8  App_TaskSwHook
     512  App_Task_LED1_Stack
     512  App_Task_LED2_Stack
     512  App_Task_LED3_Stack
       8  App_TimeTickHook
      72  GPIO_Configuration
      42  GetChar
      32  Gets
      30  PutChar
      22  Puts
      60  USART1_Init
      70  main

 
 2 048 bytes in section .bss
   136 bytes in section .rodata
   866 bytes in section .text
 
   866 bytes of CODE  memory
   136 bytes of CONST memory
 2 048 bytes of DATA  memory

Errors: none
Warnings: none
